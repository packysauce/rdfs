// This file is generated by rust-protobuf 2.20.0. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![rustfmt::skip]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `NamenodeProtocol.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_20_0;

#[derive(PartialEq,Clone,Default)]
pub struct GetBlocksRequestProto {
    // message fields
    pub datanode: ::protobuf::SingularPtrField<super::hdfs::DatanodeIDProto>,
    size: ::std::option::Option<u64>,
    minBlockSize: ::std::option::Option<u64>,
    timeInterval: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetBlocksRequestProto {
    fn default() -> &'a GetBlocksRequestProto {
        <GetBlocksRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl GetBlocksRequestProto {
    pub fn new() -> GetBlocksRequestProto {
        ::std::default::Default::default()
    }

    // required .hadoop.hdfs.DatanodeIDProto datanode = 1;


    pub fn get_datanode(&self) -> &super::hdfs::DatanodeIDProto {
        self.datanode.as_ref().unwrap_or_else(|| <super::hdfs::DatanodeIDProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_datanode(&mut self) {
        self.datanode.clear();
    }

    pub fn has_datanode(&self) -> bool {
        self.datanode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_datanode(&mut self, v: super::hdfs::DatanodeIDProto) {
        self.datanode = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_datanode(&mut self) -> &mut super::hdfs::DatanodeIDProto {
        if self.datanode.is_none() {
            self.datanode.set_default();
        }
        self.datanode.as_mut().unwrap()
    }

    // Take field
    pub fn take_datanode(&mut self) -> super::hdfs::DatanodeIDProto {
        self.datanode.take().unwrap_or_else(|| super::hdfs::DatanodeIDProto::new())
    }

    // required uint64 size = 2;


    pub fn get_size(&self) -> u64 {
        self.size.unwrap_or(0)
    }
    pub fn clear_size(&mut self) {
        self.size = ::std::option::Option::None;
    }

    pub fn has_size(&self) -> bool {
        self.size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_size(&mut self, v: u64) {
        self.size = ::std::option::Option::Some(v);
    }

    // optional uint64 minBlockSize = 3;


    pub fn get_minBlockSize(&self) -> u64 {
        self.minBlockSize.unwrap_or(10485760u64)
    }
    pub fn clear_minBlockSize(&mut self) {
        self.minBlockSize = ::std::option::Option::None;
    }

    pub fn has_minBlockSize(&self) -> bool {
        self.minBlockSize.is_some()
    }

    // Param is passed by value, moved
    pub fn set_minBlockSize(&mut self, v: u64) {
        self.minBlockSize = ::std::option::Option::Some(v);
    }

    // optional uint64 timeInterval = 4;


    pub fn get_timeInterval(&self) -> u64 {
        self.timeInterval.unwrap_or(0u64)
    }
    pub fn clear_timeInterval(&mut self) {
        self.timeInterval = ::std::option::Option::None;
    }

    pub fn has_timeInterval(&self) -> bool {
        self.timeInterval.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timeInterval(&mut self, v: u64) {
        self.timeInterval = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for GetBlocksRequestProto {
    fn is_initialized(&self) -> bool {
        if self.datanode.is_none() {
            return false;
        }
        if self.size.is_none() {
            return false;
        }
        for v in &self.datanode {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.datanode)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.size = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.minBlockSize = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.timeInterval = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.datanode.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.size {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.minBlockSize {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.timeInterval {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.datanode.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.size {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.minBlockSize {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.timeInterval {
            os.write_uint64(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetBlocksRequestProto {
        GetBlocksRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::hdfs::DatanodeIDProto>>(
                "datanode",
                |m: &GetBlocksRequestProto| { &m.datanode },
                |m: &mut GetBlocksRequestProto| { &mut m.datanode },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "size",
                |m: &GetBlocksRequestProto| { &m.size },
                |m: &mut GetBlocksRequestProto| { &mut m.size },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "minBlockSize",
                |m: &GetBlocksRequestProto| { &m.minBlockSize },
                |m: &mut GetBlocksRequestProto| { &mut m.minBlockSize },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "timeInterval",
                |m: &GetBlocksRequestProto| { &m.timeInterval },
                |m: &mut GetBlocksRequestProto| { &mut m.timeInterval },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetBlocksRequestProto>(
                "GetBlocksRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetBlocksRequestProto {
        static instance: ::protobuf::rt::LazyV2<GetBlocksRequestProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetBlocksRequestProto::new)
    }
}

impl ::protobuf::Clear for GetBlocksRequestProto {
    fn clear(&mut self) {
        self.datanode.clear();
        self.size = ::std::option::Option::None;
        self.minBlockSize = ::std::option::Option::None;
        self.timeInterval = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetBlocksRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetBlocksRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetBlocksResponseProto {
    // message fields
    pub blocks: ::protobuf::SingularPtrField<super::HdfsServer::BlocksWithLocationsProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetBlocksResponseProto {
    fn default() -> &'a GetBlocksResponseProto {
        <GetBlocksResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl GetBlocksResponseProto {
    pub fn new() -> GetBlocksResponseProto {
        ::std::default::Default::default()
    }

    // required .hadoop.hdfs.BlocksWithLocationsProto blocks = 1;


    pub fn get_blocks(&self) -> &super::HdfsServer::BlocksWithLocationsProto {
        self.blocks.as_ref().unwrap_or_else(|| <super::HdfsServer::BlocksWithLocationsProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_blocks(&mut self) {
        self.blocks.clear();
    }

    pub fn has_blocks(&self) -> bool {
        self.blocks.is_some()
    }

    // Param is passed by value, moved
    pub fn set_blocks(&mut self, v: super::HdfsServer::BlocksWithLocationsProto) {
        self.blocks = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_blocks(&mut self) -> &mut super::HdfsServer::BlocksWithLocationsProto {
        if self.blocks.is_none() {
            self.blocks.set_default();
        }
        self.blocks.as_mut().unwrap()
    }

    // Take field
    pub fn take_blocks(&mut self) -> super::HdfsServer::BlocksWithLocationsProto {
        self.blocks.take().unwrap_or_else(|| super::HdfsServer::BlocksWithLocationsProto::new())
    }
}

impl ::protobuf::Message for GetBlocksResponseProto {
    fn is_initialized(&self) -> bool {
        if self.blocks.is_none() {
            return false;
        }
        for v in &self.blocks {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.blocks)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.blocks.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.blocks.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetBlocksResponseProto {
        GetBlocksResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::HdfsServer::BlocksWithLocationsProto>>(
                "blocks",
                |m: &GetBlocksResponseProto| { &m.blocks },
                |m: &mut GetBlocksResponseProto| { &mut m.blocks },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetBlocksResponseProto>(
                "GetBlocksResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetBlocksResponseProto {
        static instance: ::protobuf::rt::LazyV2<GetBlocksResponseProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetBlocksResponseProto::new)
    }
}

impl ::protobuf::Clear for GetBlocksResponseProto {
    fn clear(&mut self) {
        self.blocks.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetBlocksResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetBlocksResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetBlockKeysRequestProto {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetBlockKeysRequestProto {
    fn default() -> &'a GetBlockKeysRequestProto {
        <GetBlockKeysRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl GetBlockKeysRequestProto {
    pub fn new() -> GetBlockKeysRequestProto {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for GetBlockKeysRequestProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetBlockKeysRequestProto {
        GetBlockKeysRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetBlockKeysRequestProto>(
                "GetBlockKeysRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetBlockKeysRequestProto {
        static instance: ::protobuf::rt::LazyV2<GetBlockKeysRequestProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetBlockKeysRequestProto::new)
    }
}

impl ::protobuf::Clear for GetBlockKeysRequestProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetBlockKeysRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetBlockKeysRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetBlockKeysResponseProto {
    // message fields
    pub keys: ::protobuf::SingularPtrField<super::HdfsServer::ExportedBlockKeysProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetBlockKeysResponseProto {
    fn default() -> &'a GetBlockKeysResponseProto {
        <GetBlockKeysResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl GetBlockKeysResponseProto {
    pub fn new() -> GetBlockKeysResponseProto {
        ::std::default::Default::default()
    }

    // optional .hadoop.hdfs.ExportedBlockKeysProto keys = 1;


    pub fn get_keys(&self) -> &super::HdfsServer::ExportedBlockKeysProto {
        self.keys.as_ref().unwrap_or_else(|| <super::HdfsServer::ExportedBlockKeysProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_keys(&mut self) {
        self.keys.clear();
    }

    pub fn has_keys(&self) -> bool {
        self.keys.is_some()
    }

    // Param is passed by value, moved
    pub fn set_keys(&mut self, v: super::HdfsServer::ExportedBlockKeysProto) {
        self.keys = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_keys(&mut self) -> &mut super::HdfsServer::ExportedBlockKeysProto {
        if self.keys.is_none() {
            self.keys.set_default();
        }
        self.keys.as_mut().unwrap()
    }

    // Take field
    pub fn take_keys(&mut self) -> super::HdfsServer::ExportedBlockKeysProto {
        self.keys.take().unwrap_or_else(|| super::HdfsServer::ExportedBlockKeysProto::new())
    }
}

impl ::protobuf::Message for GetBlockKeysResponseProto {
    fn is_initialized(&self) -> bool {
        for v in &self.keys {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.keys)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.keys.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.keys.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetBlockKeysResponseProto {
        GetBlockKeysResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::HdfsServer::ExportedBlockKeysProto>>(
                "keys",
                |m: &GetBlockKeysResponseProto| { &m.keys },
                |m: &mut GetBlockKeysResponseProto| { &mut m.keys },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetBlockKeysResponseProto>(
                "GetBlockKeysResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetBlockKeysResponseProto {
        static instance: ::protobuf::rt::LazyV2<GetBlockKeysResponseProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetBlockKeysResponseProto::new)
    }
}

impl ::protobuf::Clear for GetBlockKeysResponseProto {
    fn clear(&mut self) {
        self.keys.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetBlockKeysResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetBlockKeysResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetTransactionIdRequestProto {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetTransactionIdRequestProto {
    fn default() -> &'a GetTransactionIdRequestProto {
        <GetTransactionIdRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl GetTransactionIdRequestProto {
    pub fn new() -> GetTransactionIdRequestProto {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for GetTransactionIdRequestProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetTransactionIdRequestProto {
        GetTransactionIdRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetTransactionIdRequestProto>(
                "GetTransactionIdRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetTransactionIdRequestProto {
        static instance: ::protobuf::rt::LazyV2<GetTransactionIdRequestProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetTransactionIdRequestProto::new)
    }
}

impl ::protobuf::Clear for GetTransactionIdRequestProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetTransactionIdRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetTransactionIdRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetTransactionIdResponseProto {
    // message fields
    txId: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetTransactionIdResponseProto {
    fn default() -> &'a GetTransactionIdResponseProto {
        <GetTransactionIdResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl GetTransactionIdResponseProto {
    pub fn new() -> GetTransactionIdResponseProto {
        ::std::default::Default::default()
    }

    // required uint64 txId = 1;


    pub fn get_txId(&self) -> u64 {
        self.txId.unwrap_or(0)
    }
    pub fn clear_txId(&mut self) {
        self.txId = ::std::option::Option::None;
    }

    pub fn has_txId(&self) -> bool {
        self.txId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_txId(&mut self, v: u64) {
        self.txId = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for GetTransactionIdResponseProto {
    fn is_initialized(&self) -> bool {
        if self.txId.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.txId = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.txId {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.txId {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetTransactionIdResponseProto {
        GetTransactionIdResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "txId",
                |m: &GetTransactionIdResponseProto| { &m.txId },
                |m: &mut GetTransactionIdResponseProto| { &mut m.txId },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetTransactionIdResponseProto>(
                "GetTransactionIdResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetTransactionIdResponseProto {
        static instance: ::protobuf::rt::LazyV2<GetTransactionIdResponseProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetTransactionIdResponseProto::new)
    }
}

impl ::protobuf::Clear for GetTransactionIdResponseProto {
    fn clear(&mut self) {
        self.txId = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetTransactionIdResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetTransactionIdResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RollEditLogRequestProto {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RollEditLogRequestProto {
    fn default() -> &'a RollEditLogRequestProto {
        <RollEditLogRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl RollEditLogRequestProto {
    pub fn new() -> RollEditLogRequestProto {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for RollEditLogRequestProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RollEditLogRequestProto {
        RollEditLogRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RollEditLogRequestProto>(
                "RollEditLogRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RollEditLogRequestProto {
        static instance: ::protobuf::rt::LazyV2<RollEditLogRequestProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RollEditLogRequestProto::new)
    }
}

impl ::protobuf::Clear for RollEditLogRequestProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RollEditLogRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RollEditLogRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RollEditLogResponseProto {
    // message fields
    pub signature: ::protobuf::SingularPtrField<super::HdfsServer::CheckpointSignatureProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RollEditLogResponseProto {
    fn default() -> &'a RollEditLogResponseProto {
        <RollEditLogResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl RollEditLogResponseProto {
    pub fn new() -> RollEditLogResponseProto {
        ::std::default::Default::default()
    }

    // required .hadoop.hdfs.CheckpointSignatureProto signature = 1;


    pub fn get_signature(&self) -> &super::HdfsServer::CheckpointSignatureProto {
        self.signature.as_ref().unwrap_or_else(|| <super::HdfsServer::CheckpointSignatureProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_signature(&mut self) {
        self.signature.clear();
    }

    pub fn has_signature(&self) -> bool {
        self.signature.is_some()
    }

    // Param is passed by value, moved
    pub fn set_signature(&mut self, v: super::HdfsServer::CheckpointSignatureProto) {
        self.signature = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_signature(&mut self) -> &mut super::HdfsServer::CheckpointSignatureProto {
        if self.signature.is_none() {
            self.signature.set_default();
        }
        self.signature.as_mut().unwrap()
    }

    // Take field
    pub fn take_signature(&mut self) -> super::HdfsServer::CheckpointSignatureProto {
        self.signature.take().unwrap_or_else(|| super::HdfsServer::CheckpointSignatureProto::new())
    }
}

impl ::protobuf::Message for RollEditLogResponseProto {
    fn is_initialized(&self) -> bool {
        if self.signature.is_none() {
            return false;
        }
        for v in &self.signature {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.signature)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.signature.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.signature.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RollEditLogResponseProto {
        RollEditLogResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::HdfsServer::CheckpointSignatureProto>>(
                "signature",
                |m: &RollEditLogResponseProto| { &m.signature },
                |m: &mut RollEditLogResponseProto| { &mut m.signature },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RollEditLogResponseProto>(
                "RollEditLogResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RollEditLogResponseProto {
        static instance: ::protobuf::rt::LazyV2<RollEditLogResponseProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RollEditLogResponseProto::new)
    }
}

impl ::protobuf::Clear for RollEditLogResponseProto {
    fn clear(&mut self) {
        self.signature.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RollEditLogResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RollEditLogResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetMostRecentCheckpointTxIdRequestProto {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetMostRecentCheckpointTxIdRequestProto {
    fn default() -> &'a GetMostRecentCheckpointTxIdRequestProto {
        <GetMostRecentCheckpointTxIdRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl GetMostRecentCheckpointTxIdRequestProto {
    pub fn new() -> GetMostRecentCheckpointTxIdRequestProto {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for GetMostRecentCheckpointTxIdRequestProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetMostRecentCheckpointTxIdRequestProto {
        GetMostRecentCheckpointTxIdRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetMostRecentCheckpointTxIdRequestProto>(
                "GetMostRecentCheckpointTxIdRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetMostRecentCheckpointTxIdRequestProto {
        static instance: ::protobuf::rt::LazyV2<GetMostRecentCheckpointTxIdRequestProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetMostRecentCheckpointTxIdRequestProto::new)
    }
}

impl ::protobuf::Clear for GetMostRecentCheckpointTxIdRequestProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetMostRecentCheckpointTxIdRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetMostRecentCheckpointTxIdRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetMostRecentCheckpointTxIdResponseProto {
    // message fields
    txId: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetMostRecentCheckpointTxIdResponseProto {
    fn default() -> &'a GetMostRecentCheckpointTxIdResponseProto {
        <GetMostRecentCheckpointTxIdResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl GetMostRecentCheckpointTxIdResponseProto {
    pub fn new() -> GetMostRecentCheckpointTxIdResponseProto {
        ::std::default::Default::default()
    }

    // required uint64 txId = 1;


    pub fn get_txId(&self) -> u64 {
        self.txId.unwrap_or(0)
    }
    pub fn clear_txId(&mut self) {
        self.txId = ::std::option::Option::None;
    }

    pub fn has_txId(&self) -> bool {
        self.txId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_txId(&mut self, v: u64) {
        self.txId = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for GetMostRecentCheckpointTxIdResponseProto {
    fn is_initialized(&self) -> bool {
        if self.txId.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.txId = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.txId {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.txId {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetMostRecentCheckpointTxIdResponseProto {
        GetMostRecentCheckpointTxIdResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "txId",
                |m: &GetMostRecentCheckpointTxIdResponseProto| { &m.txId },
                |m: &mut GetMostRecentCheckpointTxIdResponseProto| { &mut m.txId },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetMostRecentCheckpointTxIdResponseProto>(
                "GetMostRecentCheckpointTxIdResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetMostRecentCheckpointTxIdResponseProto {
        static instance: ::protobuf::rt::LazyV2<GetMostRecentCheckpointTxIdResponseProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetMostRecentCheckpointTxIdResponseProto::new)
    }
}

impl ::protobuf::Clear for GetMostRecentCheckpointTxIdResponseProto {
    fn clear(&mut self) {
        self.txId = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetMostRecentCheckpointTxIdResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetMostRecentCheckpointTxIdResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ErrorReportRequestProto {
    // message fields
    pub registration: ::protobuf::SingularPtrField<super::HdfsServer::NamenodeRegistrationProto>,
    errorCode: ::std::option::Option<u32>,
    msg: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ErrorReportRequestProto {
    fn default() -> &'a ErrorReportRequestProto {
        <ErrorReportRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl ErrorReportRequestProto {
    pub fn new() -> ErrorReportRequestProto {
        ::std::default::Default::default()
    }

    // required .hadoop.hdfs.NamenodeRegistrationProto registration = 1;


    pub fn get_registration(&self) -> &super::HdfsServer::NamenodeRegistrationProto {
        self.registration.as_ref().unwrap_or_else(|| <super::HdfsServer::NamenodeRegistrationProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_registration(&mut self) {
        self.registration.clear();
    }

    pub fn has_registration(&self) -> bool {
        self.registration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_registration(&mut self, v: super::HdfsServer::NamenodeRegistrationProto) {
        self.registration = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_registration(&mut self) -> &mut super::HdfsServer::NamenodeRegistrationProto {
        if self.registration.is_none() {
            self.registration.set_default();
        }
        self.registration.as_mut().unwrap()
    }

    // Take field
    pub fn take_registration(&mut self) -> super::HdfsServer::NamenodeRegistrationProto {
        self.registration.take().unwrap_or_else(|| super::HdfsServer::NamenodeRegistrationProto::new())
    }

    // required uint32 errorCode = 2;


    pub fn get_errorCode(&self) -> u32 {
        self.errorCode.unwrap_or(0)
    }
    pub fn clear_errorCode(&mut self) {
        self.errorCode = ::std::option::Option::None;
    }

    pub fn has_errorCode(&self) -> bool {
        self.errorCode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_errorCode(&mut self, v: u32) {
        self.errorCode = ::std::option::Option::Some(v);
    }

    // required string msg = 3;


    pub fn get_msg(&self) -> &str {
        match self.msg.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_msg(&mut self) {
        self.msg.clear();
    }

    pub fn has_msg(&self) -> bool {
        self.msg.is_some()
    }

    // Param is passed by value, moved
    pub fn set_msg(&mut self, v: ::std::string::String) {
        self.msg = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_msg(&mut self) -> &mut ::std::string::String {
        if self.msg.is_none() {
            self.msg.set_default();
        }
        self.msg.as_mut().unwrap()
    }

    // Take field
    pub fn take_msg(&mut self) -> ::std::string::String {
        self.msg.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for ErrorReportRequestProto {
    fn is_initialized(&self) -> bool {
        if self.registration.is_none() {
            return false;
        }
        if self.errorCode.is_none() {
            return false;
        }
        if self.msg.is_none() {
            return false;
        }
        for v in &self.registration {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.registration)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.errorCode = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.msg)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.registration.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.errorCode {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.msg.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.registration.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.errorCode {
            os.write_uint32(2, v)?;
        }
        if let Some(ref v) = self.msg.as_ref() {
            os.write_string(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ErrorReportRequestProto {
        ErrorReportRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::HdfsServer::NamenodeRegistrationProto>>(
                "registration",
                |m: &ErrorReportRequestProto| { &m.registration },
                |m: &mut ErrorReportRequestProto| { &mut m.registration },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "errorCode",
                |m: &ErrorReportRequestProto| { &m.errorCode },
                |m: &mut ErrorReportRequestProto| { &mut m.errorCode },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "msg",
                |m: &ErrorReportRequestProto| { &m.msg },
                |m: &mut ErrorReportRequestProto| { &mut m.msg },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ErrorReportRequestProto>(
                "ErrorReportRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ErrorReportRequestProto {
        static instance: ::protobuf::rt::LazyV2<ErrorReportRequestProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ErrorReportRequestProto::new)
    }
}

impl ::protobuf::Clear for ErrorReportRequestProto {
    fn clear(&mut self) {
        self.registration.clear();
        self.errorCode = ::std::option::Option::None;
        self.msg.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ErrorReportRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ErrorReportRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ErrorReportResponseProto {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ErrorReportResponseProto {
    fn default() -> &'a ErrorReportResponseProto {
        <ErrorReportResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl ErrorReportResponseProto {
    pub fn new() -> ErrorReportResponseProto {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for ErrorReportResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ErrorReportResponseProto {
        ErrorReportResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ErrorReportResponseProto>(
                "ErrorReportResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ErrorReportResponseProto {
        static instance: ::protobuf::rt::LazyV2<ErrorReportResponseProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ErrorReportResponseProto::new)
    }
}

impl ::protobuf::Clear for ErrorReportResponseProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ErrorReportResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ErrorReportResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RegisterRequestProto {
    // message fields
    pub registration: ::protobuf::SingularPtrField<super::HdfsServer::NamenodeRegistrationProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RegisterRequestProto {
    fn default() -> &'a RegisterRequestProto {
        <RegisterRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl RegisterRequestProto {
    pub fn new() -> RegisterRequestProto {
        ::std::default::Default::default()
    }

    // required .hadoop.hdfs.NamenodeRegistrationProto registration = 1;


    pub fn get_registration(&self) -> &super::HdfsServer::NamenodeRegistrationProto {
        self.registration.as_ref().unwrap_or_else(|| <super::HdfsServer::NamenodeRegistrationProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_registration(&mut self) {
        self.registration.clear();
    }

    pub fn has_registration(&self) -> bool {
        self.registration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_registration(&mut self, v: super::HdfsServer::NamenodeRegistrationProto) {
        self.registration = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_registration(&mut self) -> &mut super::HdfsServer::NamenodeRegistrationProto {
        if self.registration.is_none() {
            self.registration.set_default();
        }
        self.registration.as_mut().unwrap()
    }

    // Take field
    pub fn take_registration(&mut self) -> super::HdfsServer::NamenodeRegistrationProto {
        self.registration.take().unwrap_or_else(|| super::HdfsServer::NamenodeRegistrationProto::new())
    }
}

impl ::protobuf::Message for RegisterRequestProto {
    fn is_initialized(&self) -> bool {
        if self.registration.is_none() {
            return false;
        }
        for v in &self.registration {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.registration)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.registration.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.registration.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RegisterRequestProto {
        RegisterRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::HdfsServer::NamenodeRegistrationProto>>(
                "registration",
                |m: &RegisterRequestProto| { &m.registration },
                |m: &mut RegisterRequestProto| { &mut m.registration },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RegisterRequestProto>(
                "RegisterRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RegisterRequestProto {
        static instance: ::protobuf::rt::LazyV2<RegisterRequestProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RegisterRequestProto::new)
    }
}

impl ::protobuf::Clear for RegisterRequestProto {
    fn clear(&mut self) {
        self.registration.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RegisterRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RegisterRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RegisterResponseProto {
    // message fields
    pub registration: ::protobuf::SingularPtrField<super::HdfsServer::NamenodeRegistrationProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RegisterResponseProto {
    fn default() -> &'a RegisterResponseProto {
        <RegisterResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl RegisterResponseProto {
    pub fn new() -> RegisterResponseProto {
        ::std::default::Default::default()
    }

    // required .hadoop.hdfs.NamenodeRegistrationProto registration = 1;


    pub fn get_registration(&self) -> &super::HdfsServer::NamenodeRegistrationProto {
        self.registration.as_ref().unwrap_or_else(|| <super::HdfsServer::NamenodeRegistrationProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_registration(&mut self) {
        self.registration.clear();
    }

    pub fn has_registration(&self) -> bool {
        self.registration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_registration(&mut self, v: super::HdfsServer::NamenodeRegistrationProto) {
        self.registration = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_registration(&mut self) -> &mut super::HdfsServer::NamenodeRegistrationProto {
        if self.registration.is_none() {
            self.registration.set_default();
        }
        self.registration.as_mut().unwrap()
    }

    // Take field
    pub fn take_registration(&mut self) -> super::HdfsServer::NamenodeRegistrationProto {
        self.registration.take().unwrap_or_else(|| super::HdfsServer::NamenodeRegistrationProto::new())
    }
}

impl ::protobuf::Message for RegisterResponseProto {
    fn is_initialized(&self) -> bool {
        if self.registration.is_none() {
            return false;
        }
        for v in &self.registration {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.registration)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.registration.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.registration.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RegisterResponseProto {
        RegisterResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::HdfsServer::NamenodeRegistrationProto>>(
                "registration",
                |m: &RegisterResponseProto| { &m.registration },
                |m: &mut RegisterResponseProto| { &mut m.registration },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RegisterResponseProto>(
                "RegisterResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RegisterResponseProto {
        static instance: ::protobuf::rt::LazyV2<RegisterResponseProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RegisterResponseProto::new)
    }
}

impl ::protobuf::Clear for RegisterResponseProto {
    fn clear(&mut self) {
        self.registration.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RegisterResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RegisterResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StartCheckpointRequestProto {
    // message fields
    pub registration: ::protobuf::SingularPtrField<super::HdfsServer::NamenodeRegistrationProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StartCheckpointRequestProto {
    fn default() -> &'a StartCheckpointRequestProto {
        <StartCheckpointRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl StartCheckpointRequestProto {
    pub fn new() -> StartCheckpointRequestProto {
        ::std::default::Default::default()
    }

    // required .hadoop.hdfs.NamenodeRegistrationProto registration = 1;


    pub fn get_registration(&self) -> &super::HdfsServer::NamenodeRegistrationProto {
        self.registration.as_ref().unwrap_or_else(|| <super::HdfsServer::NamenodeRegistrationProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_registration(&mut self) {
        self.registration.clear();
    }

    pub fn has_registration(&self) -> bool {
        self.registration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_registration(&mut self, v: super::HdfsServer::NamenodeRegistrationProto) {
        self.registration = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_registration(&mut self) -> &mut super::HdfsServer::NamenodeRegistrationProto {
        if self.registration.is_none() {
            self.registration.set_default();
        }
        self.registration.as_mut().unwrap()
    }

    // Take field
    pub fn take_registration(&mut self) -> super::HdfsServer::NamenodeRegistrationProto {
        self.registration.take().unwrap_or_else(|| super::HdfsServer::NamenodeRegistrationProto::new())
    }
}

impl ::protobuf::Message for StartCheckpointRequestProto {
    fn is_initialized(&self) -> bool {
        if self.registration.is_none() {
            return false;
        }
        for v in &self.registration {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.registration)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.registration.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.registration.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StartCheckpointRequestProto {
        StartCheckpointRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::HdfsServer::NamenodeRegistrationProto>>(
                "registration",
                |m: &StartCheckpointRequestProto| { &m.registration },
                |m: &mut StartCheckpointRequestProto| { &mut m.registration },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<StartCheckpointRequestProto>(
                "StartCheckpointRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static StartCheckpointRequestProto {
        static instance: ::protobuf::rt::LazyV2<StartCheckpointRequestProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(StartCheckpointRequestProto::new)
    }
}

impl ::protobuf::Clear for StartCheckpointRequestProto {
    fn clear(&mut self) {
        self.registration.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StartCheckpointRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StartCheckpointRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StartCheckpointResponseProto {
    // message fields
    pub command: ::protobuf::SingularPtrField<super::HdfsServer::NamenodeCommandProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StartCheckpointResponseProto {
    fn default() -> &'a StartCheckpointResponseProto {
        <StartCheckpointResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl StartCheckpointResponseProto {
    pub fn new() -> StartCheckpointResponseProto {
        ::std::default::Default::default()
    }

    // required .hadoop.hdfs.NamenodeCommandProto command = 1;


    pub fn get_command(&self) -> &super::HdfsServer::NamenodeCommandProto {
        self.command.as_ref().unwrap_or_else(|| <super::HdfsServer::NamenodeCommandProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_command(&mut self) {
        self.command.clear();
    }

    pub fn has_command(&self) -> bool {
        self.command.is_some()
    }

    // Param is passed by value, moved
    pub fn set_command(&mut self, v: super::HdfsServer::NamenodeCommandProto) {
        self.command = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_command(&mut self) -> &mut super::HdfsServer::NamenodeCommandProto {
        if self.command.is_none() {
            self.command.set_default();
        }
        self.command.as_mut().unwrap()
    }

    // Take field
    pub fn take_command(&mut self) -> super::HdfsServer::NamenodeCommandProto {
        self.command.take().unwrap_or_else(|| super::HdfsServer::NamenodeCommandProto::new())
    }
}

impl ::protobuf::Message for StartCheckpointResponseProto {
    fn is_initialized(&self) -> bool {
        if self.command.is_none() {
            return false;
        }
        for v in &self.command {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.command)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.command.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.command.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StartCheckpointResponseProto {
        StartCheckpointResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::HdfsServer::NamenodeCommandProto>>(
                "command",
                |m: &StartCheckpointResponseProto| { &m.command },
                |m: &mut StartCheckpointResponseProto| { &mut m.command },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<StartCheckpointResponseProto>(
                "StartCheckpointResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static StartCheckpointResponseProto {
        static instance: ::protobuf::rt::LazyV2<StartCheckpointResponseProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(StartCheckpointResponseProto::new)
    }
}

impl ::protobuf::Clear for StartCheckpointResponseProto {
    fn clear(&mut self) {
        self.command.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StartCheckpointResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StartCheckpointResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EndCheckpointRequestProto {
    // message fields
    pub registration: ::protobuf::SingularPtrField<super::HdfsServer::NamenodeRegistrationProto>,
    pub signature: ::protobuf::SingularPtrField<super::HdfsServer::CheckpointSignatureProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EndCheckpointRequestProto {
    fn default() -> &'a EndCheckpointRequestProto {
        <EndCheckpointRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl EndCheckpointRequestProto {
    pub fn new() -> EndCheckpointRequestProto {
        ::std::default::Default::default()
    }

    // required .hadoop.hdfs.NamenodeRegistrationProto registration = 1;


    pub fn get_registration(&self) -> &super::HdfsServer::NamenodeRegistrationProto {
        self.registration.as_ref().unwrap_or_else(|| <super::HdfsServer::NamenodeRegistrationProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_registration(&mut self) {
        self.registration.clear();
    }

    pub fn has_registration(&self) -> bool {
        self.registration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_registration(&mut self, v: super::HdfsServer::NamenodeRegistrationProto) {
        self.registration = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_registration(&mut self) -> &mut super::HdfsServer::NamenodeRegistrationProto {
        if self.registration.is_none() {
            self.registration.set_default();
        }
        self.registration.as_mut().unwrap()
    }

    // Take field
    pub fn take_registration(&mut self) -> super::HdfsServer::NamenodeRegistrationProto {
        self.registration.take().unwrap_or_else(|| super::HdfsServer::NamenodeRegistrationProto::new())
    }

    // required .hadoop.hdfs.CheckpointSignatureProto signature = 2;


    pub fn get_signature(&self) -> &super::HdfsServer::CheckpointSignatureProto {
        self.signature.as_ref().unwrap_or_else(|| <super::HdfsServer::CheckpointSignatureProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_signature(&mut self) {
        self.signature.clear();
    }

    pub fn has_signature(&self) -> bool {
        self.signature.is_some()
    }

    // Param is passed by value, moved
    pub fn set_signature(&mut self, v: super::HdfsServer::CheckpointSignatureProto) {
        self.signature = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_signature(&mut self) -> &mut super::HdfsServer::CheckpointSignatureProto {
        if self.signature.is_none() {
            self.signature.set_default();
        }
        self.signature.as_mut().unwrap()
    }

    // Take field
    pub fn take_signature(&mut self) -> super::HdfsServer::CheckpointSignatureProto {
        self.signature.take().unwrap_or_else(|| super::HdfsServer::CheckpointSignatureProto::new())
    }
}

impl ::protobuf::Message for EndCheckpointRequestProto {
    fn is_initialized(&self) -> bool {
        if self.registration.is_none() {
            return false;
        }
        if self.signature.is_none() {
            return false;
        }
        for v in &self.registration {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.signature {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.registration)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.signature)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.registration.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.signature.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.registration.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.signature.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EndCheckpointRequestProto {
        EndCheckpointRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::HdfsServer::NamenodeRegistrationProto>>(
                "registration",
                |m: &EndCheckpointRequestProto| { &m.registration },
                |m: &mut EndCheckpointRequestProto| { &mut m.registration },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::HdfsServer::CheckpointSignatureProto>>(
                "signature",
                |m: &EndCheckpointRequestProto| { &m.signature },
                |m: &mut EndCheckpointRequestProto| { &mut m.signature },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<EndCheckpointRequestProto>(
                "EndCheckpointRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static EndCheckpointRequestProto {
        static instance: ::protobuf::rt::LazyV2<EndCheckpointRequestProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(EndCheckpointRequestProto::new)
    }
}

impl ::protobuf::Clear for EndCheckpointRequestProto {
    fn clear(&mut self) {
        self.registration.clear();
        self.signature.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EndCheckpointRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EndCheckpointRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EndCheckpointResponseProto {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EndCheckpointResponseProto {
    fn default() -> &'a EndCheckpointResponseProto {
        <EndCheckpointResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl EndCheckpointResponseProto {
    pub fn new() -> EndCheckpointResponseProto {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for EndCheckpointResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EndCheckpointResponseProto {
        EndCheckpointResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<EndCheckpointResponseProto>(
                "EndCheckpointResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static EndCheckpointResponseProto {
        static instance: ::protobuf::rt::LazyV2<EndCheckpointResponseProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(EndCheckpointResponseProto::new)
    }
}

impl ::protobuf::Clear for EndCheckpointResponseProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EndCheckpointResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EndCheckpointResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetEditLogManifestRequestProto {
    // message fields
    sinceTxId: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetEditLogManifestRequestProto {
    fn default() -> &'a GetEditLogManifestRequestProto {
        <GetEditLogManifestRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl GetEditLogManifestRequestProto {
    pub fn new() -> GetEditLogManifestRequestProto {
        ::std::default::Default::default()
    }

    // required uint64 sinceTxId = 1;


    pub fn get_sinceTxId(&self) -> u64 {
        self.sinceTxId.unwrap_or(0)
    }
    pub fn clear_sinceTxId(&mut self) {
        self.sinceTxId = ::std::option::Option::None;
    }

    pub fn has_sinceTxId(&self) -> bool {
        self.sinceTxId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sinceTxId(&mut self, v: u64) {
        self.sinceTxId = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for GetEditLogManifestRequestProto {
    fn is_initialized(&self) -> bool {
        if self.sinceTxId.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.sinceTxId = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.sinceTxId {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.sinceTxId {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetEditLogManifestRequestProto {
        GetEditLogManifestRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "sinceTxId",
                |m: &GetEditLogManifestRequestProto| { &m.sinceTxId },
                |m: &mut GetEditLogManifestRequestProto| { &mut m.sinceTxId },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetEditLogManifestRequestProto>(
                "GetEditLogManifestRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetEditLogManifestRequestProto {
        static instance: ::protobuf::rt::LazyV2<GetEditLogManifestRequestProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetEditLogManifestRequestProto::new)
    }
}

impl ::protobuf::Clear for GetEditLogManifestRequestProto {
    fn clear(&mut self) {
        self.sinceTxId = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetEditLogManifestRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetEditLogManifestRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetEditLogManifestResponseProto {
    // message fields
    pub manifest: ::protobuf::SingularPtrField<super::HdfsServer::RemoteEditLogManifestProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetEditLogManifestResponseProto {
    fn default() -> &'a GetEditLogManifestResponseProto {
        <GetEditLogManifestResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl GetEditLogManifestResponseProto {
    pub fn new() -> GetEditLogManifestResponseProto {
        ::std::default::Default::default()
    }

    // required .hadoop.hdfs.RemoteEditLogManifestProto manifest = 1;


    pub fn get_manifest(&self) -> &super::HdfsServer::RemoteEditLogManifestProto {
        self.manifest.as_ref().unwrap_or_else(|| <super::HdfsServer::RemoteEditLogManifestProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_manifest(&mut self) {
        self.manifest.clear();
    }

    pub fn has_manifest(&self) -> bool {
        self.manifest.is_some()
    }

    // Param is passed by value, moved
    pub fn set_manifest(&mut self, v: super::HdfsServer::RemoteEditLogManifestProto) {
        self.manifest = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_manifest(&mut self) -> &mut super::HdfsServer::RemoteEditLogManifestProto {
        if self.manifest.is_none() {
            self.manifest.set_default();
        }
        self.manifest.as_mut().unwrap()
    }

    // Take field
    pub fn take_manifest(&mut self) -> super::HdfsServer::RemoteEditLogManifestProto {
        self.manifest.take().unwrap_or_else(|| super::HdfsServer::RemoteEditLogManifestProto::new())
    }
}

impl ::protobuf::Message for GetEditLogManifestResponseProto {
    fn is_initialized(&self) -> bool {
        if self.manifest.is_none() {
            return false;
        }
        for v in &self.manifest {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.manifest)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.manifest.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.manifest.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetEditLogManifestResponseProto {
        GetEditLogManifestResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::HdfsServer::RemoteEditLogManifestProto>>(
                "manifest",
                |m: &GetEditLogManifestResponseProto| { &m.manifest },
                |m: &mut GetEditLogManifestResponseProto| { &mut m.manifest },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetEditLogManifestResponseProto>(
                "GetEditLogManifestResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetEditLogManifestResponseProto {
        static instance: ::protobuf::rt::LazyV2<GetEditLogManifestResponseProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetEditLogManifestResponseProto::new)
    }
}

impl ::protobuf::Clear for GetEditLogManifestResponseProto {
    fn clear(&mut self) {
        self.manifest.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetEditLogManifestResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetEditLogManifestResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct IsUpgradeFinalizedRequestProto {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a IsUpgradeFinalizedRequestProto {
    fn default() -> &'a IsUpgradeFinalizedRequestProto {
        <IsUpgradeFinalizedRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl IsUpgradeFinalizedRequestProto {
    pub fn new() -> IsUpgradeFinalizedRequestProto {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for IsUpgradeFinalizedRequestProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> IsUpgradeFinalizedRequestProto {
        IsUpgradeFinalizedRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<IsUpgradeFinalizedRequestProto>(
                "IsUpgradeFinalizedRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static IsUpgradeFinalizedRequestProto {
        static instance: ::protobuf::rt::LazyV2<IsUpgradeFinalizedRequestProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(IsUpgradeFinalizedRequestProto::new)
    }
}

impl ::protobuf::Clear for IsUpgradeFinalizedRequestProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for IsUpgradeFinalizedRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for IsUpgradeFinalizedRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct IsUpgradeFinalizedResponseProto {
    // message fields
    isUpgradeFinalized: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a IsUpgradeFinalizedResponseProto {
    fn default() -> &'a IsUpgradeFinalizedResponseProto {
        <IsUpgradeFinalizedResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl IsUpgradeFinalizedResponseProto {
    pub fn new() -> IsUpgradeFinalizedResponseProto {
        ::std::default::Default::default()
    }

    // required bool isUpgradeFinalized = 1;


    pub fn get_isUpgradeFinalized(&self) -> bool {
        self.isUpgradeFinalized.unwrap_or(false)
    }
    pub fn clear_isUpgradeFinalized(&mut self) {
        self.isUpgradeFinalized = ::std::option::Option::None;
    }

    pub fn has_isUpgradeFinalized(&self) -> bool {
        self.isUpgradeFinalized.is_some()
    }

    // Param is passed by value, moved
    pub fn set_isUpgradeFinalized(&mut self, v: bool) {
        self.isUpgradeFinalized = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for IsUpgradeFinalizedResponseProto {
    fn is_initialized(&self) -> bool {
        if self.isUpgradeFinalized.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.isUpgradeFinalized = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.isUpgradeFinalized {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.isUpgradeFinalized {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> IsUpgradeFinalizedResponseProto {
        IsUpgradeFinalizedResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "isUpgradeFinalized",
                |m: &IsUpgradeFinalizedResponseProto| { &m.isUpgradeFinalized },
                |m: &mut IsUpgradeFinalizedResponseProto| { &mut m.isUpgradeFinalized },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<IsUpgradeFinalizedResponseProto>(
                "IsUpgradeFinalizedResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static IsUpgradeFinalizedResponseProto {
        static instance: ::protobuf::rt::LazyV2<IsUpgradeFinalizedResponseProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(IsUpgradeFinalizedResponseProto::new)
    }
}

impl ::protobuf::Clear for IsUpgradeFinalizedResponseProto {
    fn clear(&mut self) {
        self.isUpgradeFinalized = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for IsUpgradeFinalizedResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for IsUpgradeFinalizedResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct IsRollingUpgradeRequestProto {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a IsRollingUpgradeRequestProto {
    fn default() -> &'a IsRollingUpgradeRequestProto {
        <IsRollingUpgradeRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl IsRollingUpgradeRequestProto {
    pub fn new() -> IsRollingUpgradeRequestProto {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for IsRollingUpgradeRequestProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> IsRollingUpgradeRequestProto {
        IsRollingUpgradeRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<IsRollingUpgradeRequestProto>(
                "IsRollingUpgradeRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static IsRollingUpgradeRequestProto {
        static instance: ::protobuf::rt::LazyV2<IsRollingUpgradeRequestProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(IsRollingUpgradeRequestProto::new)
    }
}

impl ::protobuf::Clear for IsRollingUpgradeRequestProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for IsRollingUpgradeRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for IsRollingUpgradeRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct IsRollingUpgradeResponseProto {
    // message fields
    isRollingUpgrade: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a IsRollingUpgradeResponseProto {
    fn default() -> &'a IsRollingUpgradeResponseProto {
        <IsRollingUpgradeResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl IsRollingUpgradeResponseProto {
    pub fn new() -> IsRollingUpgradeResponseProto {
        ::std::default::Default::default()
    }

    // required bool isRollingUpgrade = 1;


    pub fn get_isRollingUpgrade(&self) -> bool {
        self.isRollingUpgrade.unwrap_or(false)
    }
    pub fn clear_isRollingUpgrade(&mut self) {
        self.isRollingUpgrade = ::std::option::Option::None;
    }

    pub fn has_isRollingUpgrade(&self) -> bool {
        self.isRollingUpgrade.is_some()
    }

    // Param is passed by value, moved
    pub fn set_isRollingUpgrade(&mut self, v: bool) {
        self.isRollingUpgrade = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for IsRollingUpgradeResponseProto {
    fn is_initialized(&self) -> bool {
        if self.isRollingUpgrade.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.isRollingUpgrade = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.isRollingUpgrade {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.isRollingUpgrade {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> IsRollingUpgradeResponseProto {
        IsRollingUpgradeResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "isRollingUpgrade",
                |m: &IsRollingUpgradeResponseProto| { &m.isRollingUpgrade },
                |m: &mut IsRollingUpgradeResponseProto| { &mut m.isRollingUpgrade },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<IsRollingUpgradeResponseProto>(
                "IsRollingUpgradeResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static IsRollingUpgradeResponseProto {
        static instance: ::protobuf::rt::LazyV2<IsRollingUpgradeResponseProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(IsRollingUpgradeResponseProto::new)
    }
}

impl ::protobuf::Clear for IsRollingUpgradeResponseProto {
    fn clear(&mut self) {
        self.isRollingUpgrade = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for IsRollingUpgradeResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for IsRollingUpgradeResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetFilePathRequestProto {
    // message fields
    fileId: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetFilePathRequestProto {
    fn default() -> &'a GetFilePathRequestProto {
        <GetFilePathRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl GetFilePathRequestProto {
    pub fn new() -> GetFilePathRequestProto {
        ::std::default::Default::default()
    }

    // required uint64 fileId = 1;


    pub fn get_fileId(&self) -> u64 {
        self.fileId.unwrap_or(0)
    }
    pub fn clear_fileId(&mut self) {
        self.fileId = ::std::option::Option::None;
    }

    pub fn has_fileId(&self) -> bool {
        self.fileId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fileId(&mut self, v: u64) {
        self.fileId = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for GetFilePathRequestProto {
    fn is_initialized(&self) -> bool {
        if self.fileId.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.fileId = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.fileId {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.fileId {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetFilePathRequestProto {
        GetFilePathRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "fileId",
                |m: &GetFilePathRequestProto| { &m.fileId },
                |m: &mut GetFilePathRequestProto| { &mut m.fileId },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetFilePathRequestProto>(
                "GetFilePathRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetFilePathRequestProto {
        static instance: ::protobuf::rt::LazyV2<GetFilePathRequestProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetFilePathRequestProto::new)
    }
}

impl ::protobuf::Clear for GetFilePathRequestProto {
    fn clear(&mut self) {
        self.fileId = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetFilePathRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetFilePathRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetFilePathResponseProto {
    // message fields
    srcPath: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetFilePathResponseProto {
    fn default() -> &'a GetFilePathResponseProto {
        <GetFilePathResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl GetFilePathResponseProto {
    pub fn new() -> GetFilePathResponseProto {
        ::std::default::Default::default()
    }

    // required string srcPath = 1;


    pub fn get_srcPath(&self) -> &str {
        match self.srcPath.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_srcPath(&mut self) {
        self.srcPath.clear();
    }

    pub fn has_srcPath(&self) -> bool {
        self.srcPath.is_some()
    }

    // Param is passed by value, moved
    pub fn set_srcPath(&mut self, v: ::std::string::String) {
        self.srcPath = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_srcPath(&mut self) -> &mut ::std::string::String {
        if self.srcPath.is_none() {
            self.srcPath.set_default();
        }
        self.srcPath.as_mut().unwrap()
    }

    // Take field
    pub fn take_srcPath(&mut self) -> ::std::string::String {
        self.srcPath.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for GetFilePathResponseProto {
    fn is_initialized(&self) -> bool {
        if self.srcPath.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.srcPath)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.srcPath.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.srcPath.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetFilePathResponseProto {
        GetFilePathResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "srcPath",
                |m: &GetFilePathResponseProto| { &m.srcPath },
                |m: &mut GetFilePathResponseProto| { &mut m.srcPath },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetFilePathResponseProto>(
                "GetFilePathResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetFilePathResponseProto {
        static instance: ::protobuf::rt::LazyV2<GetFilePathResponseProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetFilePathResponseProto::new)
    }
}

impl ::protobuf::Clear for GetFilePathResponseProto {
    fn clear(&mut self) {
        self.srcPath.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetFilePathResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetFilePathResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetNextSPSPathRequestProto {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetNextSPSPathRequestProto {
    fn default() -> &'a GetNextSPSPathRequestProto {
        <GetNextSPSPathRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl GetNextSPSPathRequestProto {
    pub fn new() -> GetNextSPSPathRequestProto {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for GetNextSPSPathRequestProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetNextSPSPathRequestProto {
        GetNextSPSPathRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetNextSPSPathRequestProto>(
                "GetNextSPSPathRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetNextSPSPathRequestProto {
        static instance: ::protobuf::rt::LazyV2<GetNextSPSPathRequestProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetNextSPSPathRequestProto::new)
    }
}

impl ::protobuf::Clear for GetNextSPSPathRequestProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetNextSPSPathRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetNextSPSPathRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetNextSPSPathResponseProto {
    // message fields
    spsPath: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetNextSPSPathResponseProto {
    fn default() -> &'a GetNextSPSPathResponseProto {
        <GetNextSPSPathResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl GetNextSPSPathResponseProto {
    pub fn new() -> GetNextSPSPathResponseProto {
        ::std::default::Default::default()
    }

    // optional uint64 spsPath = 1;


    pub fn get_spsPath(&self) -> u64 {
        self.spsPath.unwrap_or(0)
    }
    pub fn clear_spsPath(&mut self) {
        self.spsPath = ::std::option::Option::None;
    }

    pub fn has_spsPath(&self) -> bool {
        self.spsPath.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spsPath(&mut self, v: u64) {
        self.spsPath = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for GetNextSPSPathResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.spsPath = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.spsPath {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.spsPath {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetNextSPSPathResponseProto {
        GetNextSPSPathResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "spsPath",
                |m: &GetNextSPSPathResponseProto| { &m.spsPath },
                |m: &mut GetNextSPSPathResponseProto| { &mut m.spsPath },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetNextSPSPathResponseProto>(
                "GetNextSPSPathResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetNextSPSPathResponseProto {
        static instance: ::protobuf::rt::LazyV2<GetNextSPSPathResponseProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetNextSPSPathResponseProto::new)
    }
}

impl ::protobuf::Clear for GetNextSPSPathResponseProto {
    fn clear(&mut self) {
        self.spsPath = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetNextSPSPathResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetNextSPSPathResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x16NamenodeProtocol.proto\x12\x0bhadoop.hdfs\x1a\nhdfs.proto\x1a\x10H\
    dfsServer.proto\"\xc4\x01\n\x15GetBlocksRequestProto\x12:\n\x08datanode\
    \x18\x01\x20\x02(\x0b2\x1c.hadoop.hdfs.DatanodeIDProtoR\x08datanodeB\0\
    \x12\x14\n\x04size\x18\x02\x20\x02(\x04R\x04sizeB\0\x12.\n\x0cminBlockSi\
    ze\x18\x03\x20\x01(\x04:\x0810485760R\x0cminBlockSizeB\0\x12'\n\x0ctimeI\
    nterval\x18\x04\x20\x01(\x04:\x010R\x0ctimeIntervalB\0:\0\"[\n\x16GetBlo\
    cksResponseProto\x12?\n\x06blocks\x18\x01\x20\x02(\x0b2%.hadoop.hdfs.Blo\
    cksWithLocationsProtoR\x06blocksB\0:\0\"\x1c\n\x18GetBlockKeysRequestPro\
    to:\0\"X\n\x19GetBlockKeysResponseProto\x129\n\x04keys\x18\x01\x20\x01(\
    \x0b2#.hadoop.hdfs.ExportedBlockKeysProtoR\x04keysB\0:\0\"\x20\n\x1cGetT\
    ransactionIdRequestProto:\0\"7\n\x1dGetTransactionIdResponseProto\x12\
    \x14\n\x04txId\x18\x01\x20\x02(\x04R\x04txIdB\0:\0\"\x1b\n\x17RollEditLo\
    gRequestProto:\0\"c\n\x18RollEditLogResponseProto\x12E\n\tsignature\x18\
    \x01\x20\x02(\x0b2%.hadoop.hdfs.CheckpointSignatureProtoR\tsignatureB\0:\
    \0\"+\n'GetMostRecentCheckpointTxIdRequestProto:\0\"B\n(GetMostRecentChe\
    ckpointTxIdResponseProto\x12\x14\n\x04txId\x18\x01\x20\x02(\x04R\x04txId\
    B\0:\0\"\x9d\x01\n\x17ErrorReportRequestProto\x12L\n\x0cregistration\x18\
    \x01\x20\x02(\x0b2&.hadoop.hdfs.NamenodeRegistrationProtoR\x0cregistrati\
    onB\0\x12\x1e\n\terrorCode\x18\x02\x20\x02(\rR\terrorCodeB\0\x12\x12\n\
    \x03msg\x18\x03\x20\x02(\tR\x03msgB\0:\0\"\x1c\n\x18ErrorReportResponseP\
    roto:\0\"f\n\x14RegisterRequestProto\x12L\n\x0cregistration\x18\x01\x20\
    \x02(\x0b2&.hadoop.hdfs.NamenodeRegistrationProtoR\x0cregistrationB\0:\0\
    \"g\n\x15RegisterResponseProto\x12L\n\x0cregistration\x18\x01\x20\x02(\
    \x0b2&.hadoop.hdfs.NamenodeRegistrationProtoR\x0cregistrationB\0:\0\"m\n\
    \x1bStartCheckpointRequestProto\x12L\n\x0cregistration\x18\x01\x20\x02(\
    \x0b2&.hadoop.hdfs.NamenodeRegistrationProtoR\x0cregistrationB\0:\0\"_\n\
    \x1cStartCheckpointResponseProto\x12=\n\x07command\x18\x01\x20\x02(\x0b2\
    !.hadoop.hdfs.NamenodeCommandProtoR\x07commandB\0:\0\"\xb2\x01\n\x19EndC\
    heckpointRequestProto\x12L\n\x0cregistration\x18\x01\x20\x02(\x0b2&.hado\
    op.hdfs.NamenodeRegistrationProtoR\x0cregistrationB\0\x12E\n\tsignature\
    \x18\x02\x20\x02(\x0b2%.hadoop.hdfs.CheckpointSignatureProtoR\tsignature\
    B\0:\0\"\x1e\n\x1aEndCheckpointResponseProto:\0\"B\n\x1eGetEditLogManife\
    stRequestProto\x12\x1e\n\tsinceTxId\x18\x01\x20\x02(\x04R\tsinceTxIdB\0:\
    \0\"j\n\x1fGetEditLogManifestResponseProto\x12E\n\x08manifest\x18\x01\
    \x20\x02(\x0b2'.hadoop.hdfs.RemoteEditLogManifestProtoR\x08manifestB\0:\
    \0\"\"\n\x1eIsUpgradeFinalizedRequestProto:\0\"U\n\x1fIsUpgradeFinalized\
    ResponseProto\x120\n\x12isUpgradeFinalized\x18\x01\x20\x02(\x08R\x12isUp\
    gradeFinalizedB\0:\0\"\x20\n\x1cIsRollingUpgradeRequestProto:\0\"O\n\x1d\
    IsRollingUpgradeResponseProto\x12,\n\x10isRollingUpgrade\x18\x01\x20\x02\
    (\x08R\x10isRollingUpgradeB\0:\0\"5\n\x17GetFilePathRequestProto\x12\x18\
    \n\x06fileId\x18\x01\x20\x02(\x04R\x06fileIdB\0:\0\"8\n\x18GetFilePathRe\
    sponseProto\x12\x1a\n\x07srcPath\x18\x01\x20\x02(\tR\x07srcPathB\0:\0\"\
    \x1e\n\x1aGetNextSPSPathRequestProto:\0\";\n\x1bGetNextSPSPathResponsePr\
    oto\x12\x1a\n\x07spsPath\x18\x01\x20\x01(\x04R\x07spsPathB\0:\0B\0b\x06p\
    roto2\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
