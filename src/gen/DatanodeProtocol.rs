// This file is generated by rust-protobuf 2.20.0. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![rustfmt::skip]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `DatanodeProtocol.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_20_0;

#[derive(PartialEq,Clone,Default)]
pub struct DatanodeRegistrationProto {
    // message fields
    pub datanodeID: ::protobuf::SingularPtrField<super::hdfs::DatanodeIDProto>,
    pub storageInfo: ::protobuf::SingularPtrField<super::HdfsServer::StorageInfoProto>,
    pub keys: ::protobuf::SingularPtrField<super::HdfsServer::ExportedBlockKeysProto>,
    softwareVersion: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DatanodeRegistrationProto {
    fn default() -> &'a DatanodeRegistrationProto {
        <DatanodeRegistrationProto as ::protobuf::Message>::default_instance()
    }
}

impl DatanodeRegistrationProto {
    pub fn new() -> DatanodeRegistrationProto {
        ::std::default::Default::default()
    }

    // required .hadoop.hdfs.DatanodeIDProto datanodeID = 1;


    pub fn get_datanodeID(&self) -> &super::hdfs::DatanodeIDProto {
        self.datanodeID.as_ref().unwrap_or_else(|| <super::hdfs::DatanodeIDProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_datanodeID(&mut self) {
        self.datanodeID.clear();
    }

    pub fn has_datanodeID(&self) -> bool {
        self.datanodeID.is_some()
    }

    // Param is passed by value, moved
    pub fn set_datanodeID(&mut self, v: super::hdfs::DatanodeIDProto) {
        self.datanodeID = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_datanodeID(&mut self) -> &mut super::hdfs::DatanodeIDProto {
        if self.datanodeID.is_none() {
            self.datanodeID.set_default();
        }
        self.datanodeID.as_mut().unwrap()
    }

    // Take field
    pub fn take_datanodeID(&mut self) -> super::hdfs::DatanodeIDProto {
        self.datanodeID.take().unwrap_or_else(|| super::hdfs::DatanodeIDProto::new())
    }

    // required .hadoop.hdfs.StorageInfoProto storageInfo = 2;


    pub fn get_storageInfo(&self) -> &super::HdfsServer::StorageInfoProto {
        self.storageInfo.as_ref().unwrap_or_else(|| <super::HdfsServer::StorageInfoProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_storageInfo(&mut self) {
        self.storageInfo.clear();
    }

    pub fn has_storageInfo(&self) -> bool {
        self.storageInfo.is_some()
    }

    // Param is passed by value, moved
    pub fn set_storageInfo(&mut self, v: super::HdfsServer::StorageInfoProto) {
        self.storageInfo = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_storageInfo(&mut self) -> &mut super::HdfsServer::StorageInfoProto {
        if self.storageInfo.is_none() {
            self.storageInfo.set_default();
        }
        self.storageInfo.as_mut().unwrap()
    }

    // Take field
    pub fn take_storageInfo(&mut self) -> super::HdfsServer::StorageInfoProto {
        self.storageInfo.take().unwrap_or_else(|| super::HdfsServer::StorageInfoProto::new())
    }

    // required .hadoop.hdfs.ExportedBlockKeysProto keys = 3;


    pub fn get_keys(&self) -> &super::HdfsServer::ExportedBlockKeysProto {
        self.keys.as_ref().unwrap_or_else(|| <super::HdfsServer::ExportedBlockKeysProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_keys(&mut self) {
        self.keys.clear();
    }

    pub fn has_keys(&self) -> bool {
        self.keys.is_some()
    }

    // Param is passed by value, moved
    pub fn set_keys(&mut self, v: super::HdfsServer::ExportedBlockKeysProto) {
        self.keys = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_keys(&mut self) -> &mut super::HdfsServer::ExportedBlockKeysProto {
        if self.keys.is_none() {
            self.keys.set_default();
        }
        self.keys.as_mut().unwrap()
    }

    // Take field
    pub fn take_keys(&mut self) -> super::HdfsServer::ExportedBlockKeysProto {
        self.keys.take().unwrap_or_else(|| super::HdfsServer::ExportedBlockKeysProto::new())
    }

    // required string softwareVersion = 4;


    pub fn get_softwareVersion(&self) -> &str {
        match self.softwareVersion.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_softwareVersion(&mut self) {
        self.softwareVersion.clear();
    }

    pub fn has_softwareVersion(&self) -> bool {
        self.softwareVersion.is_some()
    }

    // Param is passed by value, moved
    pub fn set_softwareVersion(&mut self, v: ::std::string::String) {
        self.softwareVersion = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_softwareVersion(&mut self) -> &mut ::std::string::String {
        if self.softwareVersion.is_none() {
            self.softwareVersion.set_default();
        }
        self.softwareVersion.as_mut().unwrap()
    }

    // Take field
    pub fn take_softwareVersion(&mut self) -> ::std::string::String {
        self.softwareVersion.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for DatanodeRegistrationProto {
    fn is_initialized(&self) -> bool {
        if self.datanodeID.is_none() {
            return false;
        }
        if self.storageInfo.is_none() {
            return false;
        }
        if self.keys.is_none() {
            return false;
        }
        if self.softwareVersion.is_none() {
            return false;
        }
        for v in &self.datanodeID {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.storageInfo {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.keys {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.datanodeID)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.storageInfo)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.keys)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.softwareVersion)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.datanodeID.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.storageInfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.keys.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.softwareVersion.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.datanodeID.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.storageInfo.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.keys.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.softwareVersion.as_ref() {
            os.write_string(4, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DatanodeRegistrationProto {
        DatanodeRegistrationProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::hdfs::DatanodeIDProto>>(
                "datanodeID",
                |m: &DatanodeRegistrationProto| { &m.datanodeID },
                |m: &mut DatanodeRegistrationProto| { &mut m.datanodeID },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::HdfsServer::StorageInfoProto>>(
                "storageInfo",
                |m: &DatanodeRegistrationProto| { &m.storageInfo },
                |m: &mut DatanodeRegistrationProto| { &mut m.storageInfo },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::HdfsServer::ExportedBlockKeysProto>>(
                "keys",
                |m: &DatanodeRegistrationProto| { &m.keys },
                |m: &mut DatanodeRegistrationProto| { &mut m.keys },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "softwareVersion",
                |m: &DatanodeRegistrationProto| { &m.softwareVersion },
                |m: &mut DatanodeRegistrationProto| { &mut m.softwareVersion },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DatanodeRegistrationProto>(
                "DatanodeRegistrationProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DatanodeRegistrationProto {
        static instance: ::protobuf::rt::LazyV2<DatanodeRegistrationProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DatanodeRegistrationProto::new)
    }
}

impl ::protobuf::Clear for DatanodeRegistrationProto {
    fn clear(&mut self) {
        self.datanodeID.clear();
        self.storageInfo.clear();
        self.keys.clear();
        self.softwareVersion.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DatanodeRegistrationProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DatanodeRegistrationProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DatanodeCommandProto {
    // message fields
    cmdType: ::std::option::Option<DatanodeCommandProto_Type>,
    pub balancerCmd: ::protobuf::SingularPtrField<BalancerBandwidthCommandProto>,
    pub blkCmd: ::protobuf::SingularPtrField<BlockCommandProto>,
    pub recoveryCmd: ::protobuf::SingularPtrField<BlockRecoveryCommandProto>,
    pub finalizeCmd: ::protobuf::SingularPtrField<FinalizeCommandProto>,
    pub keyUpdateCmd: ::protobuf::SingularPtrField<KeyUpdateCommandProto>,
    pub registerCmd: ::protobuf::SingularPtrField<RegisterCommandProto>,
    pub blkIdCmd: ::protobuf::SingularPtrField<BlockIdCommandProto>,
    pub blkECReconstructionCmd: ::protobuf::SingularPtrField<BlockECReconstructionCommandProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DatanodeCommandProto {
    fn default() -> &'a DatanodeCommandProto {
        <DatanodeCommandProto as ::protobuf::Message>::default_instance()
    }
}

impl DatanodeCommandProto {
    pub fn new() -> DatanodeCommandProto {
        ::std::default::Default::default()
    }

    // required .hadoop.hdfs.DatanodeCommandProto.Type cmdType = 1;


    pub fn get_cmdType(&self) -> DatanodeCommandProto_Type {
        self.cmdType.unwrap_or(DatanodeCommandProto_Type::BalancerBandwidthCommand)
    }
    pub fn clear_cmdType(&mut self) {
        self.cmdType = ::std::option::Option::None;
    }

    pub fn has_cmdType(&self) -> bool {
        self.cmdType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cmdType(&mut self, v: DatanodeCommandProto_Type) {
        self.cmdType = ::std::option::Option::Some(v);
    }

    // optional .hadoop.hdfs.BalancerBandwidthCommandProto balancerCmd = 2;


    pub fn get_balancerCmd(&self) -> &BalancerBandwidthCommandProto {
        self.balancerCmd.as_ref().unwrap_or_else(|| <BalancerBandwidthCommandProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_balancerCmd(&mut self) {
        self.balancerCmd.clear();
    }

    pub fn has_balancerCmd(&self) -> bool {
        self.balancerCmd.is_some()
    }

    // Param is passed by value, moved
    pub fn set_balancerCmd(&mut self, v: BalancerBandwidthCommandProto) {
        self.balancerCmd = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_balancerCmd(&mut self) -> &mut BalancerBandwidthCommandProto {
        if self.balancerCmd.is_none() {
            self.balancerCmd.set_default();
        }
        self.balancerCmd.as_mut().unwrap()
    }

    // Take field
    pub fn take_balancerCmd(&mut self) -> BalancerBandwidthCommandProto {
        self.balancerCmd.take().unwrap_or_else(|| BalancerBandwidthCommandProto::new())
    }

    // optional .hadoop.hdfs.BlockCommandProto blkCmd = 3;


    pub fn get_blkCmd(&self) -> &BlockCommandProto {
        self.blkCmd.as_ref().unwrap_or_else(|| <BlockCommandProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_blkCmd(&mut self) {
        self.blkCmd.clear();
    }

    pub fn has_blkCmd(&self) -> bool {
        self.blkCmd.is_some()
    }

    // Param is passed by value, moved
    pub fn set_blkCmd(&mut self, v: BlockCommandProto) {
        self.blkCmd = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_blkCmd(&mut self) -> &mut BlockCommandProto {
        if self.blkCmd.is_none() {
            self.blkCmd.set_default();
        }
        self.blkCmd.as_mut().unwrap()
    }

    // Take field
    pub fn take_blkCmd(&mut self) -> BlockCommandProto {
        self.blkCmd.take().unwrap_or_else(|| BlockCommandProto::new())
    }

    // optional .hadoop.hdfs.BlockRecoveryCommandProto recoveryCmd = 4;


    pub fn get_recoveryCmd(&self) -> &BlockRecoveryCommandProto {
        self.recoveryCmd.as_ref().unwrap_or_else(|| <BlockRecoveryCommandProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_recoveryCmd(&mut self) {
        self.recoveryCmd.clear();
    }

    pub fn has_recoveryCmd(&self) -> bool {
        self.recoveryCmd.is_some()
    }

    // Param is passed by value, moved
    pub fn set_recoveryCmd(&mut self, v: BlockRecoveryCommandProto) {
        self.recoveryCmd = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_recoveryCmd(&mut self) -> &mut BlockRecoveryCommandProto {
        if self.recoveryCmd.is_none() {
            self.recoveryCmd.set_default();
        }
        self.recoveryCmd.as_mut().unwrap()
    }

    // Take field
    pub fn take_recoveryCmd(&mut self) -> BlockRecoveryCommandProto {
        self.recoveryCmd.take().unwrap_or_else(|| BlockRecoveryCommandProto::new())
    }

    // optional .hadoop.hdfs.FinalizeCommandProto finalizeCmd = 5;


    pub fn get_finalizeCmd(&self) -> &FinalizeCommandProto {
        self.finalizeCmd.as_ref().unwrap_or_else(|| <FinalizeCommandProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_finalizeCmd(&mut self) {
        self.finalizeCmd.clear();
    }

    pub fn has_finalizeCmd(&self) -> bool {
        self.finalizeCmd.is_some()
    }

    // Param is passed by value, moved
    pub fn set_finalizeCmd(&mut self, v: FinalizeCommandProto) {
        self.finalizeCmd = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_finalizeCmd(&mut self) -> &mut FinalizeCommandProto {
        if self.finalizeCmd.is_none() {
            self.finalizeCmd.set_default();
        }
        self.finalizeCmd.as_mut().unwrap()
    }

    // Take field
    pub fn take_finalizeCmd(&mut self) -> FinalizeCommandProto {
        self.finalizeCmd.take().unwrap_or_else(|| FinalizeCommandProto::new())
    }

    // optional .hadoop.hdfs.KeyUpdateCommandProto keyUpdateCmd = 6;


    pub fn get_keyUpdateCmd(&self) -> &KeyUpdateCommandProto {
        self.keyUpdateCmd.as_ref().unwrap_or_else(|| <KeyUpdateCommandProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_keyUpdateCmd(&mut self) {
        self.keyUpdateCmd.clear();
    }

    pub fn has_keyUpdateCmd(&self) -> bool {
        self.keyUpdateCmd.is_some()
    }

    // Param is passed by value, moved
    pub fn set_keyUpdateCmd(&mut self, v: KeyUpdateCommandProto) {
        self.keyUpdateCmd = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_keyUpdateCmd(&mut self) -> &mut KeyUpdateCommandProto {
        if self.keyUpdateCmd.is_none() {
            self.keyUpdateCmd.set_default();
        }
        self.keyUpdateCmd.as_mut().unwrap()
    }

    // Take field
    pub fn take_keyUpdateCmd(&mut self) -> KeyUpdateCommandProto {
        self.keyUpdateCmd.take().unwrap_or_else(|| KeyUpdateCommandProto::new())
    }

    // optional .hadoop.hdfs.RegisterCommandProto registerCmd = 7;


    pub fn get_registerCmd(&self) -> &RegisterCommandProto {
        self.registerCmd.as_ref().unwrap_or_else(|| <RegisterCommandProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_registerCmd(&mut self) {
        self.registerCmd.clear();
    }

    pub fn has_registerCmd(&self) -> bool {
        self.registerCmd.is_some()
    }

    // Param is passed by value, moved
    pub fn set_registerCmd(&mut self, v: RegisterCommandProto) {
        self.registerCmd = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_registerCmd(&mut self) -> &mut RegisterCommandProto {
        if self.registerCmd.is_none() {
            self.registerCmd.set_default();
        }
        self.registerCmd.as_mut().unwrap()
    }

    // Take field
    pub fn take_registerCmd(&mut self) -> RegisterCommandProto {
        self.registerCmd.take().unwrap_or_else(|| RegisterCommandProto::new())
    }

    // optional .hadoop.hdfs.BlockIdCommandProto blkIdCmd = 8;


    pub fn get_blkIdCmd(&self) -> &BlockIdCommandProto {
        self.blkIdCmd.as_ref().unwrap_or_else(|| <BlockIdCommandProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_blkIdCmd(&mut self) {
        self.blkIdCmd.clear();
    }

    pub fn has_blkIdCmd(&self) -> bool {
        self.blkIdCmd.is_some()
    }

    // Param is passed by value, moved
    pub fn set_blkIdCmd(&mut self, v: BlockIdCommandProto) {
        self.blkIdCmd = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_blkIdCmd(&mut self) -> &mut BlockIdCommandProto {
        if self.blkIdCmd.is_none() {
            self.blkIdCmd.set_default();
        }
        self.blkIdCmd.as_mut().unwrap()
    }

    // Take field
    pub fn take_blkIdCmd(&mut self) -> BlockIdCommandProto {
        self.blkIdCmd.take().unwrap_or_else(|| BlockIdCommandProto::new())
    }

    // optional .hadoop.hdfs.BlockECReconstructionCommandProto blkECReconstructionCmd = 9;


    pub fn get_blkECReconstructionCmd(&self) -> &BlockECReconstructionCommandProto {
        self.blkECReconstructionCmd.as_ref().unwrap_or_else(|| <BlockECReconstructionCommandProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_blkECReconstructionCmd(&mut self) {
        self.blkECReconstructionCmd.clear();
    }

    pub fn has_blkECReconstructionCmd(&self) -> bool {
        self.blkECReconstructionCmd.is_some()
    }

    // Param is passed by value, moved
    pub fn set_blkECReconstructionCmd(&mut self, v: BlockECReconstructionCommandProto) {
        self.blkECReconstructionCmd = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_blkECReconstructionCmd(&mut self) -> &mut BlockECReconstructionCommandProto {
        if self.blkECReconstructionCmd.is_none() {
            self.blkECReconstructionCmd.set_default();
        }
        self.blkECReconstructionCmd.as_mut().unwrap()
    }

    // Take field
    pub fn take_blkECReconstructionCmd(&mut self) -> BlockECReconstructionCommandProto {
        self.blkECReconstructionCmd.take().unwrap_or_else(|| BlockECReconstructionCommandProto::new())
    }
}

impl ::protobuf::Message for DatanodeCommandProto {
    fn is_initialized(&self) -> bool {
        if self.cmdType.is_none() {
            return false;
        }
        for v in &self.balancerCmd {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.blkCmd {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.recoveryCmd {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.finalizeCmd {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.keyUpdateCmd {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.registerCmd {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.blkIdCmd {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.blkECReconstructionCmd {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.cmdType, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.balancerCmd)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.blkCmd)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.recoveryCmd)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.finalizeCmd)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.keyUpdateCmd)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.registerCmd)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.blkIdCmd)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.blkECReconstructionCmd)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.cmdType {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        if let Some(ref v) = self.balancerCmd.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.blkCmd.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.recoveryCmd.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.finalizeCmd.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.keyUpdateCmd.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.registerCmd.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.blkIdCmd.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.blkECReconstructionCmd.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.cmdType {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(ref v) = self.balancerCmd.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.blkCmd.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.recoveryCmd.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.finalizeCmd.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.keyUpdateCmd.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.registerCmd.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.blkIdCmd.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.blkECReconstructionCmd.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DatanodeCommandProto {
        DatanodeCommandProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<DatanodeCommandProto_Type>>(
                "cmdType",
                |m: &DatanodeCommandProto| { &m.cmdType },
                |m: &mut DatanodeCommandProto| { &mut m.cmdType },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BalancerBandwidthCommandProto>>(
                "balancerCmd",
                |m: &DatanodeCommandProto| { &m.balancerCmd },
                |m: &mut DatanodeCommandProto| { &mut m.balancerCmd },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BlockCommandProto>>(
                "blkCmd",
                |m: &DatanodeCommandProto| { &m.blkCmd },
                |m: &mut DatanodeCommandProto| { &mut m.blkCmd },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BlockRecoveryCommandProto>>(
                "recoveryCmd",
                |m: &DatanodeCommandProto| { &m.recoveryCmd },
                |m: &mut DatanodeCommandProto| { &mut m.recoveryCmd },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<FinalizeCommandProto>>(
                "finalizeCmd",
                |m: &DatanodeCommandProto| { &m.finalizeCmd },
                |m: &mut DatanodeCommandProto| { &mut m.finalizeCmd },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<KeyUpdateCommandProto>>(
                "keyUpdateCmd",
                |m: &DatanodeCommandProto| { &m.keyUpdateCmd },
                |m: &mut DatanodeCommandProto| { &mut m.keyUpdateCmd },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RegisterCommandProto>>(
                "registerCmd",
                |m: &DatanodeCommandProto| { &m.registerCmd },
                |m: &mut DatanodeCommandProto| { &mut m.registerCmd },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BlockIdCommandProto>>(
                "blkIdCmd",
                |m: &DatanodeCommandProto| { &m.blkIdCmd },
                |m: &mut DatanodeCommandProto| { &mut m.blkIdCmd },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BlockECReconstructionCommandProto>>(
                "blkECReconstructionCmd",
                |m: &DatanodeCommandProto| { &m.blkECReconstructionCmd },
                |m: &mut DatanodeCommandProto| { &mut m.blkECReconstructionCmd },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DatanodeCommandProto>(
                "DatanodeCommandProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DatanodeCommandProto {
        static instance: ::protobuf::rt::LazyV2<DatanodeCommandProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DatanodeCommandProto::new)
    }
}

impl ::protobuf::Clear for DatanodeCommandProto {
    fn clear(&mut self) {
        self.cmdType = ::std::option::Option::None;
        self.balancerCmd.clear();
        self.blkCmd.clear();
        self.recoveryCmd.clear();
        self.finalizeCmd.clear();
        self.keyUpdateCmd.clear();
        self.registerCmd.clear();
        self.blkIdCmd.clear();
        self.blkECReconstructionCmd.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DatanodeCommandProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DatanodeCommandProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum DatanodeCommandProto_Type {
    BalancerBandwidthCommand = 0,
    BlockCommand = 1,
    BlockRecoveryCommand = 2,
    FinalizeCommand = 3,
    KeyUpdateCommand = 4,
    RegisterCommand = 5,
    UnusedUpgradeCommand = 6,
    NullDatanodeCommand = 7,
    BlockIdCommand = 8,
    BlockECReconstructionCommand = 9,
}

impl ::protobuf::ProtobufEnum for DatanodeCommandProto_Type {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<DatanodeCommandProto_Type> {
        match value {
            0 => ::std::option::Option::Some(DatanodeCommandProto_Type::BalancerBandwidthCommand),
            1 => ::std::option::Option::Some(DatanodeCommandProto_Type::BlockCommand),
            2 => ::std::option::Option::Some(DatanodeCommandProto_Type::BlockRecoveryCommand),
            3 => ::std::option::Option::Some(DatanodeCommandProto_Type::FinalizeCommand),
            4 => ::std::option::Option::Some(DatanodeCommandProto_Type::KeyUpdateCommand),
            5 => ::std::option::Option::Some(DatanodeCommandProto_Type::RegisterCommand),
            6 => ::std::option::Option::Some(DatanodeCommandProto_Type::UnusedUpgradeCommand),
            7 => ::std::option::Option::Some(DatanodeCommandProto_Type::NullDatanodeCommand),
            8 => ::std::option::Option::Some(DatanodeCommandProto_Type::BlockIdCommand),
            9 => ::std::option::Option::Some(DatanodeCommandProto_Type::BlockECReconstructionCommand),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [DatanodeCommandProto_Type] = &[
            DatanodeCommandProto_Type::BalancerBandwidthCommand,
            DatanodeCommandProto_Type::BlockCommand,
            DatanodeCommandProto_Type::BlockRecoveryCommand,
            DatanodeCommandProto_Type::FinalizeCommand,
            DatanodeCommandProto_Type::KeyUpdateCommand,
            DatanodeCommandProto_Type::RegisterCommand,
            DatanodeCommandProto_Type::UnusedUpgradeCommand,
            DatanodeCommandProto_Type::NullDatanodeCommand,
            DatanodeCommandProto_Type::BlockIdCommand,
            DatanodeCommandProto_Type::BlockECReconstructionCommand,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<DatanodeCommandProto_Type>("DatanodeCommandProto.Type", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for DatanodeCommandProto_Type {
}

impl ::std::default::Default for DatanodeCommandProto_Type {
    fn default() -> Self {
        DatanodeCommandProto_Type::BalancerBandwidthCommand
    }
}

impl ::protobuf::reflect::ProtobufValue for DatanodeCommandProto_Type {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BalancerBandwidthCommandProto {
    // message fields
    bandwidth: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BalancerBandwidthCommandProto {
    fn default() -> &'a BalancerBandwidthCommandProto {
        <BalancerBandwidthCommandProto as ::protobuf::Message>::default_instance()
    }
}

impl BalancerBandwidthCommandProto {
    pub fn new() -> BalancerBandwidthCommandProto {
        ::std::default::Default::default()
    }

    // required uint64 bandwidth = 1;


    pub fn get_bandwidth(&self) -> u64 {
        self.bandwidth.unwrap_or(0)
    }
    pub fn clear_bandwidth(&mut self) {
        self.bandwidth = ::std::option::Option::None;
    }

    pub fn has_bandwidth(&self) -> bool {
        self.bandwidth.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bandwidth(&mut self, v: u64) {
        self.bandwidth = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for BalancerBandwidthCommandProto {
    fn is_initialized(&self) -> bool {
        if self.bandwidth.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.bandwidth = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.bandwidth {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.bandwidth {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BalancerBandwidthCommandProto {
        BalancerBandwidthCommandProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "bandwidth",
                |m: &BalancerBandwidthCommandProto| { &m.bandwidth },
                |m: &mut BalancerBandwidthCommandProto| { &mut m.bandwidth },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BalancerBandwidthCommandProto>(
                "BalancerBandwidthCommandProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BalancerBandwidthCommandProto {
        static instance: ::protobuf::rt::LazyV2<BalancerBandwidthCommandProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BalancerBandwidthCommandProto::new)
    }
}

impl ::protobuf::Clear for BalancerBandwidthCommandProto {
    fn clear(&mut self) {
        self.bandwidth = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BalancerBandwidthCommandProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BalancerBandwidthCommandProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BlockCommandProto {
    // message fields
    action: ::std::option::Option<BlockCommandProto_Action>,
    blockPoolId: ::protobuf::SingularField<::std::string::String>,
    pub blocks: ::protobuf::RepeatedField<super::hdfs::BlockProto>,
    pub targets: ::protobuf::RepeatedField<super::hdfs::DatanodeInfosProto>,
    pub targetStorageUuids: ::protobuf::RepeatedField<super::hdfs::StorageUuidsProto>,
    pub targetStorageTypes: ::protobuf::RepeatedField<super::hdfs::StorageTypesProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BlockCommandProto {
    fn default() -> &'a BlockCommandProto {
        <BlockCommandProto as ::protobuf::Message>::default_instance()
    }
}

impl BlockCommandProto {
    pub fn new() -> BlockCommandProto {
        ::std::default::Default::default()
    }

    // required .hadoop.hdfs.BlockCommandProto.Action action = 1;


    pub fn get_action(&self) -> BlockCommandProto_Action {
        self.action.unwrap_or(BlockCommandProto_Action::TRANSFER)
    }
    pub fn clear_action(&mut self) {
        self.action = ::std::option::Option::None;
    }

    pub fn has_action(&self) -> bool {
        self.action.is_some()
    }

    // Param is passed by value, moved
    pub fn set_action(&mut self, v: BlockCommandProto_Action) {
        self.action = ::std::option::Option::Some(v);
    }

    // required string blockPoolId = 2;


    pub fn get_blockPoolId(&self) -> &str {
        match self.blockPoolId.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_blockPoolId(&mut self) {
        self.blockPoolId.clear();
    }

    pub fn has_blockPoolId(&self) -> bool {
        self.blockPoolId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_blockPoolId(&mut self, v: ::std::string::String) {
        self.blockPoolId = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_blockPoolId(&mut self) -> &mut ::std::string::String {
        if self.blockPoolId.is_none() {
            self.blockPoolId.set_default();
        }
        self.blockPoolId.as_mut().unwrap()
    }

    // Take field
    pub fn take_blockPoolId(&mut self) -> ::std::string::String {
        self.blockPoolId.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated .hadoop.hdfs.BlockProto blocks = 3;


    pub fn get_blocks(&self) -> &[super::hdfs::BlockProto] {
        &self.blocks
    }
    pub fn clear_blocks(&mut self) {
        self.blocks.clear();
    }

    // Param is passed by value, moved
    pub fn set_blocks(&mut self, v: ::protobuf::RepeatedField<super::hdfs::BlockProto>) {
        self.blocks = v;
    }

    // Mutable pointer to the field.
    pub fn mut_blocks(&mut self) -> &mut ::protobuf::RepeatedField<super::hdfs::BlockProto> {
        &mut self.blocks
    }

    // Take field
    pub fn take_blocks(&mut self) -> ::protobuf::RepeatedField<super::hdfs::BlockProto> {
        ::std::mem::replace(&mut self.blocks, ::protobuf::RepeatedField::new())
    }

    // repeated .hadoop.hdfs.DatanodeInfosProto targets = 4;


    pub fn get_targets(&self) -> &[super::hdfs::DatanodeInfosProto] {
        &self.targets
    }
    pub fn clear_targets(&mut self) {
        self.targets.clear();
    }

    // Param is passed by value, moved
    pub fn set_targets(&mut self, v: ::protobuf::RepeatedField<super::hdfs::DatanodeInfosProto>) {
        self.targets = v;
    }

    // Mutable pointer to the field.
    pub fn mut_targets(&mut self) -> &mut ::protobuf::RepeatedField<super::hdfs::DatanodeInfosProto> {
        &mut self.targets
    }

    // Take field
    pub fn take_targets(&mut self) -> ::protobuf::RepeatedField<super::hdfs::DatanodeInfosProto> {
        ::std::mem::replace(&mut self.targets, ::protobuf::RepeatedField::new())
    }

    // repeated .hadoop.hdfs.StorageUuidsProto targetStorageUuids = 5;


    pub fn get_targetStorageUuids(&self) -> &[super::hdfs::StorageUuidsProto] {
        &self.targetStorageUuids
    }
    pub fn clear_targetStorageUuids(&mut self) {
        self.targetStorageUuids.clear();
    }

    // Param is passed by value, moved
    pub fn set_targetStorageUuids(&mut self, v: ::protobuf::RepeatedField<super::hdfs::StorageUuidsProto>) {
        self.targetStorageUuids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_targetStorageUuids(&mut self) -> &mut ::protobuf::RepeatedField<super::hdfs::StorageUuidsProto> {
        &mut self.targetStorageUuids
    }

    // Take field
    pub fn take_targetStorageUuids(&mut self) -> ::protobuf::RepeatedField<super::hdfs::StorageUuidsProto> {
        ::std::mem::replace(&mut self.targetStorageUuids, ::protobuf::RepeatedField::new())
    }

    // repeated .hadoop.hdfs.StorageTypesProto targetStorageTypes = 6;


    pub fn get_targetStorageTypes(&self) -> &[super::hdfs::StorageTypesProto] {
        &self.targetStorageTypes
    }
    pub fn clear_targetStorageTypes(&mut self) {
        self.targetStorageTypes.clear();
    }

    // Param is passed by value, moved
    pub fn set_targetStorageTypes(&mut self, v: ::protobuf::RepeatedField<super::hdfs::StorageTypesProto>) {
        self.targetStorageTypes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_targetStorageTypes(&mut self) -> &mut ::protobuf::RepeatedField<super::hdfs::StorageTypesProto> {
        &mut self.targetStorageTypes
    }

    // Take field
    pub fn take_targetStorageTypes(&mut self) -> ::protobuf::RepeatedField<super::hdfs::StorageTypesProto> {
        ::std::mem::replace(&mut self.targetStorageTypes, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for BlockCommandProto {
    fn is_initialized(&self) -> bool {
        if self.action.is_none() {
            return false;
        }
        if self.blockPoolId.is_none() {
            return false;
        }
        for v in &self.blocks {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.targets {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.targetStorageUuids {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.targetStorageTypes {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.action, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.blockPoolId)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.blocks)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.targets)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.targetStorageUuids)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.targetStorageTypes)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.action {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        if let Some(ref v) = self.blockPoolId.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        for value in &self.blocks {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.targets {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.targetStorageUuids {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.targetStorageTypes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.action {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(ref v) = self.blockPoolId.as_ref() {
            os.write_string(2, &v)?;
        }
        for v in &self.blocks {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.targets {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.targetStorageUuids {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.targetStorageTypes {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BlockCommandProto {
        BlockCommandProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<BlockCommandProto_Action>>(
                "action",
                |m: &BlockCommandProto| { &m.action },
                |m: &mut BlockCommandProto| { &mut m.action },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "blockPoolId",
                |m: &BlockCommandProto| { &m.blockPoolId },
                |m: &mut BlockCommandProto| { &mut m.blockPoolId },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::hdfs::BlockProto>>(
                "blocks",
                |m: &BlockCommandProto| { &m.blocks },
                |m: &mut BlockCommandProto| { &mut m.blocks },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::hdfs::DatanodeInfosProto>>(
                "targets",
                |m: &BlockCommandProto| { &m.targets },
                |m: &mut BlockCommandProto| { &mut m.targets },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::hdfs::StorageUuidsProto>>(
                "targetStorageUuids",
                |m: &BlockCommandProto| { &m.targetStorageUuids },
                |m: &mut BlockCommandProto| { &mut m.targetStorageUuids },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::hdfs::StorageTypesProto>>(
                "targetStorageTypes",
                |m: &BlockCommandProto| { &m.targetStorageTypes },
                |m: &mut BlockCommandProto| { &mut m.targetStorageTypes },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BlockCommandProto>(
                "BlockCommandProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BlockCommandProto {
        static instance: ::protobuf::rt::LazyV2<BlockCommandProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BlockCommandProto::new)
    }
}

impl ::protobuf::Clear for BlockCommandProto {
    fn clear(&mut self) {
        self.action = ::std::option::Option::None;
        self.blockPoolId.clear();
        self.blocks.clear();
        self.targets.clear();
        self.targetStorageUuids.clear();
        self.targetStorageTypes.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BlockCommandProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BlockCommandProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum BlockCommandProto_Action {
    TRANSFER = 1,
    INVALIDATE = 2,
    SHUTDOWN = 3,
}

impl ::protobuf::ProtobufEnum for BlockCommandProto_Action {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<BlockCommandProto_Action> {
        match value {
            1 => ::std::option::Option::Some(BlockCommandProto_Action::TRANSFER),
            2 => ::std::option::Option::Some(BlockCommandProto_Action::INVALIDATE),
            3 => ::std::option::Option::Some(BlockCommandProto_Action::SHUTDOWN),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [BlockCommandProto_Action] = &[
            BlockCommandProto_Action::TRANSFER,
            BlockCommandProto_Action::INVALIDATE,
            BlockCommandProto_Action::SHUTDOWN,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<BlockCommandProto_Action>("BlockCommandProto.Action", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for BlockCommandProto_Action {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for BlockCommandProto_Action {
    fn default() -> Self {
        BlockCommandProto_Action::TRANSFER
    }
}

impl ::protobuf::reflect::ProtobufValue for BlockCommandProto_Action {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BlockIdCommandProto {
    // message fields
    action: ::std::option::Option<BlockIdCommandProto_Action>,
    blockPoolId: ::protobuf::SingularField<::std::string::String>,
    pub blockIds: ::std::vec::Vec<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BlockIdCommandProto {
    fn default() -> &'a BlockIdCommandProto {
        <BlockIdCommandProto as ::protobuf::Message>::default_instance()
    }
}

impl BlockIdCommandProto {
    pub fn new() -> BlockIdCommandProto {
        ::std::default::Default::default()
    }

    // required .hadoop.hdfs.BlockIdCommandProto.Action action = 1;


    pub fn get_action(&self) -> BlockIdCommandProto_Action {
        self.action.unwrap_or(BlockIdCommandProto_Action::CACHE)
    }
    pub fn clear_action(&mut self) {
        self.action = ::std::option::Option::None;
    }

    pub fn has_action(&self) -> bool {
        self.action.is_some()
    }

    // Param is passed by value, moved
    pub fn set_action(&mut self, v: BlockIdCommandProto_Action) {
        self.action = ::std::option::Option::Some(v);
    }

    // required string blockPoolId = 2;


    pub fn get_blockPoolId(&self) -> &str {
        match self.blockPoolId.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_blockPoolId(&mut self) {
        self.blockPoolId.clear();
    }

    pub fn has_blockPoolId(&self) -> bool {
        self.blockPoolId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_blockPoolId(&mut self, v: ::std::string::String) {
        self.blockPoolId = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_blockPoolId(&mut self) -> &mut ::std::string::String {
        if self.blockPoolId.is_none() {
            self.blockPoolId.set_default();
        }
        self.blockPoolId.as_mut().unwrap()
    }

    // Take field
    pub fn take_blockPoolId(&mut self) -> ::std::string::String {
        self.blockPoolId.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated uint64 blockIds = 3;


    pub fn get_blockIds(&self) -> &[u64] {
        &self.blockIds
    }
    pub fn clear_blockIds(&mut self) {
        self.blockIds.clear();
    }

    // Param is passed by value, moved
    pub fn set_blockIds(&mut self, v: ::std::vec::Vec<u64>) {
        self.blockIds = v;
    }

    // Mutable pointer to the field.
    pub fn mut_blockIds(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.blockIds
    }

    // Take field
    pub fn take_blockIds(&mut self) -> ::std::vec::Vec<u64> {
        ::std::mem::replace(&mut self.blockIds, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for BlockIdCommandProto {
    fn is_initialized(&self) -> bool {
        if self.action.is_none() {
            return false;
        }
        if self.blockPoolId.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.action, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.blockPoolId)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_uint64_into(wire_type, is, &mut self.blockIds)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.action {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        if let Some(ref v) = self.blockPoolId.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if !self.blockIds.is_empty() {
            my_size += ::protobuf::rt::vec_packed_varint_size(3, &self.blockIds);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.action {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(ref v) = self.blockPoolId.as_ref() {
            os.write_string(2, &v)?;
        }
        if !self.blockIds.is_empty() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            // TODO: Data size is computed again, it should be cached
            os.write_raw_varint32(::protobuf::rt::vec_packed_varint_data_size(&self.blockIds))?;
            for v in &self.blockIds {
                os.write_uint64_no_tag(*v)?;
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BlockIdCommandProto {
        BlockIdCommandProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<BlockIdCommandProto_Action>>(
                "action",
                |m: &BlockIdCommandProto| { &m.action },
                |m: &mut BlockIdCommandProto| { &mut m.action },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "blockPoolId",
                |m: &BlockIdCommandProto| { &m.blockPoolId },
                |m: &mut BlockIdCommandProto| { &mut m.blockPoolId },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "blockIds",
                |m: &BlockIdCommandProto| { &m.blockIds },
                |m: &mut BlockIdCommandProto| { &mut m.blockIds },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BlockIdCommandProto>(
                "BlockIdCommandProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BlockIdCommandProto {
        static instance: ::protobuf::rt::LazyV2<BlockIdCommandProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BlockIdCommandProto::new)
    }
}

impl ::protobuf::Clear for BlockIdCommandProto {
    fn clear(&mut self) {
        self.action = ::std::option::Option::None;
        self.blockPoolId.clear();
        self.blockIds.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BlockIdCommandProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BlockIdCommandProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum BlockIdCommandProto_Action {
    CACHE = 1,
    UNCACHE = 2,
}

impl ::protobuf::ProtobufEnum for BlockIdCommandProto_Action {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<BlockIdCommandProto_Action> {
        match value {
            1 => ::std::option::Option::Some(BlockIdCommandProto_Action::CACHE),
            2 => ::std::option::Option::Some(BlockIdCommandProto_Action::UNCACHE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [BlockIdCommandProto_Action] = &[
            BlockIdCommandProto_Action::CACHE,
            BlockIdCommandProto_Action::UNCACHE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<BlockIdCommandProto_Action>("BlockIdCommandProto.Action", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for BlockIdCommandProto_Action {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for BlockIdCommandProto_Action {
    fn default() -> Self {
        BlockIdCommandProto_Action::CACHE
    }
}

impl ::protobuf::reflect::ProtobufValue for BlockIdCommandProto_Action {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BlockRecoveryCommandProto {
    // message fields
    pub blocks: ::protobuf::RepeatedField<super::HdfsServer::RecoveringBlockProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BlockRecoveryCommandProto {
    fn default() -> &'a BlockRecoveryCommandProto {
        <BlockRecoveryCommandProto as ::protobuf::Message>::default_instance()
    }
}

impl BlockRecoveryCommandProto {
    pub fn new() -> BlockRecoveryCommandProto {
        ::std::default::Default::default()
    }

    // repeated .hadoop.hdfs.RecoveringBlockProto blocks = 1;


    pub fn get_blocks(&self) -> &[super::HdfsServer::RecoveringBlockProto] {
        &self.blocks
    }
    pub fn clear_blocks(&mut self) {
        self.blocks.clear();
    }

    // Param is passed by value, moved
    pub fn set_blocks(&mut self, v: ::protobuf::RepeatedField<super::HdfsServer::RecoveringBlockProto>) {
        self.blocks = v;
    }

    // Mutable pointer to the field.
    pub fn mut_blocks(&mut self) -> &mut ::protobuf::RepeatedField<super::HdfsServer::RecoveringBlockProto> {
        &mut self.blocks
    }

    // Take field
    pub fn take_blocks(&mut self) -> ::protobuf::RepeatedField<super::HdfsServer::RecoveringBlockProto> {
        ::std::mem::replace(&mut self.blocks, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for BlockRecoveryCommandProto {
    fn is_initialized(&self) -> bool {
        for v in &self.blocks {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.blocks)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.blocks {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.blocks {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BlockRecoveryCommandProto {
        BlockRecoveryCommandProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::HdfsServer::RecoveringBlockProto>>(
                "blocks",
                |m: &BlockRecoveryCommandProto| { &m.blocks },
                |m: &mut BlockRecoveryCommandProto| { &mut m.blocks },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BlockRecoveryCommandProto>(
                "BlockRecoveryCommandProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BlockRecoveryCommandProto {
        static instance: ::protobuf::rt::LazyV2<BlockRecoveryCommandProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BlockRecoveryCommandProto::new)
    }
}

impl ::protobuf::Clear for BlockRecoveryCommandProto {
    fn clear(&mut self) {
        self.blocks.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BlockRecoveryCommandProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BlockRecoveryCommandProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FinalizeCommandProto {
    // message fields
    blockPoolId: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FinalizeCommandProto {
    fn default() -> &'a FinalizeCommandProto {
        <FinalizeCommandProto as ::protobuf::Message>::default_instance()
    }
}

impl FinalizeCommandProto {
    pub fn new() -> FinalizeCommandProto {
        ::std::default::Default::default()
    }

    // required string blockPoolId = 1;


    pub fn get_blockPoolId(&self) -> &str {
        match self.blockPoolId.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_blockPoolId(&mut self) {
        self.blockPoolId.clear();
    }

    pub fn has_blockPoolId(&self) -> bool {
        self.blockPoolId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_blockPoolId(&mut self, v: ::std::string::String) {
        self.blockPoolId = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_blockPoolId(&mut self) -> &mut ::std::string::String {
        if self.blockPoolId.is_none() {
            self.blockPoolId.set_default();
        }
        self.blockPoolId.as_mut().unwrap()
    }

    // Take field
    pub fn take_blockPoolId(&mut self) -> ::std::string::String {
        self.blockPoolId.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for FinalizeCommandProto {
    fn is_initialized(&self) -> bool {
        if self.blockPoolId.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.blockPoolId)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.blockPoolId.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.blockPoolId.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FinalizeCommandProto {
        FinalizeCommandProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "blockPoolId",
                |m: &FinalizeCommandProto| { &m.blockPoolId },
                |m: &mut FinalizeCommandProto| { &mut m.blockPoolId },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<FinalizeCommandProto>(
                "FinalizeCommandProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static FinalizeCommandProto {
        static instance: ::protobuf::rt::LazyV2<FinalizeCommandProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(FinalizeCommandProto::new)
    }
}

impl ::protobuf::Clear for FinalizeCommandProto {
    fn clear(&mut self) {
        self.blockPoolId.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FinalizeCommandProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FinalizeCommandProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct KeyUpdateCommandProto {
    // message fields
    pub keys: ::protobuf::SingularPtrField<super::HdfsServer::ExportedBlockKeysProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a KeyUpdateCommandProto {
    fn default() -> &'a KeyUpdateCommandProto {
        <KeyUpdateCommandProto as ::protobuf::Message>::default_instance()
    }
}

impl KeyUpdateCommandProto {
    pub fn new() -> KeyUpdateCommandProto {
        ::std::default::Default::default()
    }

    // required .hadoop.hdfs.ExportedBlockKeysProto keys = 1;


    pub fn get_keys(&self) -> &super::HdfsServer::ExportedBlockKeysProto {
        self.keys.as_ref().unwrap_or_else(|| <super::HdfsServer::ExportedBlockKeysProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_keys(&mut self) {
        self.keys.clear();
    }

    pub fn has_keys(&self) -> bool {
        self.keys.is_some()
    }

    // Param is passed by value, moved
    pub fn set_keys(&mut self, v: super::HdfsServer::ExportedBlockKeysProto) {
        self.keys = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_keys(&mut self) -> &mut super::HdfsServer::ExportedBlockKeysProto {
        if self.keys.is_none() {
            self.keys.set_default();
        }
        self.keys.as_mut().unwrap()
    }

    // Take field
    pub fn take_keys(&mut self) -> super::HdfsServer::ExportedBlockKeysProto {
        self.keys.take().unwrap_or_else(|| super::HdfsServer::ExportedBlockKeysProto::new())
    }
}

impl ::protobuf::Message for KeyUpdateCommandProto {
    fn is_initialized(&self) -> bool {
        if self.keys.is_none() {
            return false;
        }
        for v in &self.keys {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.keys)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.keys.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.keys.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> KeyUpdateCommandProto {
        KeyUpdateCommandProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::HdfsServer::ExportedBlockKeysProto>>(
                "keys",
                |m: &KeyUpdateCommandProto| { &m.keys },
                |m: &mut KeyUpdateCommandProto| { &mut m.keys },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<KeyUpdateCommandProto>(
                "KeyUpdateCommandProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static KeyUpdateCommandProto {
        static instance: ::protobuf::rt::LazyV2<KeyUpdateCommandProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(KeyUpdateCommandProto::new)
    }
}

impl ::protobuf::Clear for KeyUpdateCommandProto {
    fn clear(&mut self) {
        self.keys.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for KeyUpdateCommandProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for KeyUpdateCommandProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RegisterCommandProto {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RegisterCommandProto {
    fn default() -> &'a RegisterCommandProto {
        <RegisterCommandProto as ::protobuf::Message>::default_instance()
    }
}

impl RegisterCommandProto {
    pub fn new() -> RegisterCommandProto {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for RegisterCommandProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RegisterCommandProto {
        RegisterCommandProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RegisterCommandProto>(
                "RegisterCommandProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RegisterCommandProto {
        static instance: ::protobuf::rt::LazyV2<RegisterCommandProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RegisterCommandProto::new)
    }
}

impl ::protobuf::Clear for RegisterCommandProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RegisterCommandProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RegisterCommandProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BlockECReconstructionCommandProto {
    // message fields
    pub blockECReconstructioninfo: ::protobuf::RepeatedField<super::erasurecoding::BlockECReconstructionInfoProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BlockECReconstructionCommandProto {
    fn default() -> &'a BlockECReconstructionCommandProto {
        <BlockECReconstructionCommandProto as ::protobuf::Message>::default_instance()
    }
}

impl BlockECReconstructionCommandProto {
    pub fn new() -> BlockECReconstructionCommandProto {
        ::std::default::Default::default()
    }

    // repeated .hadoop.hdfs.BlockECReconstructionInfoProto blockECReconstructioninfo = 1;


    pub fn get_blockECReconstructioninfo(&self) -> &[super::erasurecoding::BlockECReconstructionInfoProto] {
        &self.blockECReconstructioninfo
    }
    pub fn clear_blockECReconstructioninfo(&mut self) {
        self.blockECReconstructioninfo.clear();
    }

    // Param is passed by value, moved
    pub fn set_blockECReconstructioninfo(&mut self, v: ::protobuf::RepeatedField<super::erasurecoding::BlockECReconstructionInfoProto>) {
        self.blockECReconstructioninfo = v;
    }

    // Mutable pointer to the field.
    pub fn mut_blockECReconstructioninfo(&mut self) -> &mut ::protobuf::RepeatedField<super::erasurecoding::BlockECReconstructionInfoProto> {
        &mut self.blockECReconstructioninfo
    }

    // Take field
    pub fn take_blockECReconstructioninfo(&mut self) -> ::protobuf::RepeatedField<super::erasurecoding::BlockECReconstructionInfoProto> {
        ::std::mem::replace(&mut self.blockECReconstructioninfo, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for BlockECReconstructionCommandProto {
    fn is_initialized(&self) -> bool {
        for v in &self.blockECReconstructioninfo {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.blockECReconstructioninfo)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.blockECReconstructioninfo {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.blockECReconstructioninfo {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BlockECReconstructionCommandProto {
        BlockECReconstructionCommandProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::erasurecoding::BlockECReconstructionInfoProto>>(
                "blockECReconstructioninfo",
                |m: &BlockECReconstructionCommandProto| { &m.blockECReconstructioninfo },
                |m: &mut BlockECReconstructionCommandProto| { &mut m.blockECReconstructioninfo },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BlockECReconstructionCommandProto>(
                "BlockECReconstructionCommandProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BlockECReconstructionCommandProto {
        static instance: ::protobuf::rt::LazyV2<BlockECReconstructionCommandProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BlockECReconstructionCommandProto::new)
    }
}

impl ::protobuf::Clear for BlockECReconstructionCommandProto {
    fn clear(&mut self) {
        self.blockECReconstructioninfo.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BlockECReconstructionCommandProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BlockECReconstructionCommandProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RegisterDatanodeRequestProto {
    // message fields
    pub registration: ::protobuf::SingularPtrField<DatanodeRegistrationProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RegisterDatanodeRequestProto {
    fn default() -> &'a RegisterDatanodeRequestProto {
        <RegisterDatanodeRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl RegisterDatanodeRequestProto {
    pub fn new() -> RegisterDatanodeRequestProto {
        ::std::default::Default::default()
    }

    // required .hadoop.hdfs.DatanodeRegistrationProto registration = 1;


    pub fn get_registration(&self) -> &DatanodeRegistrationProto {
        self.registration.as_ref().unwrap_or_else(|| <DatanodeRegistrationProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_registration(&mut self) {
        self.registration.clear();
    }

    pub fn has_registration(&self) -> bool {
        self.registration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_registration(&mut self, v: DatanodeRegistrationProto) {
        self.registration = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_registration(&mut self) -> &mut DatanodeRegistrationProto {
        if self.registration.is_none() {
            self.registration.set_default();
        }
        self.registration.as_mut().unwrap()
    }

    // Take field
    pub fn take_registration(&mut self) -> DatanodeRegistrationProto {
        self.registration.take().unwrap_or_else(|| DatanodeRegistrationProto::new())
    }
}

impl ::protobuf::Message for RegisterDatanodeRequestProto {
    fn is_initialized(&self) -> bool {
        if self.registration.is_none() {
            return false;
        }
        for v in &self.registration {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.registration)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.registration.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.registration.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RegisterDatanodeRequestProto {
        RegisterDatanodeRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DatanodeRegistrationProto>>(
                "registration",
                |m: &RegisterDatanodeRequestProto| { &m.registration },
                |m: &mut RegisterDatanodeRequestProto| { &mut m.registration },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RegisterDatanodeRequestProto>(
                "RegisterDatanodeRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RegisterDatanodeRequestProto {
        static instance: ::protobuf::rt::LazyV2<RegisterDatanodeRequestProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RegisterDatanodeRequestProto::new)
    }
}

impl ::protobuf::Clear for RegisterDatanodeRequestProto {
    fn clear(&mut self) {
        self.registration.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RegisterDatanodeRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RegisterDatanodeRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RegisterDatanodeResponseProto {
    // message fields
    pub registration: ::protobuf::SingularPtrField<DatanodeRegistrationProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RegisterDatanodeResponseProto {
    fn default() -> &'a RegisterDatanodeResponseProto {
        <RegisterDatanodeResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl RegisterDatanodeResponseProto {
    pub fn new() -> RegisterDatanodeResponseProto {
        ::std::default::Default::default()
    }

    // required .hadoop.hdfs.DatanodeRegistrationProto registration = 1;


    pub fn get_registration(&self) -> &DatanodeRegistrationProto {
        self.registration.as_ref().unwrap_or_else(|| <DatanodeRegistrationProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_registration(&mut self) {
        self.registration.clear();
    }

    pub fn has_registration(&self) -> bool {
        self.registration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_registration(&mut self, v: DatanodeRegistrationProto) {
        self.registration = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_registration(&mut self) -> &mut DatanodeRegistrationProto {
        if self.registration.is_none() {
            self.registration.set_default();
        }
        self.registration.as_mut().unwrap()
    }

    // Take field
    pub fn take_registration(&mut self) -> DatanodeRegistrationProto {
        self.registration.take().unwrap_or_else(|| DatanodeRegistrationProto::new())
    }
}

impl ::protobuf::Message for RegisterDatanodeResponseProto {
    fn is_initialized(&self) -> bool {
        if self.registration.is_none() {
            return false;
        }
        for v in &self.registration {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.registration)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.registration.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.registration.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RegisterDatanodeResponseProto {
        RegisterDatanodeResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DatanodeRegistrationProto>>(
                "registration",
                |m: &RegisterDatanodeResponseProto| { &m.registration },
                |m: &mut RegisterDatanodeResponseProto| { &mut m.registration },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RegisterDatanodeResponseProto>(
                "RegisterDatanodeResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RegisterDatanodeResponseProto {
        static instance: ::protobuf::rt::LazyV2<RegisterDatanodeResponseProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RegisterDatanodeResponseProto::new)
    }
}

impl ::protobuf::Clear for RegisterDatanodeResponseProto {
    fn clear(&mut self) {
        self.registration.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RegisterDatanodeResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RegisterDatanodeResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct VolumeFailureSummaryProto {
    // message fields
    pub failedStorageLocations: ::protobuf::RepeatedField<::std::string::String>,
    lastVolumeFailureDate: ::std::option::Option<u64>,
    estimatedCapacityLostTotal: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VolumeFailureSummaryProto {
    fn default() -> &'a VolumeFailureSummaryProto {
        <VolumeFailureSummaryProto as ::protobuf::Message>::default_instance()
    }
}

impl VolumeFailureSummaryProto {
    pub fn new() -> VolumeFailureSummaryProto {
        ::std::default::Default::default()
    }

    // repeated string failedStorageLocations = 1;


    pub fn get_failedStorageLocations(&self) -> &[::std::string::String] {
        &self.failedStorageLocations
    }
    pub fn clear_failedStorageLocations(&mut self) {
        self.failedStorageLocations.clear();
    }

    // Param is passed by value, moved
    pub fn set_failedStorageLocations(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.failedStorageLocations = v;
    }

    // Mutable pointer to the field.
    pub fn mut_failedStorageLocations(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.failedStorageLocations
    }

    // Take field
    pub fn take_failedStorageLocations(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.failedStorageLocations, ::protobuf::RepeatedField::new())
    }

    // required uint64 lastVolumeFailureDate = 2;


    pub fn get_lastVolumeFailureDate(&self) -> u64 {
        self.lastVolumeFailureDate.unwrap_or(0)
    }
    pub fn clear_lastVolumeFailureDate(&mut self) {
        self.lastVolumeFailureDate = ::std::option::Option::None;
    }

    pub fn has_lastVolumeFailureDate(&self) -> bool {
        self.lastVolumeFailureDate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lastVolumeFailureDate(&mut self, v: u64) {
        self.lastVolumeFailureDate = ::std::option::Option::Some(v);
    }

    // required uint64 estimatedCapacityLostTotal = 3;


    pub fn get_estimatedCapacityLostTotal(&self) -> u64 {
        self.estimatedCapacityLostTotal.unwrap_or(0)
    }
    pub fn clear_estimatedCapacityLostTotal(&mut self) {
        self.estimatedCapacityLostTotal = ::std::option::Option::None;
    }

    pub fn has_estimatedCapacityLostTotal(&self) -> bool {
        self.estimatedCapacityLostTotal.is_some()
    }

    // Param is passed by value, moved
    pub fn set_estimatedCapacityLostTotal(&mut self, v: u64) {
        self.estimatedCapacityLostTotal = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for VolumeFailureSummaryProto {
    fn is_initialized(&self) -> bool {
        if self.lastVolumeFailureDate.is_none() {
            return false;
        }
        if self.estimatedCapacityLostTotal.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.failedStorageLocations)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.lastVolumeFailureDate = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.estimatedCapacityLostTotal = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.failedStorageLocations {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        if let Some(v) = self.lastVolumeFailureDate {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.estimatedCapacityLostTotal {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.failedStorageLocations {
            os.write_string(1, &v)?;
        };
        if let Some(v) = self.lastVolumeFailureDate {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.estimatedCapacityLostTotal {
            os.write_uint64(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VolumeFailureSummaryProto {
        VolumeFailureSummaryProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "failedStorageLocations",
                |m: &VolumeFailureSummaryProto| { &m.failedStorageLocations },
                |m: &mut VolumeFailureSummaryProto| { &mut m.failedStorageLocations },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "lastVolumeFailureDate",
                |m: &VolumeFailureSummaryProto| { &m.lastVolumeFailureDate },
                |m: &mut VolumeFailureSummaryProto| { &mut m.lastVolumeFailureDate },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "estimatedCapacityLostTotal",
                |m: &VolumeFailureSummaryProto| { &m.estimatedCapacityLostTotal },
                |m: &mut VolumeFailureSummaryProto| { &mut m.estimatedCapacityLostTotal },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<VolumeFailureSummaryProto>(
                "VolumeFailureSummaryProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static VolumeFailureSummaryProto {
        static instance: ::protobuf::rt::LazyV2<VolumeFailureSummaryProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(VolumeFailureSummaryProto::new)
    }
}

impl ::protobuf::Clear for VolumeFailureSummaryProto {
    fn clear(&mut self) {
        self.failedStorageLocations.clear();
        self.lastVolumeFailureDate = ::std::option::Option::None;
        self.estimatedCapacityLostTotal = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VolumeFailureSummaryProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VolumeFailureSummaryProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct HeartbeatRequestProto {
    // message fields
    pub registration: ::protobuf::SingularPtrField<DatanodeRegistrationProto>,
    pub reports: ::protobuf::RepeatedField<super::hdfs::StorageReportProto>,
    xmitsInProgress: ::std::option::Option<u32>,
    xceiverCount: ::std::option::Option<u32>,
    failedVolumes: ::std::option::Option<u32>,
    cacheCapacity: ::std::option::Option<u64>,
    cacheUsed: ::std::option::Option<u64>,
    pub volumeFailureSummary: ::protobuf::SingularPtrField<VolumeFailureSummaryProto>,
    requestFullBlockReportLease: ::std::option::Option<bool>,
    pub slowPeers: ::protobuf::RepeatedField<SlowPeerReportProto>,
    pub slowDisks: ::protobuf::RepeatedField<SlowDiskReportProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a HeartbeatRequestProto {
    fn default() -> &'a HeartbeatRequestProto {
        <HeartbeatRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl HeartbeatRequestProto {
    pub fn new() -> HeartbeatRequestProto {
        ::std::default::Default::default()
    }

    // required .hadoop.hdfs.DatanodeRegistrationProto registration = 1;


    pub fn get_registration(&self) -> &DatanodeRegistrationProto {
        self.registration.as_ref().unwrap_or_else(|| <DatanodeRegistrationProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_registration(&mut self) {
        self.registration.clear();
    }

    pub fn has_registration(&self) -> bool {
        self.registration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_registration(&mut self, v: DatanodeRegistrationProto) {
        self.registration = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_registration(&mut self) -> &mut DatanodeRegistrationProto {
        if self.registration.is_none() {
            self.registration.set_default();
        }
        self.registration.as_mut().unwrap()
    }

    // Take field
    pub fn take_registration(&mut self) -> DatanodeRegistrationProto {
        self.registration.take().unwrap_or_else(|| DatanodeRegistrationProto::new())
    }

    // repeated .hadoop.hdfs.StorageReportProto reports = 2;


    pub fn get_reports(&self) -> &[super::hdfs::StorageReportProto] {
        &self.reports
    }
    pub fn clear_reports(&mut self) {
        self.reports.clear();
    }

    // Param is passed by value, moved
    pub fn set_reports(&mut self, v: ::protobuf::RepeatedField<super::hdfs::StorageReportProto>) {
        self.reports = v;
    }

    // Mutable pointer to the field.
    pub fn mut_reports(&mut self) -> &mut ::protobuf::RepeatedField<super::hdfs::StorageReportProto> {
        &mut self.reports
    }

    // Take field
    pub fn take_reports(&mut self) -> ::protobuf::RepeatedField<super::hdfs::StorageReportProto> {
        ::std::mem::replace(&mut self.reports, ::protobuf::RepeatedField::new())
    }

    // optional uint32 xmitsInProgress = 3;


    pub fn get_xmitsInProgress(&self) -> u32 {
        self.xmitsInProgress.unwrap_or(0u32)
    }
    pub fn clear_xmitsInProgress(&mut self) {
        self.xmitsInProgress = ::std::option::Option::None;
    }

    pub fn has_xmitsInProgress(&self) -> bool {
        self.xmitsInProgress.is_some()
    }

    // Param is passed by value, moved
    pub fn set_xmitsInProgress(&mut self, v: u32) {
        self.xmitsInProgress = ::std::option::Option::Some(v);
    }

    // optional uint32 xceiverCount = 4;


    pub fn get_xceiverCount(&self) -> u32 {
        self.xceiverCount.unwrap_or(0u32)
    }
    pub fn clear_xceiverCount(&mut self) {
        self.xceiverCount = ::std::option::Option::None;
    }

    pub fn has_xceiverCount(&self) -> bool {
        self.xceiverCount.is_some()
    }

    // Param is passed by value, moved
    pub fn set_xceiverCount(&mut self, v: u32) {
        self.xceiverCount = ::std::option::Option::Some(v);
    }

    // optional uint32 failedVolumes = 5;


    pub fn get_failedVolumes(&self) -> u32 {
        self.failedVolumes.unwrap_or(0u32)
    }
    pub fn clear_failedVolumes(&mut self) {
        self.failedVolumes = ::std::option::Option::None;
    }

    pub fn has_failedVolumes(&self) -> bool {
        self.failedVolumes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_failedVolumes(&mut self, v: u32) {
        self.failedVolumes = ::std::option::Option::Some(v);
    }

    // optional uint64 cacheCapacity = 6;


    pub fn get_cacheCapacity(&self) -> u64 {
        self.cacheCapacity.unwrap_or(0u64)
    }
    pub fn clear_cacheCapacity(&mut self) {
        self.cacheCapacity = ::std::option::Option::None;
    }

    pub fn has_cacheCapacity(&self) -> bool {
        self.cacheCapacity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cacheCapacity(&mut self, v: u64) {
        self.cacheCapacity = ::std::option::Option::Some(v);
    }

    // optional uint64 cacheUsed = 7;


    pub fn get_cacheUsed(&self) -> u64 {
        self.cacheUsed.unwrap_or(0u64)
    }
    pub fn clear_cacheUsed(&mut self) {
        self.cacheUsed = ::std::option::Option::None;
    }

    pub fn has_cacheUsed(&self) -> bool {
        self.cacheUsed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cacheUsed(&mut self, v: u64) {
        self.cacheUsed = ::std::option::Option::Some(v);
    }

    // optional .hadoop.hdfs.VolumeFailureSummaryProto volumeFailureSummary = 8;


    pub fn get_volumeFailureSummary(&self) -> &VolumeFailureSummaryProto {
        self.volumeFailureSummary.as_ref().unwrap_or_else(|| <VolumeFailureSummaryProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_volumeFailureSummary(&mut self) {
        self.volumeFailureSummary.clear();
    }

    pub fn has_volumeFailureSummary(&self) -> bool {
        self.volumeFailureSummary.is_some()
    }

    // Param is passed by value, moved
    pub fn set_volumeFailureSummary(&mut self, v: VolumeFailureSummaryProto) {
        self.volumeFailureSummary = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_volumeFailureSummary(&mut self) -> &mut VolumeFailureSummaryProto {
        if self.volumeFailureSummary.is_none() {
            self.volumeFailureSummary.set_default();
        }
        self.volumeFailureSummary.as_mut().unwrap()
    }

    // Take field
    pub fn take_volumeFailureSummary(&mut self) -> VolumeFailureSummaryProto {
        self.volumeFailureSummary.take().unwrap_or_else(|| VolumeFailureSummaryProto::new())
    }

    // optional bool requestFullBlockReportLease = 9;


    pub fn get_requestFullBlockReportLease(&self) -> bool {
        self.requestFullBlockReportLease.unwrap_or(false)
    }
    pub fn clear_requestFullBlockReportLease(&mut self) {
        self.requestFullBlockReportLease = ::std::option::Option::None;
    }

    pub fn has_requestFullBlockReportLease(&self) -> bool {
        self.requestFullBlockReportLease.is_some()
    }

    // Param is passed by value, moved
    pub fn set_requestFullBlockReportLease(&mut self, v: bool) {
        self.requestFullBlockReportLease = ::std::option::Option::Some(v);
    }

    // repeated .hadoop.hdfs.SlowPeerReportProto slowPeers = 10;


    pub fn get_slowPeers(&self) -> &[SlowPeerReportProto] {
        &self.slowPeers
    }
    pub fn clear_slowPeers(&mut self) {
        self.slowPeers.clear();
    }

    // Param is passed by value, moved
    pub fn set_slowPeers(&mut self, v: ::protobuf::RepeatedField<SlowPeerReportProto>) {
        self.slowPeers = v;
    }

    // Mutable pointer to the field.
    pub fn mut_slowPeers(&mut self) -> &mut ::protobuf::RepeatedField<SlowPeerReportProto> {
        &mut self.slowPeers
    }

    // Take field
    pub fn take_slowPeers(&mut self) -> ::protobuf::RepeatedField<SlowPeerReportProto> {
        ::std::mem::replace(&mut self.slowPeers, ::protobuf::RepeatedField::new())
    }

    // repeated .hadoop.hdfs.SlowDiskReportProto slowDisks = 11;


    pub fn get_slowDisks(&self) -> &[SlowDiskReportProto] {
        &self.slowDisks
    }
    pub fn clear_slowDisks(&mut self) {
        self.slowDisks.clear();
    }

    // Param is passed by value, moved
    pub fn set_slowDisks(&mut self, v: ::protobuf::RepeatedField<SlowDiskReportProto>) {
        self.slowDisks = v;
    }

    // Mutable pointer to the field.
    pub fn mut_slowDisks(&mut self) -> &mut ::protobuf::RepeatedField<SlowDiskReportProto> {
        &mut self.slowDisks
    }

    // Take field
    pub fn take_slowDisks(&mut self) -> ::protobuf::RepeatedField<SlowDiskReportProto> {
        ::std::mem::replace(&mut self.slowDisks, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for HeartbeatRequestProto {
    fn is_initialized(&self) -> bool {
        if self.registration.is_none() {
            return false;
        }
        for v in &self.registration {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.reports {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.volumeFailureSummary {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.slowPeers {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.slowDisks {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.registration)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.reports)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.xmitsInProgress = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.xceiverCount = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.failedVolumes = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.cacheCapacity = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.cacheUsed = ::std::option::Option::Some(tmp);
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.volumeFailureSummary)?;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.requestFullBlockReportLease = ::std::option::Option::Some(tmp);
                },
                10 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.slowPeers)?;
                },
                11 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.slowDisks)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.registration.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.reports {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.xmitsInProgress {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.xceiverCount {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.failedVolumes {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.cacheCapacity {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.cacheUsed {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.volumeFailureSummary.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.requestFullBlockReportLease {
            my_size += 2;
        }
        for value in &self.slowPeers {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.slowDisks {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.registration.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.reports {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.xmitsInProgress {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.xceiverCount {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.failedVolumes {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.cacheCapacity {
            os.write_uint64(6, v)?;
        }
        if let Some(v) = self.cacheUsed {
            os.write_uint64(7, v)?;
        }
        if let Some(ref v) = self.volumeFailureSummary.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.requestFullBlockReportLease {
            os.write_bool(9, v)?;
        }
        for v in &self.slowPeers {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.slowDisks {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> HeartbeatRequestProto {
        HeartbeatRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DatanodeRegistrationProto>>(
                "registration",
                |m: &HeartbeatRequestProto| { &m.registration },
                |m: &mut HeartbeatRequestProto| { &mut m.registration },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::hdfs::StorageReportProto>>(
                "reports",
                |m: &HeartbeatRequestProto| { &m.reports },
                |m: &mut HeartbeatRequestProto| { &mut m.reports },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "xmitsInProgress",
                |m: &HeartbeatRequestProto| { &m.xmitsInProgress },
                |m: &mut HeartbeatRequestProto| { &mut m.xmitsInProgress },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "xceiverCount",
                |m: &HeartbeatRequestProto| { &m.xceiverCount },
                |m: &mut HeartbeatRequestProto| { &mut m.xceiverCount },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "failedVolumes",
                |m: &HeartbeatRequestProto| { &m.failedVolumes },
                |m: &mut HeartbeatRequestProto| { &mut m.failedVolumes },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "cacheCapacity",
                |m: &HeartbeatRequestProto| { &m.cacheCapacity },
                |m: &mut HeartbeatRequestProto| { &mut m.cacheCapacity },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "cacheUsed",
                |m: &HeartbeatRequestProto| { &m.cacheUsed },
                |m: &mut HeartbeatRequestProto| { &mut m.cacheUsed },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<VolumeFailureSummaryProto>>(
                "volumeFailureSummary",
                |m: &HeartbeatRequestProto| { &m.volumeFailureSummary },
                |m: &mut HeartbeatRequestProto| { &mut m.volumeFailureSummary },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "requestFullBlockReportLease",
                |m: &HeartbeatRequestProto| { &m.requestFullBlockReportLease },
                |m: &mut HeartbeatRequestProto| { &mut m.requestFullBlockReportLease },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SlowPeerReportProto>>(
                "slowPeers",
                |m: &HeartbeatRequestProto| { &m.slowPeers },
                |m: &mut HeartbeatRequestProto| { &mut m.slowPeers },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SlowDiskReportProto>>(
                "slowDisks",
                |m: &HeartbeatRequestProto| { &m.slowDisks },
                |m: &mut HeartbeatRequestProto| { &mut m.slowDisks },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<HeartbeatRequestProto>(
                "HeartbeatRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static HeartbeatRequestProto {
        static instance: ::protobuf::rt::LazyV2<HeartbeatRequestProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(HeartbeatRequestProto::new)
    }
}

impl ::protobuf::Clear for HeartbeatRequestProto {
    fn clear(&mut self) {
        self.registration.clear();
        self.reports.clear();
        self.xmitsInProgress = ::std::option::Option::None;
        self.xceiverCount = ::std::option::Option::None;
        self.failedVolumes = ::std::option::Option::None;
        self.cacheCapacity = ::std::option::Option::None;
        self.cacheUsed = ::std::option::Option::None;
        self.volumeFailureSummary.clear();
        self.requestFullBlockReportLease = ::std::option::Option::None;
        self.slowPeers.clear();
        self.slowDisks.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for HeartbeatRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HeartbeatRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct HeartbeatResponseProto {
    // message fields
    pub cmds: ::protobuf::RepeatedField<DatanodeCommandProto>,
    pub haStatus: ::protobuf::SingularPtrField<super::HdfsServer::NNHAStatusHeartbeatProto>,
    pub rollingUpgradeStatus: ::protobuf::SingularPtrField<super::hdfs::RollingUpgradeStatusProto>,
    pub rollingUpgradeStatusV2: ::protobuf::SingularPtrField<super::hdfs::RollingUpgradeStatusProto>,
    fullBlockReportLeaseId: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a HeartbeatResponseProto {
    fn default() -> &'a HeartbeatResponseProto {
        <HeartbeatResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl HeartbeatResponseProto {
    pub fn new() -> HeartbeatResponseProto {
        ::std::default::Default::default()
    }

    // repeated .hadoop.hdfs.DatanodeCommandProto cmds = 1;


    pub fn get_cmds(&self) -> &[DatanodeCommandProto] {
        &self.cmds
    }
    pub fn clear_cmds(&mut self) {
        self.cmds.clear();
    }

    // Param is passed by value, moved
    pub fn set_cmds(&mut self, v: ::protobuf::RepeatedField<DatanodeCommandProto>) {
        self.cmds = v;
    }

    // Mutable pointer to the field.
    pub fn mut_cmds(&mut self) -> &mut ::protobuf::RepeatedField<DatanodeCommandProto> {
        &mut self.cmds
    }

    // Take field
    pub fn take_cmds(&mut self) -> ::protobuf::RepeatedField<DatanodeCommandProto> {
        ::std::mem::replace(&mut self.cmds, ::protobuf::RepeatedField::new())
    }

    // required .hadoop.hdfs.NNHAStatusHeartbeatProto haStatus = 2;


    pub fn get_haStatus(&self) -> &super::HdfsServer::NNHAStatusHeartbeatProto {
        self.haStatus.as_ref().unwrap_or_else(|| <super::HdfsServer::NNHAStatusHeartbeatProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_haStatus(&mut self) {
        self.haStatus.clear();
    }

    pub fn has_haStatus(&self) -> bool {
        self.haStatus.is_some()
    }

    // Param is passed by value, moved
    pub fn set_haStatus(&mut self, v: super::HdfsServer::NNHAStatusHeartbeatProto) {
        self.haStatus = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_haStatus(&mut self) -> &mut super::HdfsServer::NNHAStatusHeartbeatProto {
        if self.haStatus.is_none() {
            self.haStatus.set_default();
        }
        self.haStatus.as_mut().unwrap()
    }

    // Take field
    pub fn take_haStatus(&mut self) -> super::HdfsServer::NNHAStatusHeartbeatProto {
        self.haStatus.take().unwrap_or_else(|| super::HdfsServer::NNHAStatusHeartbeatProto::new())
    }

    // optional .hadoop.hdfs.RollingUpgradeStatusProto rollingUpgradeStatus = 3;


    pub fn get_rollingUpgradeStatus(&self) -> &super::hdfs::RollingUpgradeStatusProto {
        self.rollingUpgradeStatus.as_ref().unwrap_or_else(|| <super::hdfs::RollingUpgradeStatusProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_rollingUpgradeStatus(&mut self) {
        self.rollingUpgradeStatus.clear();
    }

    pub fn has_rollingUpgradeStatus(&self) -> bool {
        self.rollingUpgradeStatus.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rollingUpgradeStatus(&mut self, v: super::hdfs::RollingUpgradeStatusProto) {
        self.rollingUpgradeStatus = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_rollingUpgradeStatus(&mut self) -> &mut super::hdfs::RollingUpgradeStatusProto {
        if self.rollingUpgradeStatus.is_none() {
            self.rollingUpgradeStatus.set_default();
        }
        self.rollingUpgradeStatus.as_mut().unwrap()
    }

    // Take field
    pub fn take_rollingUpgradeStatus(&mut self) -> super::hdfs::RollingUpgradeStatusProto {
        self.rollingUpgradeStatus.take().unwrap_or_else(|| super::hdfs::RollingUpgradeStatusProto::new())
    }

    // optional .hadoop.hdfs.RollingUpgradeStatusProto rollingUpgradeStatusV2 = 4;


    pub fn get_rollingUpgradeStatusV2(&self) -> &super::hdfs::RollingUpgradeStatusProto {
        self.rollingUpgradeStatusV2.as_ref().unwrap_or_else(|| <super::hdfs::RollingUpgradeStatusProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_rollingUpgradeStatusV2(&mut self) {
        self.rollingUpgradeStatusV2.clear();
    }

    pub fn has_rollingUpgradeStatusV2(&self) -> bool {
        self.rollingUpgradeStatusV2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rollingUpgradeStatusV2(&mut self, v: super::hdfs::RollingUpgradeStatusProto) {
        self.rollingUpgradeStatusV2 = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_rollingUpgradeStatusV2(&mut self) -> &mut super::hdfs::RollingUpgradeStatusProto {
        if self.rollingUpgradeStatusV2.is_none() {
            self.rollingUpgradeStatusV2.set_default();
        }
        self.rollingUpgradeStatusV2.as_mut().unwrap()
    }

    // Take field
    pub fn take_rollingUpgradeStatusV2(&mut self) -> super::hdfs::RollingUpgradeStatusProto {
        self.rollingUpgradeStatusV2.take().unwrap_or_else(|| super::hdfs::RollingUpgradeStatusProto::new())
    }

    // optional uint64 fullBlockReportLeaseId = 5;


    pub fn get_fullBlockReportLeaseId(&self) -> u64 {
        self.fullBlockReportLeaseId.unwrap_or(0u64)
    }
    pub fn clear_fullBlockReportLeaseId(&mut self) {
        self.fullBlockReportLeaseId = ::std::option::Option::None;
    }

    pub fn has_fullBlockReportLeaseId(&self) -> bool {
        self.fullBlockReportLeaseId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fullBlockReportLeaseId(&mut self, v: u64) {
        self.fullBlockReportLeaseId = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for HeartbeatResponseProto {
    fn is_initialized(&self) -> bool {
        if self.haStatus.is_none() {
            return false;
        }
        for v in &self.cmds {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.haStatus {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.rollingUpgradeStatus {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.rollingUpgradeStatusV2 {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.cmds)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.haStatus)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.rollingUpgradeStatus)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.rollingUpgradeStatusV2)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.fullBlockReportLeaseId = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.cmds {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.haStatus.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.rollingUpgradeStatus.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.rollingUpgradeStatusV2.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.fullBlockReportLeaseId {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.cmds {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.haStatus.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.rollingUpgradeStatus.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.rollingUpgradeStatusV2.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.fullBlockReportLeaseId {
            os.write_uint64(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> HeartbeatResponseProto {
        HeartbeatResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DatanodeCommandProto>>(
                "cmds",
                |m: &HeartbeatResponseProto| { &m.cmds },
                |m: &mut HeartbeatResponseProto| { &mut m.cmds },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::HdfsServer::NNHAStatusHeartbeatProto>>(
                "haStatus",
                |m: &HeartbeatResponseProto| { &m.haStatus },
                |m: &mut HeartbeatResponseProto| { &mut m.haStatus },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::hdfs::RollingUpgradeStatusProto>>(
                "rollingUpgradeStatus",
                |m: &HeartbeatResponseProto| { &m.rollingUpgradeStatus },
                |m: &mut HeartbeatResponseProto| { &mut m.rollingUpgradeStatus },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::hdfs::RollingUpgradeStatusProto>>(
                "rollingUpgradeStatusV2",
                |m: &HeartbeatResponseProto| { &m.rollingUpgradeStatusV2 },
                |m: &mut HeartbeatResponseProto| { &mut m.rollingUpgradeStatusV2 },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "fullBlockReportLeaseId",
                |m: &HeartbeatResponseProto| { &m.fullBlockReportLeaseId },
                |m: &mut HeartbeatResponseProto| { &mut m.fullBlockReportLeaseId },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<HeartbeatResponseProto>(
                "HeartbeatResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static HeartbeatResponseProto {
        static instance: ::protobuf::rt::LazyV2<HeartbeatResponseProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(HeartbeatResponseProto::new)
    }
}

impl ::protobuf::Clear for HeartbeatResponseProto {
    fn clear(&mut self) {
        self.cmds.clear();
        self.haStatus.clear();
        self.rollingUpgradeStatus.clear();
        self.rollingUpgradeStatusV2.clear();
        self.fullBlockReportLeaseId = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for HeartbeatResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HeartbeatResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BlockReportRequestProto {
    // message fields
    pub registration: ::protobuf::SingularPtrField<DatanodeRegistrationProto>,
    blockPoolId: ::protobuf::SingularField<::std::string::String>,
    pub reports: ::protobuf::RepeatedField<StorageBlockReportProto>,
    pub context: ::protobuf::SingularPtrField<BlockReportContextProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BlockReportRequestProto {
    fn default() -> &'a BlockReportRequestProto {
        <BlockReportRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl BlockReportRequestProto {
    pub fn new() -> BlockReportRequestProto {
        ::std::default::Default::default()
    }

    // required .hadoop.hdfs.DatanodeRegistrationProto registration = 1;


    pub fn get_registration(&self) -> &DatanodeRegistrationProto {
        self.registration.as_ref().unwrap_or_else(|| <DatanodeRegistrationProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_registration(&mut self) {
        self.registration.clear();
    }

    pub fn has_registration(&self) -> bool {
        self.registration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_registration(&mut self, v: DatanodeRegistrationProto) {
        self.registration = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_registration(&mut self) -> &mut DatanodeRegistrationProto {
        if self.registration.is_none() {
            self.registration.set_default();
        }
        self.registration.as_mut().unwrap()
    }

    // Take field
    pub fn take_registration(&mut self) -> DatanodeRegistrationProto {
        self.registration.take().unwrap_or_else(|| DatanodeRegistrationProto::new())
    }

    // required string blockPoolId = 2;


    pub fn get_blockPoolId(&self) -> &str {
        match self.blockPoolId.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_blockPoolId(&mut self) {
        self.blockPoolId.clear();
    }

    pub fn has_blockPoolId(&self) -> bool {
        self.blockPoolId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_blockPoolId(&mut self, v: ::std::string::String) {
        self.blockPoolId = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_blockPoolId(&mut self) -> &mut ::std::string::String {
        if self.blockPoolId.is_none() {
            self.blockPoolId.set_default();
        }
        self.blockPoolId.as_mut().unwrap()
    }

    // Take field
    pub fn take_blockPoolId(&mut self) -> ::std::string::String {
        self.blockPoolId.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated .hadoop.hdfs.StorageBlockReportProto reports = 3;


    pub fn get_reports(&self) -> &[StorageBlockReportProto] {
        &self.reports
    }
    pub fn clear_reports(&mut self) {
        self.reports.clear();
    }

    // Param is passed by value, moved
    pub fn set_reports(&mut self, v: ::protobuf::RepeatedField<StorageBlockReportProto>) {
        self.reports = v;
    }

    // Mutable pointer to the field.
    pub fn mut_reports(&mut self) -> &mut ::protobuf::RepeatedField<StorageBlockReportProto> {
        &mut self.reports
    }

    // Take field
    pub fn take_reports(&mut self) -> ::protobuf::RepeatedField<StorageBlockReportProto> {
        ::std::mem::replace(&mut self.reports, ::protobuf::RepeatedField::new())
    }

    // optional .hadoop.hdfs.BlockReportContextProto context = 4;


    pub fn get_context(&self) -> &BlockReportContextProto {
        self.context.as_ref().unwrap_or_else(|| <BlockReportContextProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_context(&mut self) {
        self.context.clear();
    }

    pub fn has_context(&self) -> bool {
        self.context.is_some()
    }

    // Param is passed by value, moved
    pub fn set_context(&mut self, v: BlockReportContextProto) {
        self.context = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_context(&mut self) -> &mut BlockReportContextProto {
        if self.context.is_none() {
            self.context.set_default();
        }
        self.context.as_mut().unwrap()
    }

    // Take field
    pub fn take_context(&mut self) -> BlockReportContextProto {
        self.context.take().unwrap_or_else(|| BlockReportContextProto::new())
    }
}

impl ::protobuf::Message for BlockReportRequestProto {
    fn is_initialized(&self) -> bool {
        if self.registration.is_none() {
            return false;
        }
        if self.blockPoolId.is_none() {
            return false;
        }
        for v in &self.registration {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.reports {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.context {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.registration)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.blockPoolId)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.reports)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.context)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.registration.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.blockPoolId.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        for value in &self.reports {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.context.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.registration.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.blockPoolId.as_ref() {
            os.write_string(2, &v)?;
        }
        for v in &self.reports {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.context.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BlockReportRequestProto {
        BlockReportRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DatanodeRegistrationProto>>(
                "registration",
                |m: &BlockReportRequestProto| { &m.registration },
                |m: &mut BlockReportRequestProto| { &mut m.registration },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "blockPoolId",
                |m: &BlockReportRequestProto| { &m.blockPoolId },
                |m: &mut BlockReportRequestProto| { &mut m.blockPoolId },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<StorageBlockReportProto>>(
                "reports",
                |m: &BlockReportRequestProto| { &m.reports },
                |m: &mut BlockReportRequestProto| { &mut m.reports },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BlockReportContextProto>>(
                "context",
                |m: &BlockReportRequestProto| { &m.context },
                |m: &mut BlockReportRequestProto| { &mut m.context },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BlockReportRequestProto>(
                "BlockReportRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BlockReportRequestProto {
        static instance: ::protobuf::rt::LazyV2<BlockReportRequestProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BlockReportRequestProto::new)
    }
}

impl ::protobuf::Clear for BlockReportRequestProto {
    fn clear(&mut self) {
        self.registration.clear();
        self.blockPoolId.clear();
        self.reports.clear();
        self.context.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BlockReportRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BlockReportRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BlockReportContextProto {
    // message fields
    totalRpcs: ::std::option::Option<i32>,
    curRpc: ::std::option::Option<i32>,
    id: ::std::option::Option<i64>,
    leaseId: ::std::option::Option<u64>,
    sorted: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BlockReportContextProto {
    fn default() -> &'a BlockReportContextProto {
        <BlockReportContextProto as ::protobuf::Message>::default_instance()
    }
}

impl BlockReportContextProto {
    pub fn new() -> BlockReportContextProto {
        ::std::default::Default::default()
    }

    // required int32 totalRpcs = 1;


    pub fn get_totalRpcs(&self) -> i32 {
        self.totalRpcs.unwrap_or(0)
    }
    pub fn clear_totalRpcs(&mut self) {
        self.totalRpcs = ::std::option::Option::None;
    }

    pub fn has_totalRpcs(&self) -> bool {
        self.totalRpcs.is_some()
    }

    // Param is passed by value, moved
    pub fn set_totalRpcs(&mut self, v: i32) {
        self.totalRpcs = ::std::option::Option::Some(v);
    }

    // required int32 curRpc = 2;


    pub fn get_curRpc(&self) -> i32 {
        self.curRpc.unwrap_or(0)
    }
    pub fn clear_curRpc(&mut self) {
        self.curRpc = ::std::option::Option::None;
    }

    pub fn has_curRpc(&self) -> bool {
        self.curRpc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_curRpc(&mut self, v: i32) {
        self.curRpc = ::std::option::Option::Some(v);
    }

    // required int64 id = 3;


    pub fn get_id(&self) -> i64 {
        self.id.unwrap_or(0)
    }
    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: i64) {
        self.id = ::std::option::Option::Some(v);
    }

    // optional uint64 leaseId = 4;


    pub fn get_leaseId(&self) -> u64 {
        self.leaseId.unwrap_or(0u64)
    }
    pub fn clear_leaseId(&mut self) {
        self.leaseId = ::std::option::Option::None;
    }

    pub fn has_leaseId(&self) -> bool {
        self.leaseId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_leaseId(&mut self, v: u64) {
        self.leaseId = ::std::option::Option::Some(v);
    }

    // optional bool sorted = 5;


    pub fn get_sorted(&self) -> bool {
        self.sorted.unwrap_or(false)
    }
    pub fn clear_sorted(&mut self) {
        self.sorted = ::std::option::Option::None;
    }

    pub fn has_sorted(&self) -> bool {
        self.sorted.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sorted(&mut self, v: bool) {
        self.sorted = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for BlockReportContextProto {
    fn is_initialized(&self) -> bool {
        if self.totalRpcs.is_none() {
            return false;
        }
        if self.curRpc.is_none() {
            return false;
        }
        if self.id.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.totalRpcs = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.curRpc = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.id = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.leaseId = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.sorted = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.totalRpcs {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.curRpc {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.id {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.leaseId {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.sorted {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.totalRpcs {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.curRpc {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.id {
            os.write_int64(3, v)?;
        }
        if let Some(v) = self.leaseId {
            os.write_uint64(4, v)?;
        }
        if let Some(v) = self.sorted {
            os.write_bool(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BlockReportContextProto {
        BlockReportContextProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "totalRpcs",
                |m: &BlockReportContextProto| { &m.totalRpcs },
                |m: &mut BlockReportContextProto| { &mut m.totalRpcs },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "curRpc",
                |m: &BlockReportContextProto| { &m.curRpc },
                |m: &mut BlockReportContextProto| { &mut m.curRpc },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "id",
                |m: &BlockReportContextProto| { &m.id },
                |m: &mut BlockReportContextProto| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "leaseId",
                |m: &BlockReportContextProto| { &m.leaseId },
                |m: &mut BlockReportContextProto| { &mut m.leaseId },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "sorted",
                |m: &BlockReportContextProto| { &m.sorted },
                |m: &mut BlockReportContextProto| { &mut m.sorted },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BlockReportContextProto>(
                "BlockReportContextProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BlockReportContextProto {
        static instance: ::protobuf::rt::LazyV2<BlockReportContextProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BlockReportContextProto::new)
    }
}

impl ::protobuf::Clear for BlockReportContextProto {
    fn clear(&mut self) {
        self.totalRpcs = ::std::option::Option::None;
        self.curRpc = ::std::option::Option::None;
        self.id = ::std::option::Option::None;
        self.leaseId = ::std::option::Option::None;
        self.sorted = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BlockReportContextProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BlockReportContextProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StorageBlockReportProto {
    // message fields
    pub storage: ::protobuf::SingularPtrField<super::hdfs::DatanodeStorageProto>,
    pub blocks: ::std::vec::Vec<u64>,
    numberOfBlocks: ::std::option::Option<u64>,
    pub blocksBuffers: ::protobuf::RepeatedField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StorageBlockReportProto {
    fn default() -> &'a StorageBlockReportProto {
        <StorageBlockReportProto as ::protobuf::Message>::default_instance()
    }
}

impl StorageBlockReportProto {
    pub fn new() -> StorageBlockReportProto {
        ::std::default::Default::default()
    }

    // required .hadoop.hdfs.DatanodeStorageProto storage = 1;


    pub fn get_storage(&self) -> &super::hdfs::DatanodeStorageProto {
        self.storage.as_ref().unwrap_or_else(|| <super::hdfs::DatanodeStorageProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_storage(&mut self) {
        self.storage.clear();
    }

    pub fn has_storage(&self) -> bool {
        self.storage.is_some()
    }

    // Param is passed by value, moved
    pub fn set_storage(&mut self, v: super::hdfs::DatanodeStorageProto) {
        self.storage = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_storage(&mut self) -> &mut super::hdfs::DatanodeStorageProto {
        if self.storage.is_none() {
            self.storage.set_default();
        }
        self.storage.as_mut().unwrap()
    }

    // Take field
    pub fn take_storage(&mut self) -> super::hdfs::DatanodeStorageProto {
        self.storage.take().unwrap_or_else(|| super::hdfs::DatanodeStorageProto::new())
    }

    // repeated uint64 blocks = 2;


    pub fn get_blocks(&self) -> &[u64] {
        &self.blocks
    }
    pub fn clear_blocks(&mut self) {
        self.blocks.clear();
    }

    // Param is passed by value, moved
    pub fn set_blocks(&mut self, v: ::std::vec::Vec<u64>) {
        self.blocks = v;
    }

    // Mutable pointer to the field.
    pub fn mut_blocks(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.blocks
    }

    // Take field
    pub fn take_blocks(&mut self) -> ::std::vec::Vec<u64> {
        ::std::mem::replace(&mut self.blocks, ::std::vec::Vec::new())
    }

    // optional uint64 numberOfBlocks = 3;


    pub fn get_numberOfBlocks(&self) -> u64 {
        self.numberOfBlocks.unwrap_or(0)
    }
    pub fn clear_numberOfBlocks(&mut self) {
        self.numberOfBlocks = ::std::option::Option::None;
    }

    pub fn has_numberOfBlocks(&self) -> bool {
        self.numberOfBlocks.is_some()
    }

    // Param is passed by value, moved
    pub fn set_numberOfBlocks(&mut self, v: u64) {
        self.numberOfBlocks = ::std::option::Option::Some(v);
    }

    // repeated bytes blocksBuffers = 4;


    pub fn get_blocksBuffers(&self) -> &[::std::vec::Vec<u8>] {
        &self.blocksBuffers
    }
    pub fn clear_blocksBuffers(&mut self) {
        self.blocksBuffers.clear();
    }

    // Param is passed by value, moved
    pub fn set_blocksBuffers(&mut self, v: ::protobuf::RepeatedField<::std::vec::Vec<u8>>) {
        self.blocksBuffers = v;
    }

    // Mutable pointer to the field.
    pub fn mut_blocksBuffers(&mut self) -> &mut ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        &mut self.blocksBuffers
    }

    // Take field
    pub fn take_blocksBuffers(&mut self) -> ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        ::std::mem::replace(&mut self.blocksBuffers, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for StorageBlockReportProto {
    fn is_initialized(&self) -> bool {
        if self.storage.is_none() {
            return false;
        }
        for v in &self.storage {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.storage)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_uint64_into(wire_type, is, &mut self.blocks)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.numberOfBlocks = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_repeated_bytes_into(wire_type, is, &mut self.blocksBuffers)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.storage.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.blocks.is_empty() {
            my_size += ::protobuf::rt::vec_packed_varint_size(2, &self.blocks);
        }
        if let Some(v) = self.numberOfBlocks {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.blocksBuffers {
            my_size += ::protobuf::rt::bytes_size(4, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.storage.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.blocks.is_empty() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            // TODO: Data size is computed again, it should be cached
            os.write_raw_varint32(::protobuf::rt::vec_packed_varint_data_size(&self.blocks))?;
            for v in &self.blocks {
                os.write_uint64_no_tag(*v)?;
            };
        }
        if let Some(v) = self.numberOfBlocks {
            os.write_uint64(3, v)?;
        }
        for v in &self.blocksBuffers {
            os.write_bytes(4, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StorageBlockReportProto {
        StorageBlockReportProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::hdfs::DatanodeStorageProto>>(
                "storage",
                |m: &StorageBlockReportProto| { &m.storage },
                |m: &mut StorageBlockReportProto| { &mut m.storage },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "blocks",
                |m: &StorageBlockReportProto| { &m.blocks },
                |m: &mut StorageBlockReportProto| { &mut m.blocks },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "numberOfBlocks",
                |m: &StorageBlockReportProto| { &m.numberOfBlocks },
                |m: &mut StorageBlockReportProto| { &mut m.numberOfBlocks },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "blocksBuffers",
                |m: &StorageBlockReportProto| { &m.blocksBuffers },
                |m: &mut StorageBlockReportProto| { &mut m.blocksBuffers },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<StorageBlockReportProto>(
                "StorageBlockReportProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static StorageBlockReportProto {
        static instance: ::protobuf::rt::LazyV2<StorageBlockReportProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(StorageBlockReportProto::new)
    }
}

impl ::protobuf::Clear for StorageBlockReportProto {
    fn clear(&mut self) {
        self.storage.clear();
        self.blocks.clear();
        self.numberOfBlocks = ::std::option::Option::None;
        self.blocksBuffers.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StorageBlockReportProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StorageBlockReportProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BlockReportResponseProto {
    // message fields
    pub cmd: ::protobuf::SingularPtrField<DatanodeCommandProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BlockReportResponseProto {
    fn default() -> &'a BlockReportResponseProto {
        <BlockReportResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl BlockReportResponseProto {
    pub fn new() -> BlockReportResponseProto {
        ::std::default::Default::default()
    }

    // optional .hadoop.hdfs.DatanodeCommandProto cmd = 1;


    pub fn get_cmd(&self) -> &DatanodeCommandProto {
        self.cmd.as_ref().unwrap_or_else(|| <DatanodeCommandProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_cmd(&mut self) {
        self.cmd.clear();
    }

    pub fn has_cmd(&self) -> bool {
        self.cmd.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cmd(&mut self, v: DatanodeCommandProto) {
        self.cmd = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cmd(&mut self) -> &mut DatanodeCommandProto {
        if self.cmd.is_none() {
            self.cmd.set_default();
        }
        self.cmd.as_mut().unwrap()
    }

    // Take field
    pub fn take_cmd(&mut self) -> DatanodeCommandProto {
        self.cmd.take().unwrap_or_else(|| DatanodeCommandProto::new())
    }
}

impl ::protobuf::Message for BlockReportResponseProto {
    fn is_initialized(&self) -> bool {
        for v in &self.cmd {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.cmd)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.cmd.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.cmd.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BlockReportResponseProto {
        BlockReportResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DatanodeCommandProto>>(
                "cmd",
                |m: &BlockReportResponseProto| { &m.cmd },
                |m: &mut BlockReportResponseProto| { &mut m.cmd },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BlockReportResponseProto>(
                "BlockReportResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BlockReportResponseProto {
        static instance: ::protobuf::rt::LazyV2<BlockReportResponseProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BlockReportResponseProto::new)
    }
}

impl ::protobuf::Clear for BlockReportResponseProto {
    fn clear(&mut self) {
        self.cmd.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BlockReportResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BlockReportResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CacheReportRequestProto {
    // message fields
    pub registration: ::protobuf::SingularPtrField<DatanodeRegistrationProto>,
    blockPoolId: ::protobuf::SingularField<::std::string::String>,
    pub blocks: ::std::vec::Vec<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CacheReportRequestProto {
    fn default() -> &'a CacheReportRequestProto {
        <CacheReportRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl CacheReportRequestProto {
    pub fn new() -> CacheReportRequestProto {
        ::std::default::Default::default()
    }

    // required .hadoop.hdfs.DatanodeRegistrationProto registration = 1;


    pub fn get_registration(&self) -> &DatanodeRegistrationProto {
        self.registration.as_ref().unwrap_or_else(|| <DatanodeRegistrationProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_registration(&mut self) {
        self.registration.clear();
    }

    pub fn has_registration(&self) -> bool {
        self.registration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_registration(&mut self, v: DatanodeRegistrationProto) {
        self.registration = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_registration(&mut self) -> &mut DatanodeRegistrationProto {
        if self.registration.is_none() {
            self.registration.set_default();
        }
        self.registration.as_mut().unwrap()
    }

    // Take field
    pub fn take_registration(&mut self) -> DatanodeRegistrationProto {
        self.registration.take().unwrap_or_else(|| DatanodeRegistrationProto::new())
    }

    // required string blockPoolId = 2;


    pub fn get_blockPoolId(&self) -> &str {
        match self.blockPoolId.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_blockPoolId(&mut self) {
        self.blockPoolId.clear();
    }

    pub fn has_blockPoolId(&self) -> bool {
        self.blockPoolId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_blockPoolId(&mut self, v: ::std::string::String) {
        self.blockPoolId = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_blockPoolId(&mut self) -> &mut ::std::string::String {
        if self.blockPoolId.is_none() {
            self.blockPoolId.set_default();
        }
        self.blockPoolId.as_mut().unwrap()
    }

    // Take field
    pub fn take_blockPoolId(&mut self) -> ::std::string::String {
        self.blockPoolId.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated uint64 blocks = 3;


    pub fn get_blocks(&self) -> &[u64] {
        &self.blocks
    }
    pub fn clear_blocks(&mut self) {
        self.blocks.clear();
    }

    // Param is passed by value, moved
    pub fn set_blocks(&mut self, v: ::std::vec::Vec<u64>) {
        self.blocks = v;
    }

    // Mutable pointer to the field.
    pub fn mut_blocks(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.blocks
    }

    // Take field
    pub fn take_blocks(&mut self) -> ::std::vec::Vec<u64> {
        ::std::mem::replace(&mut self.blocks, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CacheReportRequestProto {
    fn is_initialized(&self) -> bool {
        if self.registration.is_none() {
            return false;
        }
        if self.blockPoolId.is_none() {
            return false;
        }
        for v in &self.registration {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.registration)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.blockPoolId)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_uint64_into(wire_type, is, &mut self.blocks)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.registration.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.blockPoolId.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if !self.blocks.is_empty() {
            my_size += ::protobuf::rt::vec_packed_varint_size(3, &self.blocks);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.registration.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.blockPoolId.as_ref() {
            os.write_string(2, &v)?;
        }
        if !self.blocks.is_empty() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            // TODO: Data size is computed again, it should be cached
            os.write_raw_varint32(::protobuf::rt::vec_packed_varint_data_size(&self.blocks))?;
            for v in &self.blocks {
                os.write_uint64_no_tag(*v)?;
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CacheReportRequestProto {
        CacheReportRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DatanodeRegistrationProto>>(
                "registration",
                |m: &CacheReportRequestProto| { &m.registration },
                |m: &mut CacheReportRequestProto| { &mut m.registration },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "blockPoolId",
                |m: &CacheReportRequestProto| { &m.blockPoolId },
                |m: &mut CacheReportRequestProto| { &mut m.blockPoolId },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "blocks",
                |m: &CacheReportRequestProto| { &m.blocks },
                |m: &mut CacheReportRequestProto| { &mut m.blocks },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CacheReportRequestProto>(
                "CacheReportRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CacheReportRequestProto {
        static instance: ::protobuf::rt::LazyV2<CacheReportRequestProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CacheReportRequestProto::new)
    }
}

impl ::protobuf::Clear for CacheReportRequestProto {
    fn clear(&mut self) {
        self.registration.clear();
        self.blockPoolId.clear();
        self.blocks.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CacheReportRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CacheReportRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CacheReportResponseProto {
    // message fields
    pub cmd: ::protobuf::SingularPtrField<DatanodeCommandProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CacheReportResponseProto {
    fn default() -> &'a CacheReportResponseProto {
        <CacheReportResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl CacheReportResponseProto {
    pub fn new() -> CacheReportResponseProto {
        ::std::default::Default::default()
    }

    // optional .hadoop.hdfs.DatanodeCommandProto cmd = 1;


    pub fn get_cmd(&self) -> &DatanodeCommandProto {
        self.cmd.as_ref().unwrap_or_else(|| <DatanodeCommandProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_cmd(&mut self) {
        self.cmd.clear();
    }

    pub fn has_cmd(&self) -> bool {
        self.cmd.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cmd(&mut self, v: DatanodeCommandProto) {
        self.cmd = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cmd(&mut self) -> &mut DatanodeCommandProto {
        if self.cmd.is_none() {
            self.cmd.set_default();
        }
        self.cmd.as_mut().unwrap()
    }

    // Take field
    pub fn take_cmd(&mut self) -> DatanodeCommandProto {
        self.cmd.take().unwrap_or_else(|| DatanodeCommandProto::new())
    }
}

impl ::protobuf::Message for CacheReportResponseProto {
    fn is_initialized(&self) -> bool {
        for v in &self.cmd {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.cmd)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.cmd.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.cmd.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CacheReportResponseProto {
        CacheReportResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DatanodeCommandProto>>(
                "cmd",
                |m: &CacheReportResponseProto| { &m.cmd },
                |m: &mut CacheReportResponseProto| { &mut m.cmd },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CacheReportResponseProto>(
                "CacheReportResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CacheReportResponseProto {
        static instance: ::protobuf::rt::LazyV2<CacheReportResponseProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CacheReportResponseProto::new)
    }
}

impl ::protobuf::Clear for CacheReportResponseProto {
    fn clear(&mut self) {
        self.cmd.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CacheReportResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CacheReportResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ReceivedDeletedBlockInfoProto {
    // message fields
    pub block: ::protobuf::SingularPtrField<super::hdfs::BlockProto>,
    status: ::std::option::Option<ReceivedDeletedBlockInfoProto_BlockStatus>,
    deleteHint: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ReceivedDeletedBlockInfoProto {
    fn default() -> &'a ReceivedDeletedBlockInfoProto {
        <ReceivedDeletedBlockInfoProto as ::protobuf::Message>::default_instance()
    }
}

impl ReceivedDeletedBlockInfoProto {
    pub fn new() -> ReceivedDeletedBlockInfoProto {
        ::std::default::Default::default()
    }

    // required .hadoop.hdfs.BlockProto block = 1;


    pub fn get_block(&self) -> &super::hdfs::BlockProto {
        self.block.as_ref().unwrap_or_else(|| <super::hdfs::BlockProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_block(&mut self) {
        self.block.clear();
    }

    pub fn has_block(&self) -> bool {
        self.block.is_some()
    }

    // Param is passed by value, moved
    pub fn set_block(&mut self, v: super::hdfs::BlockProto) {
        self.block = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_block(&mut self) -> &mut super::hdfs::BlockProto {
        if self.block.is_none() {
            self.block.set_default();
        }
        self.block.as_mut().unwrap()
    }

    // Take field
    pub fn take_block(&mut self) -> super::hdfs::BlockProto {
        self.block.take().unwrap_or_else(|| super::hdfs::BlockProto::new())
    }

    // required .hadoop.hdfs.ReceivedDeletedBlockInfoProto.BlockStatus status = 3;


    pub fn get_status(&self) -> ReceivedDeletedBlockInfoProto_BlockStatus {
        self.status.unwrap_or(ReceivedDeletedBlockInfoProto_BlockStatus::RECEIVING)
    }
    pub fn clear_status(&mut self) {
        self.status = ::std::option::Option::None;
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: ReceivedDeletedBlockInfoProto_BlockStatus) {
        self.status = ::std::option::Option::Some(v);
    }

    // optional string deleteHint = 2;


    pub fn get_deleteHint(&self) -> &str {
        match self.deleteHint.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_deleteHint(&mut self) {
        self.deleteHint.clear();
    }

    pub fn has_deleteHint(&self) -> bool {
        self.deleteHint.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deleteHint(&mut self, v: ::std::string::String) {
        self.deleteHint = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_deleteHint(&mut self) -> &mut ::std::string::String {
        if self.deleteHint.is_none() {
            self.deleteHint.set_default();
        }
        self.deleteHint.as_mut().unwrap()
    }

    // Take field
    pub fn take_deleteHint(&mut self) -> ::std::string::String {
        self.deleteHint.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for ReceivedDeletedBlockInfoProto {
    fn is_initialized(&self) -> bool {
        if self.block.is_none() {
            return false;
        }
        if self.status.is_none() {
            return false;
        }
        for v in &self.block {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.block)?;
                },
                3 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.status, 3, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.deleteHint)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.block.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.status {
            my_size += ::protobuf::rt::enum_size(3, v);
        }
        if let Some(ref v) = self.deleteHint.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.block.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.status {
            os.write_enum(3, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(ref v) = self.deleteHint.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ReceivedDeletedBlockInfoProto {
        ReceivedDeletedBlockInfoProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::hdfs::BlockProto>>(
                "block",
                |m: &ReceivedDeletedBlockInfoProto| { &m.block },
                |m: &mut ReceivedDeletedBlockInfoProto| { &mut m.block },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ReceivedDeletedBlockInfoProto_BlockStatus>>(
                "status",
                |m: &ReceivedDeletedBlockInfoProto| { &m.status },
                |m: &mut ReceivedDeletedBlockInfoProto| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "deleteHint",
                |m: &ReceivedDeletedBlockInfoProto| { &m.deleteHint },
                |m: &mut ReceivedDeletedBlockInfoProto| { &mut m.deleteHint },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ReceivedDeletedBlockInfoProto>(
                "ReceivedDeletedBlockInfoProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ReceivedDeletedBlockInfoProto {
        static instance: ::protobuf::rt::LazyV2<ReceivedDeletedBlockInfoProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ReceivedDeletedBlockInfoProto::new)
    }
}

impl ::protobuf::Clear for ReceivedDeletedBlockInfoProto {
    fn clear(&mut self) {
        self.block.clear();
        self.status = ::std::option::Option::None;
        self.deleteHint.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ReceivedDeletedBlockInfoProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReceivedDeletedBlockInfoProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ReceivedDeletedBlockInfoProto_BlockStatus {
    RECEIVING = 1,
    RECEIVED = 2,
    DELETED = 3,
}

impl ::protobuf::ProtobufEnum for ReceivedDeletedBlockInfoProto_BlockStatus {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ReceivedDeletedBlockInfoProto_BlockStatus> {
        match value {
            1 => ::std::option::Option::Some(ReceivedDeletedBlockInfoProto_BlockStatus::RECEIVING),
            2 => ::std::option::Option::Some(ReceivedDeletedBlockInfoProto_BlockStatus::RECEIVED),
            3 => ::std::option::Option::Some(ReceivedDeletedBlockInfoProto_BlockStatus::DELETED),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ReceivedDeletedBlockInfoProto_BlockStatus] = &[
            ReceivedDeletedBlockInfoProto_BlockStatus::RECEIVING,
            ReceivedDeletedBlockInfoProto_BlockStatus::RECEIVED,
            ReceivedDeletedBlockInfoProto_BlockStatus::DELETED,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<ReceivedDeletedBlockInfoProto_BlockStatus>("ReceivedDeletedBlockInfoProto.BlockStatus", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for ReceivedDeletedBlockInfoProto_BlockStatus {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for ReceivedDeletedBlockInfoProto_BlockStatus {
    fn default() -> Self {
        ReceivedDeletedBlockInfoProto_BlockStatus::RECEIVING
    }
}

impl ::protobuf::reflect::ProtobufValue for ReceivedDeletedBlockInfoProto_BlockStatus {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StorageReceivedDeletedBlocksProto {
    // message fields
    storageUuid: ::protobuf::SingularField<::std::string::String>,
    pub blocks: ::protobuf::RepeatedField<ReceivedDeletedBlockInfoProto>,
    pub storage: ::protobuf::SingularPtrField<super::hdfs::DatanodeStorageProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StorageReceivedDeletedBlocksProto {
    fn default() -> &'a StorageReceivedDeletedBlocksProto {
        <StorageReceivedDeletedBlocksProto as ::protobuf::Message>::default_instance()
    }
}

impl StorageReceivedDeletedBlocksProto {
    pub fn new() -> StorageReceivedDeletedBlocksProto {
        ::std::default::Default::default()
    }

    // required string storageUuid = 1;


    pub fn get_storageUuid(&self) -> &str {
        match self.storageUuid.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_storageUuid(&mut self) {
        self.storageUuid.clear();
    }

    pub fn has_storageUuid(&self) -> bool {
        self.storageUuid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_storageUuid(&mut self, v: ::std::string::String) {
        self.storageUuid = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_storageUuid(&mut self) -> &mut ::std::string::String {
        if self.storageUuid.is_none() {
            self.storageUuid.set_default();
        }
        self.storageUuid.as_mut().unwrap()
    }

    // Take field
    pub fn take_storageUuid(&mut self) -> ::std::string::String {
        self.storageUuid.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated .hadoop.hdfs.ReceivedDeletedBlockInfoProto blocks = 2;


    pub fn get_blocks(&self) -> &[ReceivedDeletedBlockInfoProto] {
        &self.blocks
    }
    pub fn clear_blocks(&mut self) {
        self.blocks.clear();
    }

    // Param is passed by value, moved
    pub fn set_blocks(&mut self, v: ::protobuf::RepeatedField<ReceivedDeletedBlockInfoProto>) {
        self.blocks = v;
    }

    // Mutable pointer to the field.
    pub fn mut_blocks(&mut self) -> &mut ::protobuf::RepeatedField<ReceivedDeletedBlockInfoProto> {
        &mut self.blocks
    }

    // Take field
    pub fn take_blocks(&mut self) -> ::protobuf::RepeatedField<ReceivedDeletedBlockInfoProto> {
        ::std::mem::replace(&mut self.blocks, ::protobuf::RepeatedField::new())
    }

    // optional .hadoop.hdfs.DatanodeStorageProto storage = 3;


    pub fn get_storage(&self) -> &super::hdfs::DatanodeStorageProto {
        self.storage.as_ref().unwrap_or_else(|| <super::hdfs::DatanodeStorageProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_storage(&mut self) {
        self.storage.clear();
    }

    pub fn has_storage(&self) -> bool {
        self.storage.is_some()
    }

    // Param is passed by value, moved
    pub fn set_storage(&mut self, v: super::hdfs::DatanodeStorageProto) {
        self.storage = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_storage(&mut self) -> &mut super::hdfs::DatanodeStorageProto {
        if self.storage.is_none() {
            self.storage.set_default();
        }
        self.storage.as_mut().unwrap()
    }

    // Take field
    pub fn take_storage(&mut self) -> super::hdfs::DatanodeStorageProto {
        self.storage.take().unwrap_or_else(|| super::hdfs::DatanodeStorageProto::new())
    }
}

impl ::protobuf::Message for StorageReceivedDeletedBlocksProto {
    fn is_initialized(&self) -> bool {
        if self.storageUuid.is_none() {
            return false;
        }
        for v in &self.blocks {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.storage {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.storageUuid)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.blocks)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.storage)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.storageUuid.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        for value in &self.blocks {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.storage.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.storageUuid.as_ref() {
            os.write_string(1, &v)?;
        }
        for v in &self.blocks {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.storage.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StorageReceivedDeletedBlocksProto {
        StorageReceivedDeletedBlocksProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "storageUuid",
                |m: &StorageReceivedDeletedBlocksProto| { &m.storageUuid },
                |m: &mut StorageReceivedDeletedBlocksProto| { &mut m.storageUuid },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ReceivedDeletedBlockInfoProto>>(
                "blocks",
                |m: &StorageReceivedDeletedBlocksProto| { &m.blocks },
                |m: &mut StorageReceivedDeletedBlocksProto| { &mut m.blocks },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::hdfs::DatanodeStorageProto>>(
                "storage",
                |m: &StorageReceivedDeletedBlocksProto| { &m.storage },
                |m: &mut StorageReceivedDeletedBlocksProto| { &mut m.storage },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<StorageReceivedDeletedBlocksProto>(
                "StorageReceivedDeletedBlocksProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static StorageReceivedDeletedBlocksProto {
        static instance: ::protobuf::rt::LazyV2<StorageReceivedDeletedBlocksProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(StorageReceivedDeletedBlocksProto::new)
    }
}

impl ::protobuf::Clear for StorageReceivedDeletedBlocksProto {
    fn clear(&mut self) {
        self.storageUuid.clear();
        self.blocks.clear();
        self.storage.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StorageReceivedDeletedBlocksProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StorageReceivedDeletedBlocksProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BlockReceivedAndDeletedRequestProto {
    // message fields
    pub registration: ::protobuf::SingularPtrField<DatanodeRegistrationProto>,
    blockPoolId: ::protobuf::SingularField<::std::string::String>,
    pub blocks: ::protobuf::RepeatedField<StorageReceivedDeletedBlocksProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BlockReceivedAndDeletedRequestProto {
    fn default() -> &'a BlockReceivedAndDeletedRequestProto {
        <BlockReceivedAndDeletedRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl BlockReceivedAndDeletedRequestProto {
    pub fn new() -> BlockReceivedAndDeletedRequestProto {
        ::std::default::Default::default()
    }

    // required .hadoop.hdfs.DatanodeRegistrationProto registration = 1;


    pub fn get_registration(&self) -> &DatanodeRegistrationProto {
        self.registration.as_ref().unwrap_or_else(|| <DatanodeRegistrationProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_registration(&mut self) {
        self.registration.clear();
    }

    pub fn has_registration(&self) -> bool {
        self.registration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_registration(&mut self, v: DatanodeRegistrationProto) {
        self.registration = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_registration(&mut self) -> &mut DatanodeRegistrationProto {
        if self.registration.is_none() {
            self.registration.set_default();
        }
        self.registration.as_mut().unwrap()
    }

    // Take field
    pub fn take_registration(&mut self) -> DatanodeRegistrationProto {
        self.registration.take().unwrap_or_else(|| DatanodeRegistrationProto::new())
    }

    // required string blockPoolId = 2;


    pub fn get_blockPoolId(&self) -> &str {
        match self.blockPoolId.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_blockPoolId(&mut self) {
        self.blockPoolId.clear();
    }

    pub fn has_blockPoolId(&self) -> bool {
        self.blockPoolId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_blockPoolId(&mut self, v: ::std::string::String) {
        self.blockPoolId = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_blockPoolId(&mut self) -> &mut ::std::string::String {
        if self.blockPoolId.is_none() {
            self.blockPoolId.set_default();
        }
        self.blockPoolId.as_mut().unwrap()
    }

    // Take field
    pub fn take_blockPoolId(&mut self) -> ::std::string::String {
        self.blockPoolId.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated .hadoop.hdfs.StorageReceivedDeletedBlocksProto blocks = 3;


    pub fn get_blocks(&self) -> &[StorageReceivedDeletedBlocksProto] {
        &self.blocks
    }
    pub fn clear_blocks(&mut self) {
        self.blocks.clear();
    }

    // Param is passed by value, moved
    pub fn set_blocks(&mut self, v: ::protobuf::RepeatedField<StorageReceivedDeletedBlocksProto>) {
        self.blocks = v;
    }

    // Mutable pointer to the field.
    pub fn mut_blocks(&mut self) -> &mut ::protobuf::RepeatedField<StorageReceivedDeletedBlocksProto> {
        &mut self.blocks
    }

    // Take field
    pub fn take_blocks(&mut self) -> ::protobuf::RepeatedField<StorageReceivedDeletedBlocksProto> {
        ::std::mem::replace(&mut self.blocks, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for BlockReceivedAndDeletedRequestProto {
    fn is_initialized(&self) -> bool {
        if self.registration.is_none() {
            return false;
        }
        if self.blockPoolId.is_none() {
            return false;
        }
        for v in &self.registration {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.blocks {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.registration)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.blockPoolId)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.blocks)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.registration.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.blockPoolId.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        for value in &self.blocks {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.registration.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.blockPoolId.as_ref() {
            os.write_string(2, &v)?;
        }
        for v in &self.blocks {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BlockReceivedAndDeletedRequestProto {
        BlockReceivedAndDeletedRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DatanodeRegistrationProto>>(
                "registration",
                |m: &BlockReceivedAndDeletedRequestProto| { &m.registration },
                |m: &mut BlockReceivedAndDeletedRequestProto| { &mut m.registration },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "blockPoolId",
                |m: &BlockReceivedAndDeletedRequestProto| { &m.blockPoolId },
                |m: &mut BlockReceivedAndDeletedRequestProto| { &mut m.blockPoolId },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<StorageReceivedDeletedBlocksProto>>(
                "blocks",
                |m: &BlockReceivedAndDeletedRequestProto| { &m.blocks },
                |m: &mut BlockReceivedAndDeletedRequestProto| { &mut m.blocks },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BlockReceivedAndDeletedRequestProto>(
                "BlockReceivedAndDeletedRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BlockReceivedAndDeletedRequestProto {
        static instance: ::protobuf::rt::LazyV2<BlockReceivedAndDeletedRequestProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BlockReceivedAndDeletedRequestProto::new)
    }
}

impl ::protobuf::Clear for BlockReceivedAndDeletedRequestProto {
    fn clear(&mut self) {
        self.registration.clear();
        self.blockPoolId.clear();
        self.blocks.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BlockReceivedAndDeletedRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BlockReceivedAndDeletedRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BlockReceivedAndDeletedResponseProto {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BlockReceivedAndDeletedResponseProto {
    fn default() -> &'a BlockReceivedAndDeletedResponseProto {
        <BlockReceivedAndDeletedResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl BlockReceivedAndDeletedResponseProto {
    pub fn new() -> BlockReceivedAndDeletedResponseProto {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for BlockReceivedAndDeletedResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BlockReceivedAndDeletedResponseProto {
        BlockReceivedAndDeletedResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BlockReceivedAndDeletedResponseProto>(
                "BlockReceivedAndDeletedResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BlockReceivedAndDeletedResponseProto {
        static instance: ::protobuf::rt::LazyV2<BlockReceivedAndDeletedResponseProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BlockReceivedAndDeletedResponseProto::new)
    }
}

impl ::protobuf::Clear for BlockReceivedAndDeletedResponseProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BlockReceivedAndDeletedResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BlockReceivedAndDeletedResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ErrorReportRequestProto {
    // message fields
    pub registartion: ::protobuf::SingularPtrField<DatanodeRegistrationProto>,
    errorCode: ::std::option::Option<u32>,
    msg: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ErrorReportRequestProto {
    fn default() -> &'a ErrorReportRequestProto {
        <ErrorReportRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl ErrorReportRequestProto {
    pub fn new() -> ErrorReportRequestProto {
        ::std::default::Default::default()
    }

    // required .hadoop.hdfs.DatanodeRegistrationProto registartion = 1;


    pub fn get_registartion(&self) -> &DatanodeRegistrationProto {
        self.registartion.as_ref().unwrap_or_else(|| <DatanodeRegistrationProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_registartion(&mut self) {
        self.registartion.clear();
    }

    pub fn has_registartion(&self) -> bool {
        self.registartion.is_some()
    }

    // Param is passed by value, moved
    pub fn set_registartion(&mut self, v: DatanodeRegistrationProto) {
        self.registartion = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_registartion(&mut self) -> &mut DatanodeRegistrationProto {
        if self.registartion.is_none() {
            self.registartion.set_default();
        }
        self.registartion.as_mut().unwrap()
    }

    // Take field
    pub fn take_registartion(&mut self) -> DatanodeRegistrationProto {
        self.registartion.take().unwrap_or_else(|| DatanodeRegistrationProto::new())
    }

    // required uint32 errorCode = 2;


    pub fn get_errorCode(&self) -> u32 {
        self.errorCode.unwrap_or(0)
    }
    pub fn clear_errorCode(&mut self) {
        self.errorCode = ::std::option::Option::None;
    }

    pub fn has_errorCode(&self) -> bool {
        self.errorCode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_errorCode(&mut self, v: u32) {
        self.errorCode = ::std::option::Option::Some(v);
    }

    // required string msg = 3;


    pub fn get_msg(&self) -> &str {
        match self.msg.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_msg(&mut self) {
        self.msg.clear();
    }

    pub fn has_msg(&self) -> bool {
        self.msg.is_some()
    }

    // Param is passed by value, moved
    pub fn set_msg(&mut self, v: ::std::string::String) {
        self.msg = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_msg(&mut self) -> &mut ::std::string::String {
        if self.msg.is_none() {
            self.msg.set_default();
        }
        self.msg.as_mut().unwrap()
    }

    // Take field
    pub fn take_msg(&mut self) -> ::std::string::String {
        self.msg.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for ErrorReportRequestProto {
    fn is_initialized(&self) -> bool {
        if self.registartion.is_none() {
            return false;
        }
        if self.errorCode.is_none() {
            return false;
        }
        if self.msg.is_none() {
            return false;
        }
        for v in &self.registartion {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.registartion)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.errorCode = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.msg)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.registartion.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.errorCode {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.msg.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.registartion.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.errorCode {
            os.write_uint32(2, v)?;
        }
        if let Some(ref v) = self.msg.as_ref() {
            os.write_string(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ErrorReportRequestProto {
        ErrorReportRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DatanodeRegistrationProto>>(
                "registartion",
                |m: &ErrorReportRequestProto| { &m.registartion },
                |m: &mut ErrorReportRequestProto| { &mut m.registartion },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "errorCode",
                |m: &ErrorReportRequestProto| { &m.errorCode },
                |m: &mut ErrorReportRequestProto| { &mut m.errorCode },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "msg",
                |m: &ErrorReportRequestProto| { &m.msg },
                |m: &mut ErrorReportRequestProto| { &mut m.msg },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ErrorReportRequestProto>(
                "ErrorReportRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ErrorReportRequestProto {
        static instance: ::protobuf::rt::LazyV2<ErrorReportRequestProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ErrorReportRequestProto::new)
    }
}

impl ::protobuf::Clear for ErrorReportRequestProto {
    fn clear(&mut self) {
        self.registartion.clear();
        self.errorCode = ::std::option::Option::None;
        self.msg.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ErrorReportRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ErrorReportRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ErrorReportRequestProto_ErrorCode {
    NOTIFY = 0,
    DISK_ERROR = 1,
    INVALID_BLOCK = 2,
    FATAL_DISK_ERROR = 3,
}

impl ::protobuf::ProtobufEnum for ErrorReportRequestProto_ErrorCode {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ErrorReportRequestProto_ErrorCode> {
        match value {
            0 => ::std::option::Option::Some(ErrorReportRequestProto_ErrorCode::NOTIFY),
            1 => ::std::option::Option::Some(ErrorReportRequestProto_ErrorCode::DISK_ERROR),
            2 => ::std::option::Option::Some(ErrorReportRequestProto_ErrorCode::INVALID_BLOCK),
            3 => ::std::option::Option::Some(ErrorReportRequestProto_ErrorCode::FATAL_DISK_ERROR),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ErrorReportRequestProto_ErrorCode] = &[
            ErrorReportRequestProto_ErrorCode::NOTIFY,
            ErrorReportRequestProto_ErrorCode::DISK_ERROR,
            ErrorReportRequestProto_ErrorCode::INVALID_BLOCK,
            ErrorReportRequestProto_ErrorCode::FATAL_DISK_ERROR,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<ErrorReportRequestProto_ErrorCode>("ErrorReportRequestProto.ErrorCode", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for ErrorReportRequestProto_ErrorCode {
}

impl ::std::default::Default for ErrorReportRequestProto_ErrorCode {
    fn default() -> Self {
        ErrorReportRequestProto_ErrorCode::NOTIFY
    }
}

impl ::protobuf::reflect::ProtobufValue for ErrorReportRequestProto_ErrorCode {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ErrorReportResponseProto {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ErrorReportResponseProto {
    fn default() -> &'a ErrorReportResponseProto {
        <ErrorReportResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl ErrorReportResponseProto {
    pub fn new() -> ErrorReportResponseProto {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for ErrorReportResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ErrorReportResponseProto {
        ErrorReportResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ErrorReportResponseProto>(
                "ErrorReportResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ErrorReportResponseProto {
        static instance: ::protobuf::rt::LazyV2<ErrorReportResponseProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ErrorReportResponseProto::new)
    }
}

impl ::protobuf::Clear for ErrorReportResponseProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ErrorReportResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ErrorReportResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ReportBadBlocksRequestProto {
    // message fields
    pub blocks: ::protobuf::RepeatedField<super::hdfs::LocatedBlockProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ReportBadBlocksRequestProto {
    fn default() -> &'a ReportBadBlocksRequestProto {
        <ReportBadBlocksRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl ReportBadBlocksRequestProto {
    pub fn new() -> ReportBadBlocksRequestProto {
        ::std::default::Default::default()
    }

    // repeated .hadoop.hdfs.LocatedBlockProto blocks = 1;


    pub fn get_blocks(&self) -> &[super::hdfs::LocatedBlockProto] {
        &self.blocks
    }
    pub fn clear_blocks(&mut self) {
        self.blocks.clear();
    }

    // Param is passed by value, moved
    pub fn set_blocks(&mut self, v: ::protobuf::RepeatedField<super::hdfs::LocatedBlockProto>) {
        self.blocks = v;
    }

    // Mutable pointer to the field.
    pub fn mut_blocks(&mut self) -> &mut ::protobuf::RepeatedField<super::hdfs::LocatedBlockProto> {
        &mut self.blocks
    }

    // Take field
    pub fn take_blocks(&mut self) -> ::protobuf::RepeatedField<super::hdfs::LocatedBlockProto> {
        ::std::mem::replace(&mut self.blocks, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ReportBadBlocksRequestProto {
    fn is_initialized(&self) -> bool {
        for v in &self.blocks {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.blocks)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.blocks {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.blocks {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ReportBadBlocksRequestProto {
        ReportBadBlocksRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::hdfs::LocatedBlockProto>>(
                "blocks",
                |m: &ReportBadBlocksRequestProto| { &m.blocks },
                |m: &mut ReportBadBlocksRequestProto| { &mut m.blocks },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ReportBadBlocksRequestProto>(
                "ReportBadBlocksRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ReportBadBlocksRequestProto {
        static instance: ::protobuf::rt::LazyV2<ReportBadBlocksRequestProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ReportBadBlocksRequestProto::new)
    }
}

impl ::protobuf::Clear for ReportBadBlocksRequestProto {
    fn clear(&mut self) {
        self.blocks.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ReportBadBlocksRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReportBadBlocksRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ReportBadBlocksResponseProto {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ReportBadBlocksResponseProto {
    fn default() -> &'a ReportBadBlocksResponseProto {
        <ReportBadBlocksResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl ReportBadBlocksResponseProto {
    pub fn new() -> ReportBadBlocksResponseProto {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for ReportBadBlocksResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ReportBadBlocksResponseProto {
        ReportBadBlocksResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ReportBadBlocksResponseProto>(
                "ReportBadBlocksResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ReportBadBlocksResponseProto {
        static instance: ::protobuf::rt::LazyV2<ReportBadBlocksResponseProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ReportBadBlocksResponseProto::new)
    }
}

impl ::protobuf::Clear for ReportBadBlocksResponseProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ReportBadBlocksResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReportBadBlocksResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CommitBlockSynchronizationRequestProto {
    // message fields
    pub block: ::protobuf::SingularPtrField<super::hdfs::ExtendedBlockProto>,
    newGenStamp: ::std::option::Option<u64>,
    newLength: ::std::option::Option<u64>,
    closeFile: ::std::option::Option<bool>,
    deleteBlock: ::std::option::Option<bool>,
    pub newTaragets: ::protobuf::RepeatedField<super::hdfs::DatanodeIDProto>,
    pub newTargetStorages: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CommitBlockSynchronizationRequestProto {
    fn default() -> &'a CommitBlockSynchronizationRequestProto {
        <CommitBlockSynchronizationRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl CommitBlockSynchronizationRequestProto {
    pub fn new() -> CommitBlockSynchronizationRequestProto {
        ::std::default::Default::default()
    }

    // required .hadoop.hdfs.ExtendedBlockProto block = 1;


    pub fn get_block(&self) -> &super::hdfs::ExtendedBlockProto {
        self.block.as_ref().unwrap_or_else(|| <super::hdfs::ExtendedBlockProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_block(&mut self) {
        self.block.clear();
    }

    pub fn has_block(&self) -> bool {
        self.block.is_some()
    }

    // Param is passed by value, moved
    pub fn set_block(&mut self, v: super::hdfs::ExtendedBlockProto) {
        self.block = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_block(&mut self) -> &mut super::hdfs::ExtendedBlockProto {
        if self.block.is_none() {
            self.block.set_default();
        }
        self.block.as_mut().unwrap()
    }

    // Take field
    pub fn take_block(&mut self) -> super::hdfs::ExtendedBlockProto {
        self.block.take().unwrap_or_else(|| super::hdfs::ExtendedBlockProto::new())
    }

    // required uint64 newGenStamp = 2;


    pub fn get_newGenStamp(&self) -> u64 {
        self.newGenStamp.unwrap_or(0)
    }
    pub fn clear_newGenStamp(&mut self) {
        self.newGenStamp = ::std::option::Option::None;
    }

    pub fn has_newGenStamp(&self) -> bool {
        self.newGenStamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_newGenStamp(&mut self, v: u64) {
        self.newGenStamp = ::std::option::Option::Some(v);
    }

    // required uint64 newLength = 3;


    pub fn get_newLength(&self) -> u64 {
        self.newLength.unwrap_or(0)
    }
    pub fn clear_newLength(&mut self) {
        self.newLength = ::std::option::Option::None;
    }

    pub fn has_newLength(&self) -> bool {
        self.newLength.is_some()
    }

    // Param is passed by value, moved
    pub fn set_newLength(&mut self, v: u64) {
        self.newLength = ::std::option::Option::Some(v);
    }

    // required bool closeFile = 4;


    pub fn get_closeFile(&self) -> bool {
        self.closeFile.unwrap_or(false)
    }
    pub fn clear_closeFile(&mut self) {
        self.closeFile = ::std::option::Option::None;
    }

    pub fn has_closeFile(&self) -> bool {
        self.closeFile.is_some()
    }

    // Param is passed by value, moved
    pub fn set_closeFile(&mut self, v: bool) {
        self.closeFile = ::std::option::Option::Some(v);
    }

    // required bool deleteBlock = 5;


    pub fn get_deleteBlock(&self) -> bool {
        self.deleteBlock.unwrap_or(false)
    }
    pub fn clear_deleteBlock(&mut self) {
        self.deleteBlock = ::std::option::Option::None;
    }

    pub fn has_deleteBlock(&self) -> bool {
        self.deleteBlock.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deleteBlock(&mut self, v: bool) {
        self.deleteBlock = ::std::option::Option::Some(v);
    }

    // repeated .hadoop.hdfs.DatanodeIDProto newTaragets = 6;


    pub fn get_newTaragets(&self) -> &[super::hdfs::DatanodeIDProto] {
        &self.newTaragets
    }
    pub fn clear_newTaragets(&mut self) {
        self.newTaragets.clear();
    }

    // Param is passed by value, moved
    pub fn set_newTaragets(&mut self, v: ::protobuf::RepeatedField<super::hdfs::DatanodeIDProto>) {
        self.newTaragets = v;
    }

    // Mutable pointer to the field.
    pub fn mut_newTaragets(&mut self) -> &mut ::protobuf::RepeatedField<super::hdfs::DatanodeIDProto> {
        &mut self.newTaragets
    }

    // Take field
    pub fn take_newTaragets(&mut self) -> ::protobuf::RepeatedField<super::hdfs::DatanodeIDProto> {
        ::std::mem::replace(&mut self.newTaragets, ::protobuf::RepeatedField::new())
    }

    // repeated string newTargetStorages = 7;


    pub fn get_newTargetStorages(&self) -> &[::std::string::String] {
        &self.newTargetStorages
    }
    pub fn clear_newTargetStorages(&mut self) {
        self.newTargetStorages.clear();
    }

    // Param is passed by value, moved
    pub fn set_newTargetStorages(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.newTargetStorages = v;
    }

    // Mutable pointer to the field.
    pub fn mut_newTargetStorages(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.newTargetStorages
    }

    // Take field
    pub fn take_newTargetStorages(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.newTargetStorages, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CommitBlockSynchronizationRequestProto {
    fn is_initialized(&self) -> bool {
        if self.block.is_none() {
            return false;
        }
        if self.newGenStamp.is_none() {
            return false;
        }
        if self.newLength.is_none() {
            return false;
        }
        if self.closeFile.is_none() {
            return false;
        }
        if self.deleteBlock.is_none() {
            return false;
        }
        for v in &self.block {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.newTaragets {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.block)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.newGenStamp = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.newLength = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.closeFile = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.deleteBlock = ::std::option::Option::Some(tmp);
                },
                6 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.newTaragets)?;
                },
                7 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.newTargetStorages)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.block.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.newGenStamp {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.newLength {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.closeFile {
            my_size += 2;
        }
        if let Some(v) = self.deleteBlock {
            my_size += 2;
        }
        for value in &self.newTaragets {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.newTargetStorages {
            my_size += ::protobuf::rt::string_size(7, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.block.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.newGenStamp {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.newLength {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.closeFile {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.deleteBlock {
            os.write_bool(5, v)?;
        }
        for v in &self.newTaragets {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.newTargetStorages {
            os.write_string(7, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CommitBlockSynchronizationRequestProto {
        CommitBlockSynchronizationRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::hdfs::ExtendedBlockProto>>(
                "block",
                |m: &CommitBlockSynchronizationRequestProto| { &m.block },
                |m: &mut CommitBlockSynchronizationRequestProto| { &mut m.block },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "newGenStamp",
                |m: &CommitBlockSynchronizationRequestProto| { &m.newGenStamp },
                |m: &mut CommitBlockSynchronizationRequestProto| { &mut m.newGenStamp },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "newLength",
                |m: &CommitBlockSynchronizationRequestProto| { &m.newLength },
                |m: &mut CommitBlockSynchronizationRequestProto| { &mut m.newLength },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "closeFile",
                |m: &CommitBlockSynchronizationRequestProto| { &m.closeFile },
                |m: &mut CommitBlockSynchronizationRequestProto| { &mut m.closeFile },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "deleteBlock",
                |m: &CommitBlockSynchronizationRequestProto| { &m.deleteBlock },
                |m: &mut CommitBlockSynchronizationRequestProto| { &mut m.deleteBlock },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::hdfs::DatanodeIDProto>>(
                "newTaragets",
                |m: &CommitBlockSynchronizationRequestProto| { &m.newTaragets },
                |m: &mut CommitBlockSynchronizationRequestProto| { &mut m.newTaragets },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "newTargetStorages",
                |m: &CommitBlockSynchronizationRequestProto| { &m.newTargetStorages },
                |m: &mut CommitBlockSynchronizationRequestProto| { &mut m.newTargetStorages },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CommitBlockSynchronizationRequestProto>(
                "CommitBlockSynchronizationRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CommitBlockSynchronizationRequestProto {
        static instance: ::protobuf::rt::LazyV2<CommitBlockSynchronizationRequestProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CommitBlockSynchronizationRequestProto::new)
    }
}

impl ::protobuf::Clear for CommitBlockSynchronizationRequestProto {
    fn clear(&mut self) {
        self.block.clear();
        self.newGenStamp = ::std::option::Option::None;
        self.newLength = ::std::option::Option::None;
        self.closeFile = ::std::option::Option::None;
        self.deleteBlock = ::std::option::Option::None;
        self.newTaragets.clear();
        self.newTargetStorages.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CommitBlockSynchronizationRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CommitBlockSynchronizationRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CommitBlockSynchronizationResponseProto {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CommitBlockSynchronizationResponseProto {
    fn default() -> &'a CommitBlockSynchronizationResponseProto {
        <CommitBlockSynchronizationResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl CommitBlockSynchronizationResponseProto {
    pub fn new() -> CommitBlockSynchronizationResponseProto {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CommitBlockSynchronizationResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CommitBlockSynchronizationResponseProto {
        CommitBlockSynchronizationResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CommitBlockSynchronizationResponseProto>(
                "CommitBlockSynchronizationResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CommitBlockSynchronizationResponseProto {
        static instance: ::protobuf::rt::LazyV2<CommitBlockSynchronizationResponseProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CommitBlockSynchronizationResponseProto::new)
    }
}

impl ::protobuf::Clear for CommitBlockSynchronizationResponseProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CommitBlockSynchronizationResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CommitBlockSynchronizationResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SlowPeerReportProto {
    // message fields
    dataNodeId: ::protobuf::SingularField<::std::string::String>,
    aggregateLatency: ::std::option::Option<f64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SlowPeerReportProto {
    fn default() -> &'a SlowPeerReportProto {
        <SlowPeerReportProto as ::protobuf::Message>::default_instance()
    }
}

impl SlowPeerReportProto {
    pub fn new() -> SlowPeerReportProto {
        ::std::default::Default::default()
    }

    // optional string dataNodeId = 1;


    pub fn get_dataNodeId(&self) -> &str {
        match self.dataNodeId.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_dataNodeId(&mut self) {
        self.dataNodeId.clear();
    }

    pub fn has_dataNodeId(&self) -> bool {
        self.dataNodeId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dataNodeId(&mut self, v: ::std::string::String) {
        self.dataNodeId = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dataNodeId(&mut self) -> &mut ::std::string::String {
        if self.dataNodeId.is_none() {
            self.dataNodeId.set_default();
        }
        self.dataNodeId.as_mut().unwrap()
    }

    // Take field
    pub fn take_dataNodeId(&mut self) -> ::std::string::String {
        self.dataNodeId.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional double aggregateLatency = 2;


    pub fn get_aggregateLatency(&self) -> f64 {
        self.aggregateLatency.unwrap_or(0.)
    }
    pub fn clear_aggregateLatency(&mut self) {
        self.aggregateLatency = ::std::option::Option::None;
    }

    pub fn has_aggregateLatency(&self) -> bool {
        self.aggregateLatency.is_some()
    }

    // Param is passed by value, moved
    pub fn set_aggregateLatency(&mut self, v: f64) {
        self.aggregateLatency = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for SlowPeerReportProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.dataNodeId)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.aggregateLatency = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.dataNodeId.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.aggregateLatency {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.dataNodeId.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.aggregateLatency {
            os.write_double(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SlowPeerReportProto {
        SlowPeerReportProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "dataNodeId",
                |m: &SlowPeerReportProto| { &m.dataNodeId },
                |m: &mut SlowPeerReportProto| { &mut m.dataNodeId },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                "aggregateLatency",
                |m: &SlowPeerReportProto| { &m.aggregateLatency },
                |m: &mut SlowPeerReportProto| { &mut m.aggregateLatency },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SlowPeerReportProto>(
                "SlowPeerReportProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SlowPeerReportProto {
        static instance: ::protobuf::rt::LazyV2<SlowPeerReportProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SlowPeerReportProto::new)
    }
}

impl ::protobuf::Clear for SlowPeerReportProto {
    fn clear(&mut self) {
        self.dataNodeId.clear();
        self.aggregateLatency = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SlowPeerReportProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SlowPeerReportProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SlowDiskReportProto {
    // message fields
    basePath: ::protobuf::SingularField<::std::string::String>,
    meanMetadataOpLatency: ::std::option::Option<f64>,
    meanReadIoLatency: ::std::option::Option<f64>,
    meanWriteIoLatency: ::std::option::Option<f64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SlowDiskReportProto {
    fn default() -> &'a SlowDiskReportProto {
        <SlowDiskReportProto as ::protobuf::Message>::default_instance()
    }
}

impl SlowDiskReportProto {
    pub fn new() -> SlowDiskReportProto {
        ::std::default::Default::default()
    }

    // optional string basePath = 1;


    pub fn get_basePath(&self) -> &str {
        match self.basePath.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_basePath(&mut self) {
        self.basePath.clear();
    }

    pub fn has_basePath(&self) -> bool {
        self.basePath.is_some()
    }

    // Param is passed by value, moved
    pub fn set_basePath(&mut self, v: ::std::string::String) {
        self.basePath = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_basePath(&mut self) -> &mut ::std::string::String {
        if self.basePath.is_none() {
            self.basePath.set_default();
        }
        self.basePath.as_mut().unwrap()
    }

    // Take field
    pub fn take_basePath(&mut self) -> ::std::string::String {
        self.basePath.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional double meanMetadataOpLatency = 2;


    pub fn get_meanMetadataOpLatency(&self) -> f64 {
        self.meanMetadataOpLatency.unwrap_or(0.)
    }
    pub fn clear_meanMetadataOpLatency(&mut self) {
        self.meanMetadataOpLatency = ::std::option::Option::None;
    }

    pub fn has_meanMetadataOpLatency(&self) -> bool {
        self.meanMetadataOpLatency.is_some()
    }

    // Param is passed by value, moved
    pub fn set_meanMetadataOpLatency(&mut self, v: f64) {
        self.meanMetadataOpLatency = ::std::option::Option::Some(v);
    }

    // optional double meanReadIoLatency = 3;


    pub fn get_meanReadIoLatency(&self) -> f64 {
        self.meanReadIoLatency.unwrap_or(0.)
    }
    pub fn clear_meanReadIoLatency(&mut self) {
        self.meanReadIoLatency = ::std::option::Option::None;
    }

    pub fn has_meanReadIoLatency(&self) -> bool {
        self.meanReadIoLatency.is_some()
    }

    // Param is passed by value, moved
    pub fn set_meanReadIoLatency(&mut self, v: f64) {
        self.meanReadIoLatency = ::std::option::Option::Some(v);
    }

    // optional double meanWriteIoLatency = 4;


    pub fn get_meanWriteIoLatency(&self) -> f64 {
        self.meanWriteIoLatency.unwrap_or(0.)
    }
    pub fn clear_meanWriteIoLatency(&mut self) {
        self.meanWriteIoLatency = ::std::option::Option::None;
    }

    pub fn has_meanWriteIoLatency(&self) -> bool {
        self.meanWriteIoLatency.is_some()
    }

    // Param is passed by value, moved
    pub fn set_meanWriteIoLatency(&mut self, v: f64) {
        self.meanWriteIoLatency = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for SlowDiskReportProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.basePath)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.meanMetadataOpLatency = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.meanReadIoLatency = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.meanWriteIoLatency = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.basePath.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.meanMetadataOpLatency {
            my_size += 9;
        }
        if let Some(v) = self.meanReadIoLatency {
            my_size += 9;
        }
        if let Some(v) = self.meanWriteIoLatency {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.basePath.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.meanMetadataOpLatency {
            os.write_double(2, v)?;
        }
        if let Some(v) = self.meanReadIoLatency {
            os.write_double(3, v)?;
        }
        if let Some(v) = self.meanWriteIoLatency {
            os.write_double(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SlowDiskReportProto {
        SlowDiskReportProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "basePath",
                |m: &SlowDiskReportProto| { &m.basePath },
                |m: &mut SlowDiskReportProto| { &mut m.basePath },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                "meanMetadataOpLatency",
                |m: &SlowDiskReportProto| { &m.meanMetadataOpLatency },
                |m: &mut SlowDiskReportProto| { &mut m.meanMetadataOpLatency },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                "meanReadIoLatency",
                |m: &SlowDiskReportProto| { &m.meanReadIoLatency },
                |m: &mut SlowDiskReportProto| { &mut m.meanReadIoLatency },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                "meanWriteIoLatency",
                |m: &SlowDiskReportProto| { &m.meanWriteIoLatency },
                |m: &mut SlowDiskReportProto| { &mut m.meanWriteIoLatency },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SlowDiskReportProto>(
                "SlowDiskReportProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SlowDiskReportProto {
        static instance: ::protobuf::rt::LazyV2<SlowDiskReportProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SlowDiskReportProto::new)
    }
}

impl ::protobuf::Clear for SlowDiskReportProto {
    fn clear(&mut self) {
        self.basePath.clear();
        self.meanMetadataOpLatency = ::std::option::Option::None;
        self.meanReadIoLatency = ::std::option::Option::None;
        self.meanWriteIoLatency = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SlowDiskReportProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SlowDiskReportProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x16DatanodeProtocol.proto\x12\x0bhadoop.hdfs\x1a\nhdfs.proto\x1a\x13e\
    rasurecoding.proto\x1a\x10HdfsServer.protoP\0P\x01P\x02\"\x87\x02\n\x19D\
    atanodeRegistrationProto\x12>\n\ndatanodeID\x18\x01\x20\x02(\x0b2\x1c.ha\
    doop.hdfs.DatanodeIDProtoR\ndatanodeIDB\0\x12A\n\x0bstorageInfo\x18\x02\
    \x20\x02(\x0b2\x1d.hadoop.hdfs.StorageInfoProtoR\x0bstorageInfoB\0\x129\
    \n\x04keys\x18\x03\x20\x02(\x0b2#.hadoop.hdfs.ExportedBlockKeysProtoR\
    \x04keysB\0\x12*\n\x0fsoftwareVersion\x18\x04\x20\x02(\tR\x0fsoftwareVer\
    sionB\0:\0\"\xb2\x07\n\x14DatanodeCommandProto\x12B\n\x07cmdType\x18\x01\
    \x20\x02(\x0e2&.hadoop.hdfs.DatanodeCommandProto.TypeR\x07cmdTypeB\0\x12\
    N\n\x0bbalancerCmd\x18\x02\x20\x01(\x0b2*.hadoop.hdfs.BalancerBandwidthC\
    ommandProtoR\x0bbalancerCmdB\0\x128\n\x06blkCmd\x18\x03\x20\x01(\x0b2\
    \x1e.hadoop.hdfs.BlockCommandProtoR\x06blkCmdB\0\x12J\n\x0brecoveryCmd\
    \x18\x04\x20\x01(\x0b2&.hadoop.hdfs.BlockRecoveryCommandProtoR\x0brecove\
    ryCmdB\0\x12E\n\x0bfinalizeCmd\x18\x05\x20\x01(\x0b2!.hadoop.hdfs.Finali\
    zeCommandProtoR\x0bfinalizeCmdB\0\x12H\n\x0ckeyUpdateCmd\x18\x06\x20\x01\
    (\x0b2\".hadoop.hdfs.KeyUpdateCommandProtoR\x0ckeyUpdateCmdB\0\x12E\n\
    \x0bregisterCmd\x18\x07\x20\x01(\x0b2!.hadoop.hdfs.RegisterCommandProtoR\
    \x0bregisterCmdB\0\x12>\n\x08blkIdCmd\x18\x08\x20\x01(\x0b2\x20.hadoop.h\
    dfs.BlockIdCommandProtoR\x08blkIdCmdB\0\x12h\n\x16blkECReconstructionCmd\
    \x18\t\x20\x01(\x0b2..hadoop.hdfs.BlockECReconstructionCommandProtoR\x16\
    blkECReconstructionCmdB\0\"\xfb\x01\n\x04Type\x12\x1c\n\x18BalancerBandw\
    idthCommand\x10\0\x12\x10\n\x0cBlockCommand\x10\x01\x12\x18\n\x14BlockRe\
    coveryCommand\x10\x02\x12\x13\n\x0fFinalizeCommand\x10\x03\x12\x14\n\x10\
    KeyUpdateCommand\x10\x04\x12\x13\n\x0fRegisterCommand\x10\x05\x12\x18\n\
    \x14UnusedUpgradeCommand\x10\x06\x12\x17\n\x13NullDatanodeCommand\x10\
    \x07\x12\x12\n\x0eBlockIdCommand\x10\x08\x12\x20\n\x1cBlockECReconstruct\
    ionCommand\x10\t\x1a\0:\0\"A\n\x1dBalancerBandwidthCommandProto\x12\x1e\
    \n\tbandwidth\x18\x01\x20\x02(\x04R\tbandwidthB\0:\0\"\xc6\x03\n\x11Bloc\
    kCommandProto\x12?\n\x06action\x18\x01\x20\x02(\x0e2%.hadoop.hdfs.BlockC\
    ommandProto.ActionR\x06actionB\0\x12\"\n\x0bblockPoolId\x18\x02\x20\x02(\
    \tR\x0bblockPoolIdB\0\x121\n\x06blocks\x18\x03\x20\x03(\x0b2\x17.hadoop.\
    hdfs.BlockProtoR\x06blocksB\0\x12;\n\x07targets\x18\x04\x20\x03(\x0b2\
    \x1f.hadoop.hdfs.DatanodeInfosProtoR\x07targetsB\0\x12P\n\x12targetStora\
    geUuids\x18\x05\x20\x03(\x0b2\x1e.hadoop.hdfs.StorageUuidsProtoR\x12targ\
    etStorageUuidsB\0\x12P\n\x12targetStorageTypes\x18\x06\x20\x03(\x0b2\x1e\
    .hadoop.hdfs.StorageTypesProtoR\x12targetStorageTypesB\0\"6\n\x06Action\
    \x12\x0c\n\x08TRANSFER\x10\x01\x12\x0e\n\nINVALIDATE\x10\x02\x12\x0c\n\
    \x08SHUTDOWN\x10\x03\x1a\0:\0\"\xc2\x01\n\x13BlockIdCommandProto\x12A\n\
    \x06action\x18\x01\x20\x02(\x0e2'.hadoop.hdfs.BlockIdCommandProto.Action\
    R\x06actionB\0\x12\"\n\x0bblockPoolId\x18\x02\x20\x02(\tR\x0bblockPoolId\
    B\0\x12\x1e\n\x08blockIds\x18\x03\x20\x03(\x04R\x08blockIdsB\x02\x10\x01\
    \"\"\n\x06Action\x12\t\n\x05CACHE\x10\x01\x12\x0b\n\x07UNCACHE\x10\x02\
    \x1a\0:\0\"Z\n\x19BlockRecoveryCommandProto\x12;\n\x06blocks\x18\x01\x20\
    \x03(\x0b2!.hadoop.hdfs.RecoveringBlockProtoR\x06blocksB\0:\0\"<\n\x14Fi\
    nalizeCommandProto\x12\"\n\x0bblockPoolId\x18\x01\x20\x02(\tR\x0bblockPo\
    olIdB\0:\0\"T\n\x15KeyUpdateCommandProto\x129\n\x04keys\x18\x01\x20\x02(\
    \x0b2#.hadoop.hdfs.ExportedBlockKeysProtoR\x04keysB\0:\0\"\x18\n\x14Regi\
    sterCommandProto:\0\"\x92\x01\n!BlockECReconstructionCommandProto\x12k\n\
    \x19blockECReconstructioninfo\x18\x01\x20\x03(\x0b2+.hadoop.hdfs.BlockEC\
    ReconstructionInfoProtoR\x19blockECReconstructioninfoB\0:\0\"n\n\x1cRegi\
    sterDatanodeRequestProto\x12L\n\x0cregistration\x18\x01\x20\x02(\x0b2&.h\
    adoop.hdfs.DatanodeRegistrationProtoR\x0cregistrationB\0:\0\"o\n\x1dRegi\
    sterDatanodeResponseProto\x12L\n\x0cregistration\x18\x01\x20\x02(\x0b2&.\
    hadoop.hdfs.DatanodeRegistrationProtoR\x0cregistrationB\0:\0\"\xd1\x01\n\
    \x19VolumeFailureSummaryProto\x128\n\x16failedStorageLocations\x18\x01\
    \x20\x03(\tR\x16failedStorageLocationsB\0\x126\n\x15lastVolumeFailureDat\
    e\x18\x02\x20\x02(\x04R\x15lastVolumeFailureDateB\0\x12@\n\x1aestimatedC\
    apacityLostTotal\x18\x03\x20\x02(\x04R\x1aestimatedCapacityLostTotalB\0:\
    \0\"\xa2\x05\n\x15HeartbeatRequestProto\x12L\n\x0cregistration\x18\x01\
    \x20\x02(\x0b2&.hadoop.hdfs.DatanodeRegistrationProtoR\x0cregistrationB\
    \0\x12;\n\x07reports\x18\x02\x20\x03(\x0b2\x1f.hadoop.hdfs.StorageReport\
    ProtoR\x07reportsB\0\x12-\n\x0fxmitsInProgress\x18\x03\x20\x01(\r:\x010R\
    \x0fxmitsInProgressB\0\x12'\n\x0cxceiverCount\x18\x04\x20\x01(\r:\x010R\
    \x0cxceiverCountB\0\x12)\n\rfailedVolumes\x18\x05\x20\x01(\r:\x010R\rfai\
    ledVolumesB\0\x12)\n\rcacheCapacity\x18\x06\x20\x01(\x04:\x010R\rcacheCa\
    pacityB\0\x12!\n\tcacheUsed\x18\x07\x20\x01(\x04:\x010R\tcacheUsedB\0\
    \x12\\\n\x14volumeFailureSummary\x18\x08\x20\x01(\x0b2&.hadoop.hdfs.Volu\
    meFailureSummaryProtoR\x14volumeFailureSummaryB\0\x12I\n\x1brequestFullB\
    lockReportLease\x18\t\x20\x01(\x08:\x05falseR\x1brequestFullBlockReportL\
    easeB\0\x12@\n\tslowPeers\x18\n\x20\x03(\x0b2\x20.hadoop.hdfs.SlowPeerRe\
    portProtoR\tslowPeersB\0\x12@\n\tslowDisks\x18\x0b\x20\x03(\x0b2\x20.had\
    oop.hdfs.SlowDiskReportProtoR\tslowDisksB\0:\0\"\x95\x03\n\x16HeartbeatR\
    esponseProto\x127\n\x04cmds\x18\x01\x20\x03(\x0b2!.hadoop.hdfs.DatanodeC\
    ommandProtoR\x04cmdsB\0\x12C\n\x08haStatus\x18\x02\x20\x02(\x0b2%.hadoop\
    .hdfs.NNHAStatusHeartbeatProtoR\x08haStatusB\0\x12\\\n\x14rollingUpgrade\
    Status\x18\x03\x20\x01(\x0b2&.hadoop.hdfs.RollingUpgradeStatusProtoR\x14\
    rollingUpgradeStatusB\0\x12`\n\x16rollingUpgradeStatusV2\x18\x04\x20\x01\
    (\x0b2&.hadoop.hdfs.RollingUpgradeStatusProtoR\x16rollingUpgradeStatusV2\
    B\0\x12;\n\x16fullBlockReportLeaseId\x18\x05\x20\x01(\x04:\x010R\x16full\
    BlockReportLeaseIdB\0:\0\"\x91\x02\n\x17BlockReportRequestProto\x12L\n\
    \x0cregistration\x18\x01\x20\x02(\x0b2&.hadoop.hdfs.DatanodeRegistration\
    ProtoR\x0cregistrationB\0\x12\"\n\x0bblockPoolId\x18\x02\x20\x02(\tR\x0b\
    blockPoolIdB\0\x12@\n\x07reports\x18\x03\x20\x03(\x0b2$.hadoop.hdfs.Stor\
    ageBlockReportProtoR\x07reportsB\0\x12@\n\x07context\x18\x04\x20\x01(\
    \x0b2$.hadoop.hdfs.BlockReportContextProtoR\x07contextB\0:\0\"\xa7\x01\n\
    \x17BlockReportContextProto\x12\x1e\n\ttotalRpcs\x18\x01\x20\x02(\x05R\t\
    totalRpcsB\0\x12\x18\n\x06curRpc\x18\x02\x20\x02(\x05R\x06curRpcB\0\x12\
    \x10\n\x02id\x18\x03\x20\x02(\x03R\x02idB\0\x12\x1d\n\x07leaseId\x18\x04\
    \x20\x01(\x04:\x010R\x07leaseIdB\0\x12\x1f\n\x06sorted\x18\x05\x20\x01(\
    \x08:\x05falseR\x06sortedB\0:\0\"\xc8\x01\n\x17StorageBlockReportProto\
    \x12=\n\x07storage\x18\x01\x20\x02(\x0b2!.hadoop.hdfs.DatanodeStoragePro\
    toR\x07storageB\0\x12\x1a\n\x06blocks\x18\x02\x20\x03(\x04R\x06blocksB\
    \x02\x10\x01\x12(\n\x0enumberOfBlocks\x18\x03\x20\x01(\x04R\x0enumberOfB\
    locksB\0\x12&\n\rblocksBuffers\x18\x04\x20\x03(\x0cR\rblocksBuffersB\0:\
    \0\"S\n\x18BlockReportResponseProto\x125\n\x03cmd\x18\x01\x20\x01(\x0b2!\
    .hadoop.hdfs.DatanodeCommandProtoR\x03cmdB\0:\0\"\xa9\x01\n\x17CacheRepo\
    rtRequestProto\x12L\n\x0cregistration\x18\x01\x20\x02(\x0b2&.hadoop.hdfs\
    .DatanodeRegistrationProtoR\x0cregistrationB\0\x12\"\n\x0bblockPoolId\
    \x18\x02\x20\x02(\tR\x0bblockPoolIdB\0\x12\x1a\n\x06blocks\x18\x03\x20\
    \x03(\x04R\x06blocksB\x02\x10\x01:\0\"S\n\x18CacheReportResponseProto\
    \x125\n\x03cmd\x18\x01\x20\x01(\x0b2!.hadoop.hdfs.DatanodeCommandProtoR\
    \x03cmdB\0:\0\"\x81\x02\n\x1dReceivedDeletedBlockInfoProto\x12/\n\x05blo\
    ck\x18\x01\x20\x02(\x0b2\x17.hadoop.hdfs.BlockProtoR\x05blockB\0\x12P\n\
    \x06status\x18\x03\x20\x02(\x0e26.hadoop.hdfs.ReceivedDeletedBlockInfoPr\
    oto.BlockStatusR\x06statusB\0\x12\x20\n\ndeleteHint\x18\x02\x20\x01(\tR\
    \ndeleteHintB\0\"9\n\x0bBlockStatus\x12\r\n\tRECEIVING\x10\x01\x12\x0c\n\
    \x08RECEIVED\x10\x02\x12\x0b\n\x07DELETED\x10\x03\x1a\0:\0\"\xd0\x01\n!S\
    torageReceivedDeletedBlocksProto\x12$\n\x0bstorageUuid\x18\x01\x20\x02(\
    \tR\x0bstorageUuidB\x02\x18\x01\x12D\n\x06blocks\x18\x02\x20\x03(\x0b2*.\
    hadoop.hdfs.ReceivedDeletedBlockInfoProtoR\x06blocksB\0\x12=\n\x07storag\
    e\x18\x03\x20\x01(\x0b2!.hadoop.hdfs.DatanodeStorageProtoR\x07storageB\0\
    :\0\"\xe3\x01\n#BlockReceivedAndDeletedRequestProto\x12L\n\x0cregistrati\
    on\x18\x01\x20\x02(\x0b2&.hadoop.hdfs.DatanodeRegistrationProtoR\x0cregi\
    strationB\0\x12\"\n\x0bblockPoolId\x18\x02\x20\x02(\tR\x0bblockPoolIdB\0\
    \x12H\n\x06blocks\x18\x03\x20\x03(\x0b2..hadoop.hdfs.StorageReceivedDele\
    tedBlocksProtoR\x06blocksB\0:\0\"(\n$BlockReceivedAndDeletedResponseProt\
    o:\0\"\xf1\x01\n\x17ErrorReportRequestProto\x12L\n\x0cregistartion\x18\
    \x01\x20\x02(\x0b2&.hadoop.hdfs.DatanodeRegistrationProtoR\x0cregistarti\
    onB\0\x12\x1e\n\terrorCode\x18\x02\x20\x02(\rR\terrorCodeB\0\x12\x12\n\
    \x03msg\x18\x03\x20\x02(\tR\x03msgB\0\"R\n\tErrorCode\x12\n\n\x06NOTIFY\
    \x10\0\x12\x0e\n\nDISK_ERROR\x10\x01\x12\x11\n\rINVALID_BLOCK\x10\x02\
    \x12\x14\n\x10FATAL_DISK_ERROR\x10\x03\x1a\0:\0\"\x1c\n\x18ErrorReportRe\
    sponseProto:\0\"Y\n\x1bReportBadBlocksRequestProto\x128\n\x06blocks\x18\
    \x01\x20\x03(\x0b2\x1e.hadoop.hdfs.LocatedBlockProtoR\x06blocksB\0:\0\"\
    \x20\n\x1cReportBadBlocksResponseProto:\0\"\xdd\x02\n&CommitBlockSynchro\
    nizationRequestProto\x127\n\x05block\x18\x01\x20\x02(\x0b2\x1f.hadoop.hd\
    fs.ExtendedBlockProtoR\x05blockB\0\x12\"\n\x0bnewGenStamp\x18\x02\x20\
    \x02(\x04R\x0bnewGenStampB\0\x12\x1e\n\tnewLength\x18\x03\x20\x02(\x04R\
    \tnewLengthB\0\x12\x1e\n\tcloseFile\x18\x04\x20\x02(\x08R\tcloseFileB\0\
    \x12\"\n\x0bdeleteBlock\x18\x05\x20\x02(\x08R\x0bdeleteBlockB\0\x12@\n\
    \x0bnewTaragets\x18\x06\x20\x03(\x0b2\x1c.hadoop.hdfs.DatanodeIDProtoR\
    \x0bnewTaragetsB\0\x12.\n\x11newTargetStorages\x18\x07\x20\x03(\tR\x11ne\
    wTargetStoragesB\0:\0\"+\n'CommitBlockSynchronizationResponseProto:\0\"g\
    \n\x13SlowPeerReportProto\x12\x20\n\ndataNodeId\x18\x01\x20\x01(\tR\ndat\
    aNodeIdB\0\x12,\n\x10aggregateLatency\x18\x02\x20\x01(\x01R\x10aggregate\
    LatencyB\0:\0\"\xcf\x01\n\x13SlowDiskReportProto\x12\x1c\n\x08basePath\
    \x18\x01\x20\x01(\tR\x08basePathB\0\x126\n\x15meanMetadataOpLatency\x18\
    \x02\x20\x01(\x01R\x15meanMetadataOpLatencyB\0\x12.\n\x11meanReadIoLaten\
    cy\x18\x03\x20\x01(\x01R\x11meanReadIoLatencyB\0\x120\n\x12meanWriteIoLa\
    tency\x18\x04\x20\x01(\x01R\x12meanWriteIoLatencyB\0:\0B\0b\x06proto2\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
