// This file is generated by rust-protobuf 2.20.0. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![rustfmt::skip]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `QJournalProtocol.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_20_0;

#[derive(PartialEq,Clone,Default)]
pub struct JournalIdProto {
    // message fields
    identifier: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a JournalIdProto {
    fn default() -> &'a JournalIdProto {
        <JournalIdProto as ::protobuf::Message>::default_instance()
    }
}

impl JournalIdProto {
    pub fn new() -> JournalIdProto {
        ::std::default::Default::default()
    }

    // required string identifier = 1;


    pub fn get_identifier(&self) -> &str {
        match self.identifier.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_identifier(&mut self) {
        self.identifier.clear();
    }

    pub fn has_identifier(&self) -> bool {
        self.identifier.is_some()
    }

    // Param is passed by value, moved
    pub fn set_identifier(&mut self, v: ::std::string::String) {
        self.identifier = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_identifier(&mut self) -> &mut ::std::string::String {
        if self.identifier.is_none() {
            self.identifier.set_default();
        }
        self.identifier.as_mut().unwrap()
    }

    // Take field
    pub fn take_identifier(&mut self) -> ::std::string::String {
        self.identifier.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for JournalIdProto {
    fn is_initialized(&self) -> bool {
        if self.identifier.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.identifier)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.identifier.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.identifier.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> JournalIdProto {
        JournalIdProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "identifier",
                |m: &JournalIdProto| { &m.identifier },
                |m: &mut JournalIdProto| { &mut m.identifier },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<JournalIdProto>(
                "JournalIdProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static JournalIdProto {
        static instance: ::protobuf::rt::LazyV2<JournalIdProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(JournalIdProto::new)
    }
}

impl ::protobuf::Clear for JournalIdProto {
    fn clear(&mut self) {
        self.identifier.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for JournalIdProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for JournalIdProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RequestInfoProto {
    // message fields
    pub journalId: ::protobuf::SingularPtrField<JournalIdProto>,
    epoch: ::std::option::Option<u64>,
    ipcSerialNumber: ::std::option::Option<u64>,
    committedTxId: ::std::option::Option<u64>,
    nameServiceId: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RequestInfoProto {
    fn default() -> &'a RequestInfoProto {
        <RequestInfoProto as ::protobuf::Message>::default_instance()
    }
}

impl RequestInfoProto {
    pub fn new() -> RequestInfoProto {
        ::std::default::Default::default()
    }

    // required .hadoop.hdfs.JournalIdProto journalId = 1;


    pub fn get_journalId(&self) -> &JournalIdProto {
        self.journalId.as_ref().unwrap_or_else(|| <JournalIdProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_journalId(&mut self) {
        self.journalId.clear();
    }

    pub fn has_journalId(&self) -> bool {
        self.journalId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_journalId(&mut self, v: JournalIdProto) {
        self.journalId = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_journalId(&mut self) -> &mut JournalIdProto {
        if self.journalId.is_none() {
            self.journalId.set_default();
        }
        self.journalId.as_mut().unwrap()
    }

    // Take field
    pub fn take_journalId(&mut self) -> JournalIdProto {
        self.journalId.take().unwrap_or_else(|| JournalIdProto::new())
    }

    // required uint64 epoch = 2;


    pub fn get_epoch(&self) -> u64 {
        self.epoch.unwrap_or(0)
    }
    pub fn clear_epoch(&mut self) {
        self.epoch = ::std::option::Option::None;
    }

    pub fn has_epoch(&self) -> bool {
        self.epoch.is_some()
    }

    // Param is passed by value, moved
    pub fn set_epoch(&mut self, v: u64) {
        self.epoch = ::std::option::Option::Some(v);
    }

    // required uint64 ipcSerialNumber = 3;


    pub fn get_ipcSerialNumber(&self) -> u64 {
        self.ipcSerialNumber.unwrap_or(0)
    }
    pub fn clear_ipcSerialNumber(&mut self) {
        self.ipcSerialNumber = ::std::option::Option::None;
    }

    pub fn has_ipcSerialNumber(&self) -> bool {
        self.ipcSerialNumber.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ipcSerialNumber(&mut self, v: u64) {
        self.ipcSerialNumber = ::std::option::Option::Some(v);
    }

    // optional uint64 committedTxId = 4;


    pub fn get_committedTxId(&self) -> u64 {
        self.committedTxId.unwrap_or(0)
    }
    pub fn clear_committedTxId(&mut self) {
        self.committedTxId = ::std::option::Option::None;
    }

    pub fn has_committedTxId(&self) -> bool {
        self.committedTxId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_committedTxId(&mut self, v: u64) {
        self.committedTxId = ::std::option::Option::Some(v);
    }

    // optional string nameServiceId = 5;


    pub fn get_nameServiceId(&self) -> &str {
        match self.nameServiceId.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_nameServiceId(&mut self) {
        self.nameServiceId.clear();
    }

    pub fn has_nameServiceId(&self) -> bool {
        self.nameServiceId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nameServiceId(&mut self, v: ::std::string::String) {
        self.nameServiceId = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_nameServiceId(&mut self) -> &mut ::std::string::String {
        if self.nameServiceId.is_none() {
            self.nameServiceId.set_default();
        }
        self.nameServiceId.as_mut().unwrap()
    }

    // Take field
    pub fn take_nameServiceId(&mut self) -> ::std::string::String {
        self.nameServiceId.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for RequestInfoProto {
    fn is_initialized(&self) -> bool {
        if self.journalId.is_none() {
            return false;
        }
        if self.epoch.is_none() {
            return false;
        }
        if self.ipcSerialNumber.is_none() {
            return false;
        }
        for v in &self.journalId {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.journalId)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.epoch = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.ipcSerialNumber = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.committedTxId = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.nameServiceId)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.journalId.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.epoch {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.ipcSerialNumber {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.committedTxId {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.nameServiceId.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.journalId.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.epoch {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.ipcSerialNumber {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.committedTxId {
            os.write_uint64(4, v)?;
        }
        if let Some(ref v) = self.nameServiceId.as_ref() {
            os.write_string(5, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RequestInfoProto {
        RequestInfoProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<JournalIdProto>>(
                "journalId",
                |m: &RequestInfoProto| { &m.journalId },
                |m: &mut RequestInfoProto| { &mut m.journalId },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "epoch",
                |m: &RequestInfoProto| { &m.epoch },
                |m: &mut RequestInfoProto| { &mut m.epoch },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "ipcSerialNumber",
                |m: &RequestInfoProto| { &m.ipcSerialNumber },
                |m: &mut RequestInfoProto| { &mut m.ipcSerialNumber },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "committedTxId",
                |m: &RequestInfoProto| { &m.committedTxId },
                |m: &mut RequestInfoProto| { &mut m.committedTxId },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "nameServiceId",
                |m: &RequestInfoProto| { &m.nameServiceId },
                |m: &mut RequestInfoProto| { &mut m.nameServiceId },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RequestInfoProto>(
                "RequestInfoProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RequestInfoProto {
        static instance: ::protobuf::rt::LazyV2<RequestInfoProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RequestInfoProto::new)
    }
}

impl ::protobuf::Clear for RequestInfoProto {
    fn clear(&mut self) {
        self.journalId.clear();
        self.epoch = ::std::option::Option::None;
        self.ipcSerialNumber = ::std::option::Option::None;
        self.committedTxId = ::std::option::Option::None;
        self.nameServiceId.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RequestInfoProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RequestInfoProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SegmentStateProto {
    // message fields
    startTxId: ::std::option::Option<u64>,
    endTxId: ::std::option::Option<u64>,
    isInProgress: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SegmentStateProto {
    fn default() -> &'a SegmentStateProto {
        <SegmentStateProto as ::protobuf::Message>::default_instance()
    }
}

impl SegmentStateProto {
    pub fn new() -> SegmentStateProto {
        ::std::default::Default::default()
    }

    // required uint64 startTxId = 1;


    pub fn get_startTxId(&self) -> u64 {
        self.startTxId.unwrap_or(0)
    }
    pub fn clear_startTxId(&mut self) {
        self.startTxId = ::std::option::Option::None;
    }

    pub fn has_startTxId(&self) -> bool {
        self.startTxId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_startTxId(&mut self, v: u64) {
        self.startTxId = ::std::option::Option::Some(v);
    }

    // required uint64 endTxId = 2;


    pub fn get_endTxId(&self) -> u64 {
        self.endTxId.unwrap_or(0)
    }
    pub fn clear_endTxId(&mut self) {
        self.endTxId = ::std::option::Option::None;
    }

    pub fn has_endTxId(&self) -> bool {
        self.endTxId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_endTxId(&mut self, v: u64) {
        self.endTxId = ::std::option::Option::Some(v);
    }

    // required bool isInProgress = 3;


    pub fn get_isInProgress(&self) -> bool {
        self.isInProgress.unwrap_or(false)
    }
    pub fn clear_isInProgress(&mut self) {
        self.isInProgress = ::std::option::Option::None;
    }

    pub fn has_isInProgress(&self) -> bool {
        self.isInProgress.is_some()
    }

    // Param is passed by value, moved
    pub fn set_isInProgress(&mut self, v: bool) {
        self.isInProgress = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for SegmentStateProto {
    fn is_initialized(&self) -> bool {
        if self.startTxId.is_none() {
            return false;
        }
        if self.endTxId.is_none() {
            return false;
        }
        if self.isInProgress.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.startTxId = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.endTxId = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.isInProgress = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.startTxId {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.endTxId {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.isInProgress {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.startTxId {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.endTxId {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.isInProgress {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SegmentStateProto {
        SegmentStateProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "startTxId",
                |m: &SegmentStateProto| { &m.startTxId },
                |m: &mut SegmentStateProto| { &mut m.startTxId },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "endTxId",
                |m: &SegmentStateProto| { &m.endTxId },
                |m: &mut SegmentStateProto| { &mut m.endTxId },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "isInProgress",
                |m: &SegmentStateProto| { &m.isInProgress },
                |m: &mut SegmentStateProto| { &mut m.isInProgress },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SegmentStateProto>(
                "SegmentStateProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SegmentStateProto {
        static instance: ::protobuf::rt::LazyV2<SegmentStateProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SegmentStateProto::new)
    }
}

impl ::protobuf::Clear for SegmentStateProto {
    fn clear(&mut self) {
        self.startTxId = ::std::option::Option::None;
        self.endTxId = ::std::option::Option::None;
        self.isInProgress = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SegmentStateProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SegmentStateProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PersistedRecoveryPaxosData {
    // message fields
    pub segmentState: ::protobuf::SingularPtrField<SegmentStateProto>,
    acceptedInEpoch: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PersistedRecoveryPaxosData {
    fn default() -> &'a PersistedRecoveryPaxosData {
        <PersistedRecoveryPaxosData as ::protobuf::Message>::default_instance()
    }
}

impl PersistedRecoveryPaxosData {
    pub fn new() -> PersistedRecoveryPaxosData {
        ::std::default::Default::default()
    }

    // required .hadoop.hdfs.SegmentStateProto segmentState = 1;


    pub fn get_segmentState(&self) -> &SegmentStateProto {
        self.segmentState.as_ref().unwrap_or_else(|| <SegmentStateProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_segmentState(&mut self) {
        self.segmentState.clear();
    }

    pub fn has_segmentState(&self) -> bool {
        self.segmentState.is_some()
    }

    // Param is passed by value, moved
    pub fn set_segmentState(&mut self, v: SegmentStateProto) {
        self.segmentState = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_segmentState(&mut self) -> &mut SegmentStateProto {
        if self.segmentState.is_none() {
            self.segmentState.set_default();
        }
        self.segmentState.as_mut().unwrap()
    }

    // Take field
    pub fn take_segmentState(&mut self) -> SegmentStateProto {
        self.segmentState.take().unwrap_or_else(|| SegmentStateProto::new())
    }

    // required uint64 acceptedInEpoch = 2;


    pub fn get_acceptedInEpoch(&self) -> u64 {
        self.acceptedInEpoch.unwrap_or(0)
    }
    pub fn clear_acceptedInEpoch(&mut self) {
        self.acceptedInEpoch = ::std::option::Option::None;
    }

    pub fn has_acceptedInEpoch(&self) -> bool {
        self.acceptedInEpoch.is_some()
    }

    // Param is passed by value, moved
    pub fn set_acceptedInEpoch(&mut self, v: u64) {
        self.acceptedInEpoch = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for PersistedRecoveryPaxosData {
    fn is_initialized(&self) -> bool {
        if self.segmentState.is_none() {
            return false;
        }
        if self.acceptedInEpoch.is_none() {
            return false;
        }
        for v in &self.segmentState {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.segmentState)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.acceptedInEpoch = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.segmentState.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.acceptedInEpoch {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.segmentState.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.acceptedInEpoch {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PersistedRecoveryPaxosData {
        PersistedRecoveryPaxosData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SegmentStateProto>>(
                "segmentState",
                |m: &PersistedRecoveryPaxosData| { &m.segmentState },
                |m: &mut PersistedRecoveryPaxosData| { &mut m.segmentState },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "acceptedInEpoch",
                |m: &PersistedRecoveryPaxosData| { &m.acceptedInEpoch },
                |m: &mut PersistedRecoveryPaxosData| { &mut m.acceptedInEpoch },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PersistedRecoveryPaxosData>(
                "PersistedRecoveryPaxosData",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PersistedRecoveryPaxosData {
        static instance: ::protobuf::rt::LazyV2<PersistedRecoveryPaxosData> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PersistedRecoveryPaxosData::new)
    }
}

impl ::protobuf::Clear for PersistedRecoveryPaxosData {
    fn clear(&mut self) {
        self.segmentState.clear();
        self.acceptedInEpoch = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PersistedRecoveryPaxosData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PersistedRecoveryPaxosData {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct JournalRequestProto {
    // message fields
    pub reqInfo: ::protobuf::SingularPtrField<RequestInfoProto>,
    firstTxnId: ::std::option::Option<u64>,
    numTxns: ::std::option::Option<u32>,
    records: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    segmentTxnId: ::std::option::Option<u64>,
    nameServiceId: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a JournalRequestProto {
    fn default() -> &'a JournalRequestProto {
        <JournalRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl JournalRequestProto {
    pub fn new() -> JournalRequestProto {
        ::std::default::Default::default()
    }

    // required .hadoop.hdfs.RequestInfoProto reqInfo = 1;


    pub fn get_reqInfo(&self) -> &RequestInfoProto {
        self.reqInfo.as_ref().unwrap_or_else(|| <RequestInfoProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_reqInfo(&mut self) {
        self.reqInfo.clear();
    }

    pub fn has_reqInfo(&self) -> bool {
        self.reqInfo.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reqInfo(&mut self, v: RequestInfoProto) {
        self.reqInfo = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reqInfo(&mut self) -> &mut RequestInfoProto {
        if self.reqInfo.is_none() {
            self.reqInfo.set_default();
        }
        self.reqInfo.as_mut().unwrap()
    }

    // Take field
    pub fn take_reqInfo(&mut self) -> RequestInfoProto {
        self.reqInfo.take().unwrap_or_else(|| RequestInfoProto::new())
    }

    // required uint64 firstTxnId = 2;


    pub fn get_firstTxnId(&self) -> u64 {
        self.firstTxnId.unwrap_or(0)
    }
    pub fn clear_firstTxnId(&mut self) {
        self.firstTxnId = ::std::option::Option::None;
    }

    pub fn has_firstTxnId(&self) -> bool {
        self.firstTxnId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_firstTxnId(&mut self, v: u64) {
        self.firstTxnId = ::std::option::Option::Some(v);
    }

    // required uint32 numTxns = 3;


    pub fn get_numTxns(&self) -> u32 {
        self.numTxns.unwrap_or(0)
    }
    pub fn clear_numTxns(&mut self) {
        self.numTxns = ::std::option::Option::None;
    }

    pub fn has_numTxns(&self) -> bool {
        self.numTxns.is_some()
    }

    // Param is passed by value, moved
    pub fn set_numTxns(&mut self, v: u32) {
        self.numTxns = ::std::option::Option::Some(v);
    }

    // required bytes records = 4;


    pub fn get_records(&self) -> &[u8] {
        match self.records.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_records(&mut self) {
        self.records.clear();
    }

    pub fn has_records(&self) -> bool {
        self.records.is_some()
    }

    // Param is passed by value, moved
    pub fn set_records(&mut self, v: ::std::vec::Vec<u8>) {
        self.records = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_records(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.records.is_none() {
            self.records.set_default();
        }
        self.records.as_mut().unwrap()
    }

    // Take field
    pub fn take_records(&mut self) -> ::std::vec::Vec<u8> {
        self.records.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // required uint64 segmentTxnId = 5;


    pub fn get_segmentTxnId(&self) -> u64 {
        self.segmentTxnId.unwrap_or(0)
    }
    pub fn clear_segmentTxnId(&mut self) {
        self.segmentTxnId = ::std::option::Option::None;
    }

    pub fn has_segmentTxnId(&self) -> bool {
        self.segmentTxnId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_segmentTxnId(&mut self, v: u64) {
        self.segmentTxnId = ::std::option::Option::Some(v);
    }

    // optional string nameServiceId = 6;


    pub fn get_nameServiceId(&self) -> &str {
        match self.nameServiceId.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_nameServiceId(&mut self) {
        self.nameServiceId.clear();
    }

    pub fn has_nameServiceId(&self) -> bool {
        self.nameServiceId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nameServiceId(&mut self, v: ::std::string::String) {
        self.nameServiceId = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_nameServiceId(&mut self) -> &mut ::std::string::String {
        if self.nameServiceId.is_none() {
            self.nameServiceId.set_default();
        }
        self.nameServiceId.as_mut().unwrap()
    }

    // Take field
    pub fn take_nameServiceId(&mut self) -> ::std::string::String {
        self.nameServiceId.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for JournalRequestProto {
    fn is_initialized(&self) -> bool {
        if self.reqInfo.is_none() {
            return false;
        }
        if self.firstTxnId.is_none() {
            return false;
        }
        if self.numTxns.is_none() {
            return false;
        }
        if self.records.is_none() {
            return false;
        }
        if self.segmentTxnId.is_none() {
            return false;
        }
        for v in &self.reqInfo {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.reqInfo)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.firstTxnId = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.numTxns = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.records)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.segmentTxnId = ::std::option::Option::Some(tmp);
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.nameServiceId)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.reqInfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.firstTxnId {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.numTxns {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.records.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        if let Some(v) = self.segmentTxnId {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.nameServiceId.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.reqInfo.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.firstTxnId {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.numTxns {
            os.write_uint32(3, v)?;
        }
        if let Some(ref v) = self.records.as_ref() {
            os.write_bytes(4, &v)?;
        }
        if let Some(v) = self.segmentTxnId {
            os.write_uint64(5, v)?;
        }
        if let Some(ref v) = self.nameServiceId.as_ref() {
            os.write_string(6, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> JournalRequestProto {
        JournalRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RequestInfoProto>>(
                "reqInfo",
                |m: &JournalRequestProto| { &m.reqInfo },
                |m: &mut JournalRequestProto| { &mut m.reqInfo },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "firstTxnId",
                |m: &JournalRequestProto| { &m.firstTxnId },
                |m: &mut JournalRequestProto| { &mut m.firstTxnId },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "numTxns",
                |m: &JournalRequestProto| { &m.numTxns },
                |m: &mut JournalRequestProto| { &mut m.numTxns },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "records",
                |m: &JournalRequestProto| { &m.records },
                |m: &mut JournalRequestProto| { &mut m.records },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "segmentTxnId",
                |m: &JournalRequestProto| { &m.segmentTxnId },
                |m: &mut JournalRequestProto| { &mut m.segmentTxnId },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "nameServiceId",
                |m: &JournalRequestProto| { &m.nameServiceId },
                |m: &mut JournalRequestProto| { &mut m.nameServiceId },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<JournalRequestProto>(
                "JournalRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static JournalRequestProto {
        static instance: ::protobuf::rt::LazyV2<JournalRequestProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(JournalRequestProto::new)
    }
}

impl ::protobuf::Clear for JournalRequestProto {
    fn clear(&mut self) {
        self.reqInfo.clear();
        self.firstTxnId = ::std::option::Option::None;
        self.numTxns = ::std::option::Option::None;
        self.records.clear();
        self.segmentTxnId = ::std::option::Option::None;
        self.nameServiceId.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for JournalRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for JournalRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct JournalResponseProto {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a JournalResponseProto {
    fn default() -> &'a JournalResponseProto {
        <JournalResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl JournalResponseProto {
    pub fn new() -> JournalResponseProto {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for JournalResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> JournalResponseProto {
        JournalResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<JournalResponseProto>(
                "JournalResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static JournalResponseProto {
        static instance: ::protobuf::rt::LazyV2<JournalResponseProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(JournalResponseProto::new)
    }
}

impl ::protobuf::Clear for JournalResponseProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for JournalResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for JournalResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct HeartbeatRequestProto {
    // message fields
    pub reqInfo: ::protobuf::SingularPtrField<RequestInfoProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a HeartbeatRequestProto {
    fn default() -> &'a HeartbeatRequestProto {
        <HeartbeatRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl HeartbeatRequestProto {
    pub fn new() -> HeartbeatRequestProto {
        ::std::default::Default::default()
    }

    // required .hadoop.hdfs.RequestInfoProto reqInfo = 1;


    pub fn get_reqInfo(&self) -> &RequestInfoProto {
        self.reqInfo.as_ref().unwrap_or_else(|| <RequestInfoProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_reqInfo(&mut self) {
        self.reqInfo.clear();
    }

    pub fn has_reqInfo(&self) -> bool {
        self.reqInfo.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reqInfo(&mut self, v: RequestInfoProto) {
        self.reqInfo = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reqInfo(&mut self) -> &mut RequestInfoProto {
        if self.reqInfo.is_none() {
            self.reqInfo.set_default();
        }
        self.reqInfo.as_mut().unwrap()
    }

    // Take field
    pub fn take_reqInfo(&mut self) -> RequestInfoProto {
        self.reqInfo.take().unwrap_or_else(|| RequestInfoProto::new())
    }
}

impl ::protobuf::Message for HeartbeatRequestProto {
    fn is_initialized(&self) -> bool {
        if self.reqInfo.is_none() {
            return false;
        }
        for v in &self.reqInfo {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.reqInfo)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.reqInfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.reqInfo.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> HeartbeatRequestProto {
        HeartbeatRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RequestInfoProto>>(
                "reqInfo",
                |m: &HeartbeatRequestProto| { &m.reqInfo },
                |m: &mut HeartbeatRequestProto| { &mut m.reqInfo },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<HeartbeatRequestProto>(
                "HeartbeatRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static HeartbeatRequestProto {
        static instance: ::protobuf::rt::LazyV2<HeartbeatRequestProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(HeartbeatRequestProto::new)
    }
}

impl ::protobuf::Clear for HeartbeatRequestProto {
    fn clear(&mut self) {
        self.reqInfo.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for HeartbeatRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HeartbeatRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct HeartbeatResponseProto {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a HeartbeatResponseProto {
    fn default() -> &'a HeartbeatResponseProto {
        <HeartbeatResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl HeartbeatResponseProto {
    pub fn new() -> HeartbeatResponseProto {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for HeartbeatResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> HeartbeatResponseProto {
        HeartbeatResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<HeartbeatResponseProto>(
                "HeartbeatResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static HeartbeatResponseProto {
        static instance: ::protobuf::rt::LazyV2<HeartbeatResponseProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(HeartbeatResponseProto::new)
    }
}

impl ::protobuf::Clear for HeartbeatResponseProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for HeartbeatResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HeartbeatResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StartLogSegmentRequestProto {
    // message fields
    pub reqInfo: ::protobuf::SingularPtrField<RequestInfoProto>,
    txid: ::std::option::Option<u64>,
    layoutVersion: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StartLogSegmentRequestProto {
    fn default() -> &'a StartLogSegmentRequestProto {
        <StartLogSegmentRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl StartLogSegmentRequestProto {
    pub fn new() -> StartLogSegmentRequestProto {
        ::std::default::Default::default()
    }

    // required .hadoop.hdfs.RequestInfoProto reqInfo = 1;


    pub fn get_reqInfo(&self) -> &RequestInfoProto {
        self.reqInfo.as_ref().unwrap_or_else(|| <RequestInfoProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_reqInfo(&mut self) {
        self.reqInfo.clear();
    }

    pub fn has_reqInfo(&self) -> bool {
        self.reqInfo.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reqInfo(&mut self, v: RequestInfoProto) {
        self.reqInfo = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reqInfo(&mut self) -> &mut RequestInfoProto {
        if self.reqInfo.is_none() {
            self.reqInfo.set_default();
        }
        self.reqInfo.as_mut().unwrap()
    }

    // Take field
    pub fn take_reqInfo(&mut self) -> RequestInfoProto {
        self.reqInfo.take().unwrap_or_else(|| RequestInfoProto::new())
    }

    // required uint64 txid = 2;


    pub fn get_txid(&self) -> u64 {
        self.txid.unwrap_or(0)
    }
    pub fn clear_txid(&mut self) {
        self.txid = ::std::option::Option::None;
    }

    pub fn has_txid(&self) -> bool {
        self.txid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_txid(&mut self, v: u64) {
        self.txid = ::std::option::Option::Some(v);
    }

    // optional sint32 layoutVersion = 3;


    pub fn get_layoutVersion(&self) -> i32 {
        self.layoutVersion.unwrap_or(0)
    }
    pub fn clear_layoutVersion(&mut self) {
        self.layoutVersion = ::std::option::Option::None;
    }

    pub fn has_layoutVersion(&self) -> bool {
        self.layoutVersion.is_some()
    }

    // Param is passed by value, moved
    pub fn set_layoutVersion(&mut self, v: i32) {
        self.layoutVersion = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for StartLogSegmentRequestProto {
    fn is_initialized(&self) -> bool {
        if self.reqInfo.is_none() {
            return false;
        }
        if self.txid.is_none() {
            return false;
        }
        for v in &self.reqInfo {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.reqInfo)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.txid = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint32()?;
                    self.layoutVersion = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.reqInfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.txid {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.layoutVersion {
            my_size += ::protobuf::rt::value_varint_zigzag_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.reqInfo.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.txid {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.layoutVersion {
            os.write_sint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StartLogSegmentRequestProto {
        StartLogSegmentRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RequestInfoProto>>(
                "reqInfo",
                |m: &StartLogSegmentRequestProto| { &m.reqInfo },
                |m: &mut StartLogSegmentRequestProto| { &mut m.reqInfo },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "txid",
                |m: &StartLogSegmentRequestProto| { &m.txid },
                |m: &mut StartLogSegmentRequestProto| { &mut m.txid },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeSint32>(
                "layoutVersion",
                |m: &StartLogSegmentRequestProto| { &m.layoutVersion },
                |m: &mut StartLogSegmentRequestProto| { &mut m.layoutVersion },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<StartLogSegmentRequestProto>(
                "StartLogSegmentRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static StartLogSegmentRequestProto {
        static instance: ::protobuf::rt::LazyV2<StartLogSegmentRequestProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(StartLogSegmentRequestProto::new)
    }
}

impl ::protobuf::Clear for StartLogSegmentRequestProto {
    fn clear(&mut self) {
        self.reqInfo.clear();
        self.txid = ::std::option::Option::None;
        self.layoutVersion = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StartLogSegmentRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StartLogSegmentRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StartLogSegmentResponseProto {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StartLogSegmentResponseProto {
    fn default() -> &'a StartLogSegmentResponseProto {
        <StartLogSegmentResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl StartLogSegmentResponseProto {
    pub fn new() -> StartLogSegmentResponseProto {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for StartLogSegmentResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StartLogSegmentResponseProto {
        StartLogSegmentResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<StartLogSegmentResponseProto>(
                "StartLogSegmentResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static StartLogSegmentResponseProto {
        static instance: ::protobuf::rt::LazyV2<StartLogSegmentResponseProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(StartLogSegmentResponseProto::new)
    }
}

impl ::protobuf::Clear for StartLogSegmentResponseProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StartLogSegmentResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StartLogSegmentResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FinalizeLogSegmentRequestProto {
    // message fields
    pub reqInfo: ::protobuf::SingularPtrField<RequestInfoProto>,
    startTxId: ::std::option::Option<u64>,
    endTxId: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FinalizeLogSegmentRequestProto {
    fn default() -> &'a FinalizeLogSegmentRequestProto {
        <FinalizeLogSegmentRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl FinalizeLogSegmentRequestProto {
    pub fn new() -> FinalizeLogSegmentRequestProto {
        ::std::default::Default::default()
    }

    // required .hadoop.hdfs.RequestInfoProto reqInfo = 1;


    pub fn get_reqInfo(&self) -> &RequestInfoProto {
        self.reqInfo.as_ref().unwrap_or_else(|| <RequestInfoProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_reqInfo(&mut self) {
        self.reqInfo.clear();
    }

    pub fn has_reqInfo(&self) -> bool {
        self.reqInfo.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reqInfo(&mut self, v: RequestInfoProto) {
        self.reqInfo = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reqInfo(&mut self) -> &mut RequestInfoProto {
        if self.reqInfo.is_none() {
            self.reqInfo.set_default();
        }
        self.reqInfo.as_mut().unwrap()
    }

    // Take field
    pub fn take_reqInfo(&mut self) -> RequestInfoProto {
        self.reqInfo.take().unwrap_or_else(|| RequestInfoProto::new())
    }

    // required uint64 startTxId = 2;


    pub fn get_startTxId(&self) -> u64 {
        self.startTxId.unwrap_or(0)
    }
    pub fn clear_startTxId(&mut self) {
        self.startTxId = ::std::option::Option::None;
    }

    pub fn has_startTxId(&self) -> bool {
        self.startTxId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_startTxId(&mut self, v: u64) {
        self.startTxId = ::std::option::Option::Some(v);
    }

    // required uint64 endTxId = 3;


    pub fn get_endTxId(&self) -> u64 {
        self.endTxId.unwrap_or(0)
    }
    pub fn clear_endTxId(&mut self) {
        self.endTxId = ::std::option::Option::None;
    }

    pub fn has_endTxId(&self) -> bool {
        self.endTxId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_endTxId(&mut self, v: u64) {
        self.endTxId = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for FinalizeLogSegmentRequestProto {
    fn is_initialized(&self) -> bool {
        if self.reqInfo.is_none() {
            return false;
        }
        if self.startTxId.is_none() {
            return false;
        }
        if self.endTxId.is_none() {
            return false;
        }
        for v in &self.reqInfo {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.reqInfo)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.startTxId = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.endTxId = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.reqInfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.startTxId {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.endTxId {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.reqInfo.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.startTxId {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.endTxId {
            os.write_uint64(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FinalizeLogSegmentRequestProto {
        FinalizeLogSegmentRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RequestInfoProto>>(
                "reqInfo",
                |m: &FinalizeLogSegmentRequestProto| { &m.reqInfo },
                |m: &mut FinalizeLogSegmentRequestProto| { &mut m.reqInfo },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "startTxId",
                |m: &FinalizeLogSegmentRequestProto| { &m.startTxId },
                |m: &mut FinalizeLogSegmentRequestProto| { &mut m.startTxId },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "endTxId",
                |m: &FinalizeLogSegmentRequestProto| { &m.endTxId },
                |m: &mut FinalizeLogSegmentRequestProto| { &mut m.endTxId },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<FinalizeLogSegmentRequestProto>(
                "FinalizeLogSegmentRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static FinalizeLogSegmentRequestProto {
        static instance: ::protobuf::rt::LazyV2<FinalizeLogSegmentRequestProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(FinalizeLogSegmentRequestProto::new)
    }
}

impl ::protobuf::Clear for FinalizeLogSegmentRequestProto {
    fn clear(&mut self) {
        self.reqInfo.clear();
        self.startTxId = ::std::option::Option::None;
        self.endTxId = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FinalizeLogSegmentRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FinalizeLogSegmentRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FinalizeLogSegmentResponseProto {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FinalizeLogSegmentResponseProto {
    fn default() -> &'a FinalizeLogSegmentResponseProto {
        <FinalizeLogSegmentResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl FinalizeLogSegmentResponseProto {
    pub fn new() -> FinalizeLogSegmentResponseProto {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for FinalizeLogSegmentResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FinalizeLogSegmentResponseProto {
        FinalizeLogSegmentResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<FinalizeLogSegmentResponseProto>(
                "FinalizeLogSegmentResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static FinalizeLogSegmentResponseProto {
        static instance: ::protobuf::rt::LazyV2<FinalizeLogSegmentResponseProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(FinalizeLogSegmentResponseProto::new)
    }
}

impl ::protobuf::Clear for FinalizeLogSegmentResponseProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FinalizeLogSegmentResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FinalizeLogSegmentResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PurgeLogsRequestProto {
    // message fields
    pub reqInfo: ::protobuf::SingularPtrField<RequestInfoProto>,
    minTxIdToKeep: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PurgeLogsRequestProto {
    fn default() -> &'a PurgeLogsRequestProto {
        <PurgeLogsRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl PurgeLogsRequestProto {
    pub fn new() -> PurgeLogsRequestProto {
        ::std::default::Default::default()
    }

    // required .hadoop.hdfs.RequestInfoProto reqInfo = 1;


    pub fn get_reqInfo(&self) -> &RequestInfoProto {
        self.reqInfo.as_ref().unwrap_or_else(|| <RequestInfoProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_reqInfo(&mut self) {
        self.reqInfo.clear();
    }

    pub fn has_reqInfo(&self) -> bool {
        self.reqInfo.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reqInfo(&mut self, v: RequestInfoProto) {
        self.reqInfo = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reqInfo(&mut self) -> &mut RequestInfoProto {
        if self.reqInfo.is_none() {
            self.reqInfo.set_default();
        }
        self.reqInfo.as_mut().unwrap()
    }

    // Take field
    pub fn take_reqInfo(&mut self) -> RequestInfoProto {
        self.reqInfo.take().unwrap_or_else(|| RequestInfoProto::new())
    }

    // required uint64 minTxIdToKeep = 2;


    pub fn get_minTxIdToKeep(&self) -> u64 {
        self.minTxIdToKeep.unwrap_or(0)
    }
    pub fn clear_minTxIdToKeep(&mut self) {
        self.minTxIdToKeep = ::std::option::Option::None;
    }

    pub fn has_minTxIdToKeep(&self) -> bool {
        self.minTxIdToKeep.is_some()
    }

    // Param is passed by value, moved
    pub fn set_minTxIdToKeep(&mut self, v: u64) {
        self.minTxIdToKeep = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for PurgeLogsRequestProto {
    fn is_initialized(&self) -> bool {
        if self.reqInfo.is_none() {
            return false;
        }
        if self.minTxIdToKeep.is_none() {
            return false;
        }
        for v in &self.reqInfo {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.reqInfo)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.minTxIdToKeep = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.reqInfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.minTxIdToKeep {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.reqInfo.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.minTxIdToKeep {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PurgeLogsRequestProto {
        PurgeLogsRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RequestInfoProto>>(
                "reqInfo",
                |m: &PurgeLogsRequestProto| { &m.reqInfo },
                |m: &mut PurgeLogsRequestProto| { &mut m.reqInfo },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "minTxIdToKeep",
                |m: &PurgeLogsRequestProto| { &m.minTxIdToKeep },
                |m: &mut PurgeLogsRequestProto| { &mut m.minTxIdToKeep },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PurgeLogsRequestProto>(
                "PurgeLogsRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PurgeLogsRequestProto {
        static instance: ::protobuf::rt::LazyV2<PurgeLogsRequestProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PurgeLogsRequestProto::new)
    }
}

impl ::protobuf::Clear for PurgeLogsRequestProto {
    fn clear(&mut self) {
        self.reqInfo.clear();
        self.minTxIdToKeep = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PurgeLogsRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PurgeLogsRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PurgeLogsResponseProto {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PurgeLogsResponseProto {
    fn default() -> &'a PurgeLogsResponseProto {
        <PurgeLogsResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl PurgeLogsResponseProto {
    pub fn new() -> PurgeLogsResponseProto {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for PurgeLogsResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PurgeLogsResponseProto {
        PurgeLogsResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PurgeLogsResponseProto>(
                "PurgeLogsResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PurgeLogsResponseProto {
        static instance: ::protobuf::rt::LazyV2<PurgeLogsResponseProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PurgeLogsResponseProto::new)
    }
}

impl ::protobuf::Clear for PurgeLogsResponseProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PurgeLogsResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PurgeLogsResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct IsFormattedRequestProto {
    // message fields
    pub jid: ::protobuf::SingularPtrField<JournalIdProto>,
    nameServiceId: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a IsFormattedRequestProto {
    fn default() -> &'a IsFormattedRequestProto {
        <IsFormattedRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl IsFormattedRequestProto {
    pub fn new() -> IsFormattedRequestProto {
        ::std::default::Default::default()
    }

    // required .hadoop.hdfs.JournalIdProto jid = 1;


    pub fn get_jid(&self) -> &JournalIdProto {
        self.jid.as_ref().unwrap_or_else(|| <JournalIdProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_jid(&mut self) {
        self.jid.clear();
    }

    pub fn has_jid(&self) -> bool {
        self.jid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_jid(&mut self, v: JournalIdProto) {
        self.jid = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_jid(&mut self) -> &mut JournalIdProto {
        if self.jid.is_none() {
            self.jid.set_default();
        }
        self.jid.as_mut().unwrap()
    }

    // Take field
    pub fn take_jid(&mut self) -> JournalIdProto {
        self.jid.take().unwrap_or_else(|| JournalIdProto::new())
    }

    // optional string nameServiceId = 2;


    pub fn get_nameServiceId(&self) -> &str {
        match self.nameServiceId.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_nameServiceId(&mut self) {
        self.nameServiceId.clear();
    }

    pub fn has_nameServiceId(&self) -> bool {
        self.nameServiceId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nameServiceId(&mut self, v: ::std::string::String) {
        self.nameServiceId = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_nameServiceId(&mut self) -> &mut ::std::string::String {
        if self.nameServiceId.is_none() {
            self.nameServiceId.set_default();
        }
        self.nameServiceId.as_mut().unwrap()
    }

    // Take field
    pub fn take_nameServiceId(&mut self) -> ::std::string::String {
        self.nameServiceId.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for IsFormattedRequestProto {
    fn is_initialized(&self) -> bool {
        if self.jid.is_none() {
            return false;
        }
        for v in &self.jid {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.jid)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.nameServiceId)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.jid.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.nameServiceId.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.jid.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.nameServiceId.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> IsFormattedRequestProto {
        IsFormattedRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<JournalIdProto>>(
                "jid",
                |m: &IsFormattedRequestProto| { &m.jid },
                |m: &mut IsFormattedRequestProto| { &mut m.jid },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "nameServiceId",
                |m: &IsFormattedRequestProto| { &m.nameServiceId },
                |m: &mut IsFormattedRequestProto| { &mut m.nameServiceId },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<IsFormattedRequestProto>(
                "IsFormattedRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static IsFormattedRequestProto {
        static instance: ::protobuf::rt::LazyV2<IsFormattedRequestProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(IsFormattedRequestProto::new)
    }
}

impl ::protobuf::Clear for IsFormattedRequestProto {
    fn clear(&mut self) {
        self.jid.clear();
        self.nameServiceId.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for IsFormattedRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for IsFormattedRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct IsFormattedResponseProto {
    // message fields
    isFormatted: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a IsFormattedResponseProto {
    fn default() -> &'a IsFormattedResponseProto {
        <IsFormattedResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl IsFormattedResponseProto {
    pub fn new() -> IsFormattedResponseProto {
        ::std::default::Default::default()
    }

    // required bool isFormatted = 1;


    pub fn get_isFormatted(&self) -> bool {
        self.isFormatted.unwrap_or(false)
    }
    pub fn clear_isFormatted(&mut self) {
        self.isFormatted = ::std::option::Option::None;
    }

    pub fn has_isFormatted(&self) -> bool {
        self.isFormatted.is_some()
    }

    // Param is passed by value, moved
    pub fn set_isFormatted(&mut self, v: bool) {
        self.isFormatted = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for IsFormattedResponseProto {
    fn is_initialized(&self) -> bool {
        if self.isFormatted.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.isFormatted = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.isFormatted {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.isFormatted {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> IsFormattedResponseProto {
        IsFormattedResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "isFormatted",
                |m: &IsFormattedResponseProto| { &m.isFormatted },
                |m: &mut IsFormattedResponseProto| { &mut m.isFormatted },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<IsFormattedResponseProto>(
                "IsFormattedResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static IsFormattedResponseProto {
        static instance: ::protobuf::rt::LazyV2<IsFormattedResponseProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(IsFormattedResponseProto::new)
    }
}

impl ::protobuf::Clear for IsFormattedResponseProto {
    fn clear(&mut self) {
        self.isFormatted = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for IsFormattedResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for IsFormattedResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetJournalCTimeRequestProto {
    // message fields
    pub jid: ::protobuf::SingularPtrField<JournalIdProto>,
    nameServiceId: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetJournalCTimeRequestProto {
    fn default() -> &'a GetJournalCTimeRequestProto {
        <GetJournalCTimeRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl GetJournalCTimeRequestProto {
    pub fn new() -> GetJournalCTimeRequestProto {
        ::std::default::Default::default()
    }

    // required .hadoop.hdfs.JournalIdProto jid = 1;


    pub fn get_jid(&self) -> &JournalIdProto {
        self.jid.as_ref().unwrap_or_else(|| <JournalIdProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_jid(&mut self) {
        self.jid.clear();
    }

    pub fn has_jid(&self) -> bool {
        self.jid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_jid(&mut self, v: JournalIdProto) {
        self.jid = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_jid(&mut self) -> &mut JournalIdProto {
        if self.jid.is_none() {
            self.jid.set_default();
        }
        self.jid.as_mut().unwrap()
    }

    // Take field
    pub fn take_jid(&mut self) -> JournalIdProto {
        self.jid.take().unwrap_or_else(|| JournalIdProto::new())
    }

    // optional string nameServiceId = 2;


    pub fn get_nameServiceId(&self) -> &str {
        match self.nameServiceId.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_nameServiceId(&mut self) {
        self.nameServiceId.clear();
    }

    pub fn has_nameServiceId(&self) -> bool {
        self.nameServiceId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nameServiceId(&mut self, v: ::std::string::String) {
        self.nameServiceId = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_nameServiceId(&mut self) -> &mut ::std::string::String {
        if self.nameServiceId.is_none() {
            self.nameServiceId.set_default();
        }
        self.nameServiceId.as_mut().unwrap()
    }

    // Take field
    pub fn take_nameServiceId(&mut self) -> ::std::string::String {
        self.nameServiceId.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for GetJournalCTimeRequestProto {
    fn is_initialized(&self) -> bool {
        if self.jid.is_none() {
            return false;
        }
        for v in &self.jid {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.jid)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.nameServiceId)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.jid.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.nameServiceId.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.jid.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.nameServiceId.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetJournalCTimeRequestProto {
        GetJournalCTimeRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<JournalIdProto>>(
                "jid",
                |m: &GetJournalCTimeRequestProto| { &m.jid },
                |m: &mut GetJournalCTimeRequestProto| { &mut m.jid },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "nameServiceId",
                |m: &GetJournalCTimeRequestProto| { &m.nameServiceId },
                |m: &mut GetJournalCTimeRequestProto| { &mut m.nameServiceId },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetJournalCTimeRequestProto>(
                "GetJournalCTimeRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetJournalCTimeRequestProto {
        static instance: ::protobuf::rt::LazyV2<GetJournalCTimeRequestProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetJournalCTimeRequestProto::new)
    }
}

impl ::protobuf::Clear for GetJournalCTimeRequestProto {
    fn clear(&mut self) {
        self.jid.clear();
        self.nameServiceId.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetJournalCTimeRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetJournalCTimeRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetJournalCTimeResponseProto {
    // message fields
    resultCTime: ::std::option::Option<i64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetJournalCTimeResponseProto {
    fn default() -> &'a GetJournalCTimeResponseProto {
        <GetJournalCTimeResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl GetJournalCTimeResponseProto {
    pub fn new() -> GetJournalCTimeResponseProto {
        ::std::default::Default::default()
    }

    // required int64 resultCTime = 1;


    pub fn get_resultCTime(&self) -> i64 {
        self.resultCTime.unwrap_or(0)
    }
    pub fn clear_resultCTime(&mut self) {
        self.resultCTime = ::std::option::Option::None;
    }

    pub fn has_resultCTime(&self) -> bool {
        self.resultCTime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_resultCTime(&mut self, v: i64) {
        self.resultCTime = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for GetJournalCTimeResponseProto {
    fn is_initialized(&self) -> bool {
        if self.resultCTime.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.resultCTime = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.resultCTime {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.resultCTime {
            os.write_int64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetJournalCTimeResponseProto {
        GetJournalCTimeResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "resultCTime",
                |m: &GetJournalCTimeResponseProto| { &m.resultCTime },
                |m: &mut GetJournalCTimeResponseProto| { &mut m.resultCTime },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetJournalCTimeResponseProto>(
                "GetJournalCTimeResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetJournalCTimeResponseProto {
        static instance: ::protobuf::rt::LazyV2<GetJournalCTimeResponseProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetJournalCTimeResponseProto::new)
    }
}

impl ::protobuf::Clear for GetJournalCTimeResponseProto {
    fn clear(&mut self) {
        self.resultCTime = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetJournalCTimeResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetJournalCTimeResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DoPreUpgradeRequestProto {
    // message fields
    pub jid: ::protobuf::SingularPtrField<JournalIdProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DoPreUpgradeRequestProto {
    fn default() -> &'a DoPreUpgradeRequestProto {
        <DoPreUpgradeRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl DoPreUpgradeRequestProto {
    pub fn new() -> DoPreUpgradeRequestProto {
        ::std::default::Default::default()
    }

    // required .hadoop.hdfs.JournalIdProto jid = 1;


    pub fn get_jid(&self) -> &JournalIdProto {
        self.jid.as_ref().unwrap_or_else(|| <JournalIdProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_jid(&mut self) {
        self.jid.clear();
    }

    pub fn has_jid(&self) -> bool {
        self.jid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_jid(&mut self, v: JournalIdProto) {
        self.jid = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_jid(&mut self) -> &mut JournalIdProto {
        if self.jid.is_none() {
            self.jid.set_default();
        }
        self.jid.as_mut().unwrap()
    }

    // Take field
    pub fn take_jid(&mut self) -> JournalIdProto {
        self.jid.take().unwrap_or_else(|| JournalIdProto::new())
    }
}

impl ::protobuf::Message for DoPreUpgradeRequestProto {
    fn is_initialized(&self) -> bool {
        if self.jid.is_none() {
            return false;
        }
        for v in &self.jid {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.jid)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.jid.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.jid.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DoPreUpgradeRequestProto {
        DoPreUpgradeRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<JournalIdProto>>(
                "jid",
                |m: &DoPreUpgradeRequestProto| { &m.jid },
                |m: &mut DoPreUpgradeRequestProto| { &mut m.jid },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DoPreUpgradeRequestProto>(
                "DoPreUpgradeRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DoPreUpgradeRequestProto {
        static instance: ::protobuf::rt::LazyV2<DoPreUpgradeRequestProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DoPreUpgradeRequestProto::new)
    }
}

impl ::protobuf::Clear for DoPreUpgradeRequestProto {
    fn clear(&mut self) {
        self.jid.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DoPreUpgradeRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DoPreUpgradeRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DoPreUpgradeResponseProto {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DoPreUpgradeResponseProto {
    fn default() -> &'a DoPreUpgradeResponseProto {
        <DoPreUpgradeResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl DoPreUpgradeResponseProto {
    pub fn new() -> DoPreUpgradeResponseProto {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for DoPreUpgradeResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DoPreUpgradeResponseProto {
        DoPreUpgradeResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DoPreUpgradeResponseProto>(
                "DoPreUpgradeResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DoPreUpgradeResponseProto {
        static instance: ::protobuf::rt::LazyV2<DoPreUpgradeResponseProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DoPreUpgradeResponseProto::new)
    }
}

impl ::protobuf::Clear for DoPreUpgradeResponseProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DoPreUpgradeResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DoPreUpgradeResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DoUpgradeRequestProto {
    // message fields
    pub jid: ::protobuf::SingularPtrField<JournalIdProto>,
    pub sInfo: ::protobuf::SingularPtrField<super::HdfsServer::StorageInfoProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DoUpgradeRequestProto {
    fn default() -> &'a DoUpgradeRequestProto {
        <DoUpgradeRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl DoUpgradeRequestProto {
    pub fn new() -> DoUpgradeRequestProto {
        ::std::default::Default::default()
    }

    // required .hadoop.hdfs.JournalIdProto jid = 1;


    pub fn get_jid(&self) -> &JournalIdProto {
        self.jid.as_ref().unwrap_or_else(|| <JournalIdProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_jid(&mut self) {
        self.jid.clear();
    }

    pub fn has_jid(&self) -> bool {
        self.jid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_jid(&mut self, v: JournalIdProto) {
        self.jid = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_jid(&mut self) -> &mut JournalIdProto {
        if self.jid.is_none() {
            self.jid.set_default();
        }
        self.jid.as_mut().unwrap()
    }

    // Take field
    pub fn take_jid(&mut self) -> JournalIdProto {
        self.jid.take().unwrap_or_else(|| JournalIdProto::new())
    }

    // required .hadoop.hdfs.StorageInfoProto sInfo = 2;


    pub fn get_sInfo(&self) -> &super::HdfsServer::StorageInfoProto {
        self.sInfo.as_ref().unwrap_or_else(|| <super::HdfsServer::StorageInfoProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_sInfo(&mut self) {
        self.sInfo.clear();
    }

    pub fn has_sInfo(&self) -> bool {
        self.sInfo.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sInfo(&mut self, v: super::HdfsServer::StorageInfoProto) {
        self.sInfo = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sInfo(&mut self) -> &mut super::HdfsServer::StorageInfoProto {
        if self.sInfo.is_none() {
            self.sInfo.set_default();
        }
        self.sInfo.as_mut().unwrap()
    }

    // Take field
    pub fn take_sInfo(&mut self) -> super::HdfsServer::StorageInfoProto {
        self.sInfo.take().unwrap_or_else(|| super::HdfsServer::StorageInfoProto::new())
    }
}

impl ::protobuf::Message for DoUpgradeRequestProto {
    fn is_initialized(&self) -> bool {
        if self.jid.is_none() {
            return false;
        }
        if self.sInfo.is_none() {
            return false;
        }
        for v in &self.jid {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.sInfo {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.jid)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.sInfo)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.jid.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.sInfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.jid.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.sInfo.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DoUpgradeRequestProto {
        DoUpgradeRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<JournalIdProto>>(
                "jid",
                |m: &DoUpgradeRequestProto| { &m.jid },
                |m: &mut DoUpgradeRequestProto| { &mut m.jid },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::HdfsServer::StorageInfoProto>>(
                "sInfo",
                |m: &DoUpgradeRequestProto| { &m.sInfo },
                |m: &mut DoUpgradeRequestProto| { &mut m.sInfo },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DoUpgradeRequestProto>(
                "DoUpgradeRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DoUpgradeRequestProto {
        static instance: ::protobuf::rt::LazyV2<DoUpgradeRequestProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DoUpgradeRequestProto::new)
    }
}

impl ::protobuf::Clear for DoUpgradeRequestProto {
    fn clear(&mut self) {
        self.jid.clear();
        self.sInfo.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DoUpgradeRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DoUpgradeRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DoUpgradeResponseProto {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DoUpgradeResponseProto {
    fn default() -> &'a DoUpgradeResponseProto {
        <DoUpgradeResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl DoUpgradeResponseProto {
    pub fn new() -> DoUpgradeResponseProto {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for DoUpgradeResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DoUpgradeResponseProto {
        DoUpgradeResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DoUpgradeResponseProto>(
                "DoUpgradeResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DoUpgradeResponseProto {
        static instance: ::protobuf::rt::LazyV2<DoUpgradeResponseProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DoUpgradeResponseProto::new)
    }
}

impl ::protobuf::Clear for DoUpgradeResponseProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DoUpgradeResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DoUpgradeResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DoFinalizeRequestProto {
    // message fields
    pub jid: ::protobuf::SingularPtrField<JournalIdProto>,
    nameServiceId: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DoFinalizeRequestProto {
    fn default() -> &'a DoFinalizeRequestProto {
        <DoFinalizeRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl DoFinalizeRequestProto {
    pub fn new() -> DoFinalizeRequestProto {
        ::std::default::Default::default()
    }

    // required .hadoop.hdfs.JournalIdProto jid = 1;


    pub fn get_jid(&self) -> &JournalIdProto {
        self.jid.as_ref().unwrap_or_else(|| <JournalIdProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_jid(&mut self) {
        self.jid.clear();
    }

    pub fn has_jid(&self) -> bool {
        self.jid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_jid(&mut self, v: JournalIdProto) {
        self.jid = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_jid(&mut self) -> &mut JournalIdProto {
        if self.jid.is_none() {
            self.jid.set_default();
        }
        self.jid.as_mut().unwrap()
    }

    // Take field
    pub fn take_jid(&mut self) -> JournalIdProto {
        self.jid.take().unwrap_or_else(|| JournalIdProto::new())
    }

    // optional string nameServiceId = 2;


    pub fn get_nameServiceId(&self) -> &str {
        match self.nameServiceId.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_nameServiceId(&mut self) {
        self.nameServiceId.clear();
    }

    pub fn has_nameServiceId(&self) -> bool {
        self.nameServiceId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nameServiceId(&mut self, v: ::std::string::String) {
        self.nameServiceId = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_nameServiceId(&mut self) -> &mut ::std::string::String {
        if self.nameServiceId.is_none() {
            self.nameServiceId.set_default();
        }
        self.nameServiceId.as_mut().unwrap()
    }

    // Take field
    pub fn take_nameServiceId(&mut self) -> ::std::string::String {
        self.nameServiceId.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for DoFinalizeRequestProto {
    fn is_initialized(&self) -> bool {
        if self.jid.is_none() {
            return false;
        }
        for v in &self.jid {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.jid)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.nameServiceId)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.jid.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.nameServiceId.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.jid.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.nameServiceId.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DoFinalizeRequestProto {
        DoFinalizeRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<JournalIdProto>>(
                "jid",
                |m: &DoFinalizeRequestProto| { &m.jid },
                |m: &mut DoFinalizeRequestProto| { &mut m.jid },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "nameServiceId",
                |m: &DoFinalizeRequestProto| { &m.nameServiceId },
                |m: &mut DoFinalizeRequestProto| { &mut m.nameServiceId },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DoFinalizeRequestProto>(
                "DoFinalizeRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DoFinalizeRequestProto {
        static instance: ::protobuf::rt::LazyV2<DoFinalizeRequestProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DoFinalizeRequestProto::new)
    }
}

impl ::protobuf::Clear for DoFinalizeRequestProto {
    fn clear(&mut self) {
        self.jid.clear();
        self.nameServiceId.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DoFinalizeRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DoFinalizeRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DoFinalizeResponseProto {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DoFinalizeResponseProto {
    fn default() -> &'a DoFinalizeResponseProto {
        <DoFinalizeResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl DoFinalizeResponseProto {
    pub fn new() -> DoFinalizeResponseProto {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for DoFinalizeResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DoFinalizeResponseProto {
        DoFinalizeResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DoFinalizeResponseProto>(
                "DoFinalizeResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DoFinalizeResponseProto {
        static instance: ::protobuf::rt::LazyV2<DoFinalizeResponseProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DoFinalizeResponseProto::new)
    }
}

impl ::protobuf::Clear for DoFinalizeResponseProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DoFinalizeResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DoFinalizeResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CanRollBackRequestProto {
    // message fields
    pub jid: ::protobuf::SingularPtrField<JournalIdProto>,
    pub storage: ::protobuf::SingularPtrField<super::HdfsServer::StorageInfoProto>,
    pub prevStorage: ::protobuf::SingularPtrField<super::HdfsServer::StorageInfoProto>,
    targetLayoutVersion: ::std::option::Option<i32>,
    nameServiceId: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CanRollBackRequestProto {
    fn default() -> &'a CanRollBackRequestProto {
        <CanRollBackRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl CanRollBackRequestProto {
    pub fn new() -> CanRollBackRequestProto {
        ::std::default::Default::default()
    }

    // required .hadoop.hdfs.JournalIdProto jid = 1;


    pub fn get_jid(&self) -> &JournalIdProto {
        self.jid.as_ref().unwrap_or_else(|| <JournalIdProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_jid(&mut self) {
        self.jid.clear();
    }

    pub fn has_jid(&self) -> bool {
        self.jid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_jid(&mut self, v: JournalIdProto) {
        self.jid = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_jid(&mut self) -> &mut JournalIdProto {
        if self.jid.is_none() {
            self.jid.set_default();
        }
        self.jid.as_mut().unwrap()
    }

    // Take field
    pub fn take_jid(&mut self) -> JournalIdProto {
        self.jid.take().unwrap_or_else(|| JournalIdProto::new())
    }

    // required .hadoop.hdfs.StorageInfoProto storage = 2;


    pub fn get_storage(&self) -> &super::HdfsServer::StorageInfoProto {
        self.storage.as_ref().unwrap_or_else(|| <super::HdfsServer::StorageInfoProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_storage(&mut self) {
        self.storage.clear();
    }

    pub fn has_storage(&self) -> bool {
        self.storage.is_some()
    }

    // Param is passed by value, moved
    pub fn set_storage(&mut self, v: super::HdfsServer::StorageInfoProto) {
        self.storage = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_storage(&mut self) -> &mut super::HdfsServer::StorageInfoProto {
        if self.storage.is_none() {
            self.storage.set_default();
        }
        self.storage.as_mut().unwrap()
    }

    // Take field
    pub fn take_storage(&mut self) -> super::HdfsServer::StorageInfoProto {
        self.storage.take().unwrap_or_else(|| super::HdfsServer::StorageInfoProto::new())
    }

    // required .hadoop.hdfs.StorageInfoProto prevStorage = 3;


    pub fn get_prevStorage(&self) -> &super::HdfsServer::StorageInfoProto {
        self.prevStorage.as_ref().unwrap_or_else(|| <super::HdfsServer::StorageInfoProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_prevStorage(&mut self) {
        self.prevStorage.clear();
    }

    pub fn has_prevStorage(&self) -> bool {
        self.prevStorage.is_some()
    }

    // Param is passed by value, moved
    pub fn set_prevStorage(&mut self, v: super::HdfsServer::StorageInfoProto) {
        self.prevStorage = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_prevStorage(&mut self) -> &mut super::HdfsServer::StorageInfoProto {
        if self.prevStorage.is_none() {
            self.prevStorage.set_default();
        }
        self.prevStorage.as_mut().unwrap()
    }

    // Take field
    pub fn take_prevStorage(&mut self) -> super::HdfsServer::StorageInfoProto {
        self.prevStorage.take().unwrap_or_else(|| super::HdfsServer::StorageInfoProto::new())
    }

    // required int32 targetLayoutVersion = 4;


    pub fn get_targetLayoutVersion(&self) -> i32 {
        self.targetLayoutVersion.unwrap_or(0)
    }
    pub fn clear_targetLayoutVersion(&mut self) {
        self.targetLayoutVersion = ::std::option::Option::None;
    }

    pub fn has_targetLayoutVersion(&self) -> bool {
        self.targetLayoutVersion.is_some()
    }

    // Param is passed by value, moved
    pub fn set_targetLayoutVersion(&mut self, v: i32) {
        self.targetLayoutVersion = ::std::option::Option::Some(v);
    }

    // optional string nameServiceId = 5;


    pub fn get_nameServiceId(&self) -> &str {
        match self.nameServiceId.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_nameServiceId(&mut self) {
        self.nameServiceId.clear();
    }

    pub fn has_nameServiceId(&self) -> bool {
        self.nameServiceId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nameServiceId(&mut self, v: ::std::string::String) {
        self.nameServiceId = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_nameServiceId(&mut self) -> &mut ::std::string::String {
        if self.nameServiceId.is_none() {
            self.nameServiceId.set_default();
        }
        self.nameServiceId.as_mut().unwrap()
    }

    // Take field
    pub fn take_nameServiceId(&mut self) -> ::std::string::String {
        self.nameServiceId.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CanRollBackRequestProto {
    fn is_initialized(&self) -> bool {
        if self.jid.is_none() {
            return false;
        }
        if self.storage.is_none() {
            return false;
        }
        if self.prevStorage.is_none() {
            return false;
        }
        if self.targetLayoutVersion.is_none() {
            return false;
        }
        for v in &self.jid {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.storage {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.prevStorage {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.jid)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.storage)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.prevStorage)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.targetLayoutVersion = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.nameServiceId)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.jid.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.storage.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.prevStorage.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.targetLayoutVersion {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.nameServiceId.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.jid.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.storage.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.prevStorage.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.targetLayoutVersion {
            os.write_int32(4, v)?;
        }
        if let Some(ref v) = self.nameServiceId.as_ref() {
            os.write_string(5, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CanRollBackRequestProto {
        CanRollBackRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<JournalIdProto>>(
                "jid",
                |m: &CanRollBackRequestProto| { &m.jid },
                |m: &mut CanRollBackRequestProto| { &mut m.jid },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::HdfsServer::StorageInfoProto>>(
                "storage",
                |m: &CanRollBackRequestProto| { &m.storage },
                |m: &mut CanRollBackRequestProto| { &mut m.storage },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::HdfsServer::StorageInfoProto>>(
                "prevStorage",
                |m: &CanRollBackRequestProto| { &m.prevStorage },
                |m: &mut CanRollBackRequestProto| { &mut m.prevStorage },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "targetLayoutVersion",
                |m: &CanRollBackRequestProto| { &m.targetLayoutVersion },
                |m: &mut CanRollBackRequestProto| { &mut m.targetLayoutVersion },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "nameServiceId",
                |m: &CanRollBackRequestProto| { &m.nameServiceId },
                |m: &mut CanRollBackRequestProto| { &mut m.nameServiceId },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CanRollBackRequestProto>(
                "CanRollBackRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CanRollBackRequestProto {
        static instance: ::protobuf::rt::LazyV2<CanRollBackRequestProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CanRollBackRequestProto::new)
    }
}

impl ::protobuf::Clear for CanRollBackRequestProto {
    fn clear(&mut self) {
        self.jid.clear();
        self.storage.clear();
        self.prevStorage.clear();
        self.targetLayoutVersion = ::std::option::Option::None;
        self.nameServiceId.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CanRollBackRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CanRollBackRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CanRollBackResponseProto {
    // message fields
    canRollBack: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CanRollBackResponseProto {
    fn default() -> &'a CanRollBackResponseProto {
        <CanRollBackResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl CanRollBackResponseProto {
    pub fn new() -> CanRollBackResponseProto {
        ::std::default::Default::default()
    }

    // required bool canRollBack = 1;


    pub fn get_canRollBack(&self) -> bool {
        self.canRollBack.unwrap_or(false)
    }
    pub fn clear_canRollBack(&mut self) {
        self.canRollBack = ::std::option::Option::None;
    }

    pub fn has_canRollBack(&self) -> bool {
        self.canRollBack.is_some()
    }

    // Param is passed by value, moved
    pub fn set_canRollBack(&mut self, v: bool) {
        self.canRollBack = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CanRollBackResponseProto {
    fn is_initialized(&self) -> bool {
        if self.canRollBack.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.canRollBack = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.canRollBack {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.canRollBack {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CanRollBackResponseProto {
        CanRollBackResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "canRollBack",
                |m: &CanRollBackResponseProto| { &m.canRollBack },
                |m: &mut CanRollBackResponseProto| { &mut m.canRollBack },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CanRollBackResponseProto>(
                "CanRollBackResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CanRollBackResponseProto {
        static instance: ::protobuf::rt::LazyV2<CanRollBackResponseProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CanRollBackResponseProto::new)
    }
}

impl ::protobuf::Clear for CanRollBackResponseProto {
    fn clear(&mut self) {
        self.canRollBack = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CanRollBackResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CanRollBackResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DoRollbackRequestProto {
    // message fields
    pub jid: ::protobuf::SingularPtrField<JournalIdProto>,
    nameserviceId: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DoRollbackRequestProto {
    fn default() -> &'a DoRollbackRequestProto {
        <DoRollbackRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl DoRollbackRequestProto {
    pub fn new() -> DoRollbackRequestProto {
        ::std::default::Default::default()
    }

    // required .hadoop.hdfs.JournalIdProto jid = 1;


    pub fn get_jid(&self) -> &JournalIdProto {
        self.jid.as_ref().unwrap_or_else(|| <JournalIdProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_jid(&mut self) {
        self.jid.clear();
    }

    pub fn has_jid(&self) -> bool {
        self.jid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_jid(&mut self, v: JournalIdProto) {
        self.jid = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_jid(&mut self) -> &mut JournalIdProto {
        if self.jid.is_none() {
            self.jid.set_default();
        }
        self.jid.as_mut().unwrap()
    }

    // Take field
    pub fn take_jid(&mut self) -> JournalIdProto {
        self.jid.take().unwrap_or_else(|| JournalIdProto::new())
    }

    // optional string nameserviceId = 2;


    pub fn get_nameserviceId(&self) -> &str {
        match self.nameserviceId.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_nameserviceId(&mut self) {
        self.nameserviceId.clear();
    }

    pub fn has_nameserviceId(&self) -> bool {
        self.nameserviceId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nameserviceId(&mut self, v: ::std::string::String) {
        self.nameserviceId = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_nameserviceId(&mut self) -> &mut ::std::string::String {
        if self.nameserviceId.is_none() {
            self.nameserviceId.set_default();
        }
        self.nameserviceId.as_mut().unwrap()
    }

    // Take field
    pub fn take_nameserviceId(&mut self) -> ::std::string::String {
        self.nameserviceId.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for DoRollbackRequestProto {
    fn is_initialized(&self) -> bool {
        if self.jid.is_none() {
            return false;
        }
        for v in &self.jid {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.jid)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.nameserviceId)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.jid.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.nameserviceId.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.jid.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.nameserviceId.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DoRollbackRequestProto {
        DoRollbackRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<JournalIdProto>>(
                "jid",
                |m: &DoRollbackRequestProto| { &m.jid },
                |m: &mut DoRollbackRequestProto| { &mut m.jid },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "nameserviceId",
                |m: &DoRollbackRequestProto| { &m.nameserviceId },
                |m: &mut DoRollbackRequestProto| { &mut m.nameserviceId },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DoRollbackRequestProto>(
                "DoRollbackRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DoRollbackRequestProto {
        static instance: ::protobuf::rt::LazyV2<DoRollbackRequestProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DoRollbackRequestProto::new)
    }
}

impl ::protobuf::Clear for DoRollbackRequestProto {
    fn clear(&mut self) {
        self.jid.clear();
        self.nameserviceId.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DoRollbackRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DoRollbackRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DoRollbackResponseProto {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DoRollbackResponseProto {
    fn default() -> &'a DoRollbackResponseProto {
        <DoRollbackResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl DoRollbackResponseProto {
    pub fn new() -> DoRollbackResponseProto {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for DoRollbackResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DoRollbackResponseProto {
        DoRollbackResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DoRollbackResponseProto>(
                "DoRollbackResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DoRollbackResponseProto {
        static instance: ::protobuf::rt::LazyV2<DoRollbackResponseProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DoRollbackResponseProto::new)
    }
}

impl ::protobuf::Clear for DoRollbackResponseProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DoRollbackResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DoRollbackResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DiscardSegmentsRequestProto {
    // message fields
    pub jid: ::protobuf::SingularPtrField<JournalIdProto>,
    startTxId: ::std::option::Option<u64>,
    nameServiceId: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DiscardSegmentsRequestProto {
    fn default() -> &'a DiscardSegmentsRequestProto {
        <DiscardSegmentsRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl DiscardSegmentsRequestProto {
    pub fn new() -> DiscardSegmentsRequestProto {
        ::std::default::Default::default()
    }

    // required .hadoop.hdfs.JournalIdProto jid = 1;


    pub fn get_jid(&self) -> &JournalIdProto {
        self.jid.as_ref().unwrap_or_else(|| <JournalIdProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_jid(&mut self) {
        self.jid.clear();
    }

    pub fn has_jid(&self) -> bool {
        self.jid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_jid(&mut self, v: JournalIdProto) {
        self.jid = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_jid(&mut self) -> &mut JournalIdProto {
        if self.jid.is_none() {
            self.jid.set_default();
        }
        self.jid.as_mut().unwrap()
    }

    // Take field
    pub fn take_jid(&mut self) -> JournalIdProto {
        self.jid.take().unwrap_or_else(|| JournalIdProto::new())
    }

    // required uint64 startTxId = 2;


    pub fn get_startTxId(&self) -> u64 {
        self.startTxId.unwrap_or(0)
    }
    pub fn clear_startTxId(&mut self) {
        self.startTxId = ::std::option::Option::None;
    }

    pub fn has_startTxId(&self) -> bool {
        self.startTxId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_startTxId(&mut self, v: u64) {
        self.startTxId = ::std::option::Option::Some(v);
    }

    // optional string nameServiceId = 3;


    pub fn get_nameServiceId(&self) -> &str {
        match self.nameServiceId.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_nameServiceId(&mut self) {
        self.nameServiceId.clear();
    }

    pub fn has_nameServiceId(&self) -> bool {
        self.nameServiceId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nameServiceId(&mut self, v: ::std::string::String) {
        self.nameServiceId = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_nameServiceId(&mut self) -> &mut ::std::string::String {
        if self.nameServiceId.is_none() {
            self.nameServiceId.set_default();
        }
        self.nameServiceId.as_mut().unwrap()
    }

    // Take field
    pub fn take_nameServiceId(&mut self) -> ::std::string::String {
        self.nameServiceId.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for DiscardSegmentsRequestProto {
    fn is_initialized(&self) -> bool {
        if self.jid.is_none() {
            return false;
        }
        if self.startTxId.is_none() {
            return false;
        }
        for v in &self.jid {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.jid)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.startTxId = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.nameServiceId)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.jid.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.startTxId {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.nameServiceId.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.jid.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.startTxId {
            os.write_uint64(2, v)?;
        }
        if let Some(ref v) = self.nameServiceId.as_ref() {
            os.write_string(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DiscardSegmentsRequestProto {
        DiscardSegmentsRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<JournalIdProto>>(
                "jid",
                |m: &DiscardSegmentsRequestProto| { &m.jid },
                |m: &mut DiscardSegmentsRequestProto| { &mut m.jid },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "startTxId",
                |m: &DiscardSegmentsRequestProto| { &m.startTxId },
                |m: &mut DiscardSegmentsRequestProto| { &mut m.startTxId },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "nameServiceId",
                |m: &DiscardSegmentsRequestProto| { &m.nameServiceId },
                |m: &mut DiscardSegmentsRequestProto| { &mut m.nameServiceId },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DiscardSegmentsRequestProto>(
                "DiscardSegmentsRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DiscardSegmentsRequestProto {
        static instance: ::protobuf::rt::LazyV2<DiscardSegmentsRequestProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DiscardSegmentsRequestProto::new)
    }
}

impl ::protobuf::Clear for DiscardSegmentsRequestProto {
    fn clear(&mut self) {
        self.jid.clear();
        self.startTxId = ::std::option::Option::None;
        self.nameServiceId.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DiscardSegmentsRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DiscardSegmentsRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DiscardSegmentsResponseProto {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DiscardSegmentsResponseProto {
    fn default() -> &'a DiscardSegmentsResponseProto {
        <DiscardSegmentsResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl DiscardSegmentsResponseProto {
    pub fn new() -> DiscardSegmentsResponseProto {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for DiscardSegmentsResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DiscardSegmentsResponseProto {
        DiscardSegmentsResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DiscardSegmentsResponseProto>(
                "DiscardSegmentsResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DiscardSegmentsResponseProto {
        static instance: ::protobuf::rt::LazyV2<DiscardSegmentsResponseProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DiscardSegmentsResponseProto::new)
    }
}

impl ::protobuf::Clear for DiscardSegmentsResponseProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DiscardSegmentsResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DiscardSegmentsResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetJournalStateRequestProto {
    // message fields
    pub jid: ::protobuf::SingularPtrField<JournalIdProto>,
    nameServiceId: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetJournalStateRequestProto {
    fn default() -> &'a GetJournalStateRequestProto {
        <GetJournalStateRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl GetJournalStateRequestProto {
    pub fn new() -> GetJournalStateRequestProto {
        ::std::default::Default::default()
    }

    // required .hadoop.hdfs.JournalIdProto jid = 1;


    pub fn get_jid(&self) -> &JournalIdProto {
        self.jid.as_ref().unwrap_or_else(|| <JournalIdProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_jid(&mut self) {
        self.jid.clear();
    }

    pub fn has_jid(&self) -> bool {
        self.jid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_jid(&mut self, v: JournalIdProto) {
        self.jid = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_jid(&mut self) -> &mut JournalIdProto {
        if self.jid.is_none() {
            self.jid.set_default();
        }
        self.jid.as_mut().unwrap()
    }

    // Take field
    pub fn take_jid(&mut self) -> JournalIdProto {
        self.jid.take().unwrap_or_else(|| JournalIdProto::new())
    }

    // optional string nameServiceId = 2;


    pub fn get_nameServiceId(&self) -> &str {
        match self.nameServiceId.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_nameServiceId(&mut self) {
        self.nameServiceId.clear();
    }

    pub fn has_nameServiceId(&self) -> bool {
        self.nameServiceId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nameServiceId(&mut self, v: ::std::string::String) {
        self.nameServiceId = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_nameServiceId(&mut self) -> &mut ::std::string::String {
        if self.nameServiceId.is_none() {
            self.nameServiceId.set_default();
        }
        self.nameServiceId.as_mut().unwrap()
    }

    // Take field
    pub fn take_nameServiceId(&mut self) -> ::std::string::String {
        self.nameServiceId.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for GetJournalStateRequestProto {
    fn is_initialized(&self) -> bool {
        if self.jid.is_none() {
            return false;
        }
        for v in &self.jid {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.jid)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.nameServiceId)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.jid.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.nameServiceId.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.jid.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.nameServiceId.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetJournalStateRequestProto {
        GetJournalStateRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<JournalIdProto>>(
                "jid",
                |m: &GetJournalStateRequestProto| { &m.jid },
                |m: &mut GetJournalStateRequestProto| { &mut m.jid },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "nameServiceId",
                |m: &GetJournalStateRequestProto| { &m.nameServiceId },
                |m: &mut GetJournalStateRequestProto| { &mut m.nameServiceId },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetJournalStateRequestProto>(
                "GetJournalStateRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetJournalStateRequestProto {
        static instance: ::protobuf::rt::LazyV2<GetJournalStateRequestProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetJournalStateRequestProto::new)
    }
}

impl ::protobuf::Clear for GetJournalStateRequestProto {
    fn clear(&mut self) {
        self.jid.clear();
        self.nameServiceId.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetJournalStateRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetJournalStateRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetJournalStateResponseProto {
    // message fields
    lastPromisedEpoch: ::std::option::Option<u64>,
    httpPort: ::std::option::Option<u32>,
    fromURL: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetJournalStateResponseProto {
    fn default() -> &'a GetJournalStateResponseProto {
        <GetJournalStateResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl GetJournalStateResponseProto {
    pub fn new() -> GetJournalStateResponseProto {
        ::std::default::Default::default()
    }

    // required uint64 lastPromisedEpoch = 1;


    pub fn get_lastPromisedEpoch(&self) -> u64 {
        self.lastPromisedEpoch.unwrap_or(0)
    }
    pub fn clear_lastPromisedEpoch(&mut self) {
        self.lastPromisedEpoch = ::std::option::Option::None;
    }

    pub fn has_lastPromisedEpoch(&self) -> bool {
        self.lastPromisedEpoch.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lastPromisedEpoch(&mut self, v: u64) {
        self.lastPromisedEpoch = ::std::option::Option::Some(v);
    }

    // required uint32 httpPort = 2;


    pub fn get_httpPort(&self) -> u32 {
        self.httpPort.unwrap_or(0)
    }
    pub fn clear_httpPort(&mut self) {
        self.httpPort = ::std::option::Option::None;
    }

    pub fn has_httpPort(&self) -> bool {
        self.httpPort.is_some()
    }

    // Param is passed by value, moved
    pub fn set_httpPort(&mut self, v: u32) {
        self.httpPort = ::std::option::Option::Some(v);
    }

    // optional string fromURL = 3;


    pub fn get_fromURL(&self) -> &str {
        match self.fromURL.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_fromURL(&mut self) {
        self.fromURL.clear();
    }

    pub fn has_fromURL(&self) -> bool {
        self.fromURL.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fromURL(&mut self, v: ::std::string::String) {
        self.fromURL = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fromURL(&mut self) -> &mut ::std::string::String {
        if self.fromURL.is_none() {
            self.fromURL.set_default();
        }
        self.fromURL.as_mut().unwrap()
    }

    // Take field
    pub fn take_fromURL(&mut self) -> ::std::string::String {
        self.fromURL.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for GetJournalStateResponseProto {
    fn is_initialized(&self) -> bool {
        if self.lastPromisedEpoch.is_none() {
            return false;
        }
        if self.httpPort.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.lastPromisedEpoch = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.httpPort = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.fromURL)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.lastPromisedEpoch {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.httpPort {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.fromURL.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.lastPromisedEpoch {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.httpPort {
            os.write_uint32(2, v)?;
        }
        if let Some(ref v) = self.fromURL.as_ref() {
            os.write_string(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetJournalStateResponseProto {
        GetJournalStateResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "lastPromisedEpoch",
                |m: &GetJournalStateResponseProto| { &m.lastPromisedEpoch },
                |m: &mut GetJournalStateResponseProto| { &mut m.lastPromisedEpoch },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "httpPort",
                |m: &GetJournalStateResponseProto| { &m.httpPort },
                |m: &mut GetJournalStateResponseProto| { &mut m.httpPort },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "fromURL",
                |m: &GetJournalStateResponseProto| { &m.fromURL },
                |m: &mut GetJournalStateResponseProto| { &mut m.fromURL },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetJournalStateResponseProto>(
                "GetJournalStateResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetJournalStateResponseProto {
        static instance: ::protobuf::rt::LazyV2<GetJournalStateResponseProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetJournalStateResponseProto::new)
    }
}

impl ::protobuf::Clear for GetJournalStateResponseProto {
    fn clear(&mut self) {
        self.lastPromisedEpoch = ::std::option::Option::None;
        self.httpPort = ::std::option::Option::None;
        self.fromURL.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetJournalStateResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetJournalStateResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FormatRequestProto {
    // message fields
    pub jid: ::protobuf::SingularPtrField<JournalIdProto>,
    pub nsInfo: ::protobuf::SingularPtrField<super::HdfsServer::NamespaceInfoProto>,
    nameServiceId: ::protobuf::SingularField<::std::string::String>,
    force: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FormatRequestProto {
    fn default() -> &'a FormatRequestProto {
        <FormatRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl FormatRequestProto {
    pub fn new() -> FormatRequestProto {
        ::std::default::Default::default()
    }

    // required .hadoop.hdfs.JournalIdProto jid = 1;


    pub fn get_jid(&self) -> &JournalIdProto {
        self.jid.as_ref().unwrap_or_else(|| <JournalIdProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_jid(&mut self) {
        self.jid.clear();
    }

    pub fn has_jid(&self) -> bool {
        self.jid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_jid(&mut self, v: JournalIdProto) {
        self.jid = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_jid(&mut self) -> &mut JournalIdProto {
        if self.jid.is_none() {
            self.jid.set_default();
        }
        self.jid.as_mut().unwrap()
    }

    // Take field
    pub fn take_jid(&mut self) -> JournalIdProto {
        self.jid.take().unwrap_or_else(|| JournalIdProto::new())
    }

    // required .hadoop.hdfs.NamespaceInfoProto nsInfo = 2;


    pub fn get_nsInfo(&self) -> &super::HdfsServer::NamespaceInfoProto {
        self.nsInfo.as_ref().unwrap_or_else(|| <super::HdfsServer::NamespaceInfoProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_nsInfo(&mut self) {
        self.nsInfo.clear();
    }

    pub fn has_nsInfo(&self) -> bool {
        self.nsInfo.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nsInfo(&mut self, v: super::HdfsServer::NamespaceInfoProto) {
        self.nsInfo = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_nsInfo(&mut self) -> &mut super::HdfsServer::NamespaceInfoProto {
        if self.nsInfo.is_none() {
            self.nsInfo.set_default();
        }
        self.nsInfo.as_mut().unwrap()
    }

    // Take field
    pub fn take_nsInfo(&mut self) -> super::HdfsServer::NamespaceInfoProto {
        self.nsInfo.take().unwrap_or_else(|| super::HdfsServer::NamespaceInfoProto::new())
    }

    // optional string nameServiceId = 3;


    pub fn get_nameServiceId(&self) -> &str {
        match self.nameServiceId.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_nameServiceId(&mut self) {
        self.nameServiceId.clear();
    }

    pub fn has_nameServiceId(&self) -> bool {
        self.nameServiceId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nameServiceId(&mut self, v: ::std::string::String) {
        self.nameServiceId = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_nameServiceId(&mut self) -> &mut ::std::string::String {
        if self.nameServiceId.is_none() {
            self.nameServiceId.set_default();
        }
        self.nameServiceId.as_mut().unwrap()
    }

    // Take field
    pub fn take_nameServiceId(&mut self) -> ::std::string::String {
        self.nameServiceId.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool force = 4;


    pub fn get_force(&self) -> bool {
        self.force.unwrap_or(false)
    }
    pub fn clear_force(&mut self) {
        self.force = ::std::option::Option::None;
    }

    pub fn has_force(&self) -> bool {
        self.force.is_some()
    }

    // Param is passed by value, moved
    pub fn set_force(&mut self, v: bool) {
        self.force = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for FormatRequestProto {
    fn is_initialized(&self) -> bool {
        if self.jid.is_none() {
            return false;
        }
        if self.nsInfo.is_none() {
            return false;
        }
        for v in &self.jid {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.nsInfo {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.jid)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.nsInfo)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.nameServiceId)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.force = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.jid.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.nsInfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.nameServiceId.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.force {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.jid.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.nsInfo.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.nameServiceId.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(v) = self.force {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FormatRequestProto {
        FormatRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<JournalIdProto>>(
                "jid",
                |m: &FormatRequestProto| { &m.jid },
                |m: &mut FormatRequestProto| { &mut m.jid },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::HdfsServer::NamespaceInfoProto>>(
                "nsInfo",
                |m: &FormatRequestProto| { &m.nsInfo },
                |m: &mut FormatRequestProto| { &mut m.nsInfo },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "nameServiceId",
                |m: &FormatRequestProto| { &m.nameServiceId },
                |m: &mut FormatRequestProto| { &mut m.nameServiceId },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "force",
                |m: &FormatRequestProto| { &m.force },
                |m: &mut FormatRequestProto| { &mut m.force },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<FormatRequestProto>(
                "FormatRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static FormatRequestProto {
        static instance: ::protobuf::rt::LazyV2<FormatRequestProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(FormatRequestProto::new)
    }
}

impl ::protobuf::Clear for FormatRequestProto {
    fn clear(&mut self) {
        self.jid.clear();
        self.nsInfo.clear();
        self.nameServiceId.clear();
        self.force = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FormatRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FormatRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FormatResponseProto {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FormatResponseProto {
    fn default() -> &'a FormatResponseProto {
        <FormatResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl FormatResponseProto {
    pub fn new() -> FormatResponseProto {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for FormatResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FormatResponseProto {
        FormatResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<FormatResponseProto>(
                "FormatResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static FormatResponseProto {
        static instance: ::protobuf::rt::LazyV2<FormatResponseProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(FormatResponseProto::new)
    }
}

impl ::protobuf::Clear for FormatResponseProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FormatResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FormatResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct NewEpochRequestProto {
    // message fields
    pub jid: ::protobuf::SingularPtrField<JournalIdProto>,
    pub nsInfo: ::protobuf::SingularPtrField<super::HdfsServer::NamespaceInfoProto>,
    epoch: ::std::option::Option<u64>,
    nameServiceId: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a NewEpochRequestProto {
    fn default() -> &'a NewEpochRequestProto {
        <NewEpochRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl NewEpochRequestProto {
    pub fn new() -> NewEpochRequestProto {
        ::std::default::Default::default()
    }

    // required .hadoop.hdfs.JournalIdProto jid = 1;


    pub fn get_jid(&self) -> &JournalIdProto {
        self.jid.as_ref().unwrap_or_else(|| <JournalIdProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_jid(&mut self) {
        self.jid.clear();
    }

    pub fn has_jid(&self) -> bool {
        self.jid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_jid(&mut self, v: JournalIdProto) {
        self.jid = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_jid(&mut self) -> &mut JournalIdProto {
        if self.jid.is_none() {
            self.jid.set_default();
        }
        self.jid.as_mut().unwrap()
    }

    // Take field
    pub fn take_jid(&mut self) -> JournalIdProto {
        self.jid.take().unwrap_or_else(|| JournalIdProto::new())
    }

    // required .hadoop.hdfs.NamespaceInfoProto nsInfo = 2;


    pub fn get_nsInfo(&self) -> &super::HdfsServer::NamespaceInfoProto {
        self.nsInfo.as_ref().unwrap_or_else(|| <super::HdfsServer::NamespaceInfoProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_nsInfo(&mut self) {
        self.nsInfo.clear();
    }

    pub fn has_nsInfo(&self) -> bool {
        self.nsInfo.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nsInfo(&mut self, v: super::HdfsServer::NamespaceInfoProto) {
        self.nsInfo = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_nsInfo(&mut self) -> &mut super::HdfsServer::NamespaceInfoProto {
        if self.nsInfo.is_none() {
            self.nsInfo.set_default();
        }
        self.nsInfo.as_mut().unwrap()
    }

    // Take field
    pub fn take_nsInfo(&mut self) -> super::HdfsServer::NamespaceInfoProto {
        self.nsInfo.take().unwrap_or_else(|| super::HdfsServer::NamespaceInfoProto::new())
    }

    // required uint64 epoch = 3;


    pub fn get_epoch(&self) -> u64 {
        self.epoch.unwrap_or(0)
    }
    pub fn clear_epoch(&mut self) {
        self.epoch = ::std::option::Option::None;
    }

    pub fn has_epoch(&self) -> bool {
        self.epoch.is_some()
    }

    // Param is passed by value, moved
    pub fn set_epoch(&mut self, v: u64) {
        self.epoch = ::std::option::Option::Some(v);
    }

    // optional string nameServiceId = 4;


    pub fn get_nameServiceId(&self) -> &str {
        match self.nameServiceId.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_nameServiceId(&mut self) {
        self.nameServiceId.clear();
    }

    pub fn has_nameServiceId(&self) -> bool {
        self.nameServiceId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nameServiceId(&mut self, v: ::std::string::String) {
        self.nameServiceId = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_nameServiceId(&mut self) -> &mut ::std::string::String {
        if self.nameServiceId.is_none() {
            self.nameServiceId.set_default();
        }
        self.nameServiceId.as_mut().unwrap()
    }

    // Take field
    pub fn take_nameServiceId(&mut self) -> ::std::string::String {
        self.nameServiceId.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for NewEpochRequestProto {
    fn is_initialized(&self) -> bool {
        if self.jid.is_none() {
            return false;
        }
        if self.nsInfo.is_none() {
            return false;
        }
        if self.epoch.is_none() {
            return false;
        }
        for v in &self.jid {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.nsInfo {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.jid)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.nsInfo)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.epoch = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.nameServiceId)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.jid.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.nsInfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.epoch {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.nameServiceId.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.jid.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.nsInfo.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.epoch {
            os.write_uint64(3, v)?;
        }
        if let Some(ref v) = self.nameServiceId.as_ref() {
            os.write_string(4, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NewEpochRequestProto {
        NewEpochRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<JournalIdProto>>(
                "jid",
                |m: &NewEpochRequestProto| { &m.jid },
                |m: &mut NewEpochRequestProto| { &mut m.jid },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::HdfsServer::NamespaceInfoProto>>(
                "nsInfo",
                |m: &NewEpochRequestProto| { &m.nsInfo },
                |m: &mut NewEpochRequestProto| { &mut m.nsInfo },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "epoch",
                |m: &NewEpochRequestProto| { &m.epoch },
                |m: &mut NewEpochRequestProto| { &mut m.epoch },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "nameServiceId",
                |m: &NewEpochRequestProto| { &m.nameServiceId },
                |m: &mut NewEpochRequestProto| { &mut m.nameServiceId },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<NewEpochRequestProto>(
                "NewEpochRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static NewEpochRequestProto {
        static instance: ::protobuf::rt::LazyV2<NewEpochRequestProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(NewEpochRequestProto::new)
    }
}

impl ::protobuf::Clear for NewEpochRequestProto {
    fn clear(&mut self) {
        self.jid.clear();
        self.nsInfo.clear();
        self.epoch = ::std::option::Option::None;
        self.nameServiceId.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NewEpochRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NewEpochRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct NewEpochResponseProto {
    // message fields
    lastSegmentTxId: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a NewEpochResponseProto {
    fn default() -> &'a NewEpochResponseProto {
        <NewEpochResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl NewEpochResponseProto {
    pub fn new() -> NewEpochResponseProto {
        ::std::default::Default::default()
    }

    // optional uint64 lastSegmentTxId = 1;


    pub fn get_lastSegmentTxId(&self) -> u64 {
        self.lastSegmentTxId.unwrap_or(0)
    }
    pub fn clear_lastSegmentTxId(&mut self) {
        self.lastSegmentTxId = ::std::option::Option::None;
    }

    pub fn has_lastSegmentTxId(&self) -> bool {
        self.lastSegmentTxId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lastSegmentTxId(&mut self, v: u64) {
        self.lastSegmentTxId = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for NewEpochResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.lastSegmentTxId = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.lastSegmentTxId {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.lastSegmentTxId {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NewEpochResponseProto {
        NewEpochResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "lastSegmentTxId",
                |m: &NewEpochResponseProto| { &m.lastSegmentTxId },
                |m: &mut NewEpochResponseProto| { &mut m.lastSegmentTxId },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<NewEpochResponseProto>(
                "NewEpochResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static NewEpochResponseProto {
        static instance: ::protobuf::rt::LazyV2<NewEpochResponseProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(NewEpochResponseProto::new)
    }
}

impl ::protobuf::Clear for NewEpochResponseProto {
    fn clear(&mut self) {
        self.lastSegmentTxId = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NewEpochResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NewEpochResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetEditLogManifestRequestProto {
    // message fields
    pub jid: ::protobuf::SingularPtrField<JournalIdProto>,
    sinceTxId: ::std::option::Option<u64>,
    inProgressOk: ::std::option::Option<bool>,
    nameServiceId: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetEditLogManifestRequestProto {
    fn default() -> &'a GetEditLogManifestRequestProto {
        <GetEditLogManifestRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl GetEditLogManifestRequestProto {
    pub fn new() -> GetEditLogManifestRequestProto {
        ::std::default::Default::default()
    }

    // required .hadoop.hdfs.JournalIdProto jid = 1;


    pub fn get_jid(&self) -> &JournalIdProto {
        self.jid.as_ref().unwrap_or_else(|| <JournalIdProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_jid(&mut self) {
        self.jid.clear();
    }

    pub fn has_jid(&self) -> bool {
        self.jid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_jid(&mut self, v: JournalIdProto) {
        self.jid = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_jid(&mut self) -> &mut JournalIdProto {
        if self.jid.is_none() {
            self.jid.set_default();
        }
        self.jid.as_mut().unwrap()
    }

    // Take field
    pub fn take_jid(&mut self) -> JournalIdProto {
        self.jid.take().unwrap_or_else(|| JournalIdProto::new())
    }

    // required uint64 sinceTxId = 2;


    pub fn get_sinceTxId(&self) -> u64 {
        self.sinceTxId.unwrap_or(0)
    }
    pub fn clear_sinceTxId(&mut self) {
        self.sinceTxId = ::std::option::Option::None;
    }

    pub fn has_sinceTxId(&self) -> bool {
        self.sinceTxId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sinceTxId(&mut self, v: u64) {
        self.sinceTxId = ::std::option::Option::Some(v);
    }

    // optional bool inProgressOk = 4;


    pub fn get_inProgressOk(&self) -> bool {
        self.inProgressOk.unwrap_or(false)
    }
    pub fn clear_inProgressOk(&mut self) {
        self.inProgressOk = ::std::option::Option::None;
    }

    pub fn has_inProgressOk(&self) -> bool {
        self.inProgressOk.is_some()
    }

    // Param is passed by value, moved
    pub fn set_inProgressOk(&mut self, v: bool) {
        self.inProgressOk = ::std::option::Option::Some(v);
    }

    // optional string nameServiceId = 5;


    pub fn get_nameServiceId(&self) -> &str {
        match self.nameServiceId.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_nameServiceId(&mut self) {
        self.nameServiceId.clear();
    }

    pub fn has_nameServiceId(&self) -> bool {
        self.nameServiceId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nameServiceId(&mut self, v: ::std::string::String) {
        self.nameServiceId = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_nameServiceId(&mut self) -> &mut ::std::string::String {
        if self.nameServiceId.is_none() {
            self.nameServiceId.set_default();
        }
        self.nameServiceId.as_mut().unwrap()
    }

    // Take field
    pub fn take_nameServiceId(&mut self) -> ::std::string::String {
        self.nameServiceId.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for GetEditLogManifestRequestProto {
    fn is_initialized(&self) -> bool {
        if self.jid.is_none() {
            return false;
        }
        if self.sinceTxId.is_none() {
            return false;
        }
        for v in &self.jid {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.jid)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.sinceTxId = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.inProgressOk = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.nameServiceId)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.jid.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.sinceTxId {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.inProgressOk {
            my_size += 2;
        }
        if let Some(ref v) = self.nameServiceId.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.jid.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.sinceTxId {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.inProgressOk {
            os.write_bool(4, v)?;
        }
        if let Some(ref v) = self.nameServiceId.as_ref() {
            os.write_string(5, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetEditLogManifestRequestProto {
        GetEditLogManifestRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<JournalIdProto>>(
                "jid",
                |m: &GetEditLogManifestRequestProto| { &m.jid },
                |m: &mut GetEditLogManifestRequestProto| { &mut m.jid },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "sinceTxId",
                |m: &GetEditLogManifestRequestProto| { &m.sinceTxId },
                |m: &mut GetEditLogManifestRequestProto| { &mut m.sinceTxId },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "inProgressOk",
                |m: &GetEditLogManifestRequestProto| { &m.inProgressOk },
                |m: &mut GetEditLogManifestRequestProto| { &mut m.inProgressOk },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "nameServiceId",
                |m: &GetEditLogManifestRequestProto| { &m.nameServiceId },
                |m: &mut GetEditLogManifestRequestProto| { &mut m.nameServiceId },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetEditLogManifestRequestProto>(
                "GetEditLogManifestRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetEditLogManifestRequestProto {
        static instance: ::protobuf::rt::LazyV2<GetEditLogManifestRequestProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetEditLogManifestRequestProto::new)
    }
}

impl ::protobuf::Clear for GetEditLogManifestRequestProto {
    fn clear(&mut self) {
        self.jid.clear();
        self.sinceTxId = ::std::option::Option::None;
        self.inProgressOk = ::std::option::Option::None;
        self.nameServiceId.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetEditLogManifestRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetEditLogManifestRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetEditLogManifestResponseProto {
    // message fields
    pub manifest: ::protobuf::SingularPtrField<super::HdfsServer::RemoteEditLogManifestProto>,
    httpPort: ::std::option::Option<u32>,
    fromURL: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetEditLogManifestResponseProto {
    fn default() -> &'a GetEditLogManifestResponseProto {
        <GetEditLogManifestResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl GetEditLogManifestResponseProto {
    pub fn new() -> GetEditLogManifestResponseProto {
        ::std::default::Default::default()
    }

    // required .hadoop.hdfs.RemoteEditLogManifestProto manifest = 1;


    pub fn get_manifest(&self) -> &super::HdfsServer::RemoteEditLogManifestProto {
        self.manifest.as_ref().unwrap_or_else(|| <super::HdfsServer::RemoteEditLogManifestProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_manifest(&mut self) {
        self.manifest.clear();
    }

    pub fn has_manifest(&self) -> bool {
        self.manifest.is_some()
    }

    // Param is passed by value, moved
    pub fn set_manifest(&mut self, v: super::HdfsServer::RemoteEditLogManifestProto) {
        self.manifest = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_manifest(&mut self) -> &mut super::HdfsServer::RemoteEditLogManifestProto {
        if self.manifest.is_none() {
            self.manifest.set_default();
        }
        self.manifest.as_mut().unwrap()
    }

    // Take field
    pub fn take_manifest(&mut self) -> super::HdfsServer::RemoteEditLogManifestProto {
        self.manifest.take().unwrap_or_else(|| super::HdfsServer::RemoteEditLogManifestProto::new())
    }

    // required uint32 httpPort = 2;


    pub fn get_httpPort(&self) -> u32 {
        self.httpPort.unwrap_or(0)
    }
    pub fn clear_httpPort(&mut self) {
        self.httpPort = ::std::option::Option::None;
    }

    pub fn has_httpPort(&self) -> bool {
        self.httpPort.is_some()
    }

    // Param is passed by value, moved
    pub fn set_httpPort(&mut self, v: u32) {
        self.httpPort = ::std::option::Option::Some(v);
    }

    // optional string fromURL = 3;


    pub fn get_fromURL(&self) -> &str {
        match self.fromURL.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_fromURL(&mut self) {
        self.fromURL.clear();
    }

    pub fn has_fromURL(&self) -> bool {
        self.fromURL.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fromURL(&mut self, v: ::std::string::String) {
        self.fromURL = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fromURL(&mut self) -> &mut ::std::string::String {
        if self.fromURL.is_none() {
            self.fromURL.set_default();
        }
        self.fromURL.as_mut().unwrap()
    }

    // Take field
    pub fn take_fromURL(&mut self) -> ::std::string::String {
        self.fromURL.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for GetEditLogManifestResponseProto {
    fn is_initialized(&self) -> bool {
        if self.manifest.is_none() {
            return false;
        }
        if self.httpPort.is_none() {
            return false;
        }
        for v in &self.manifest {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.manifest)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.httpPort = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.fromURL)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.manifest.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.httpPort {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.fromURL.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.manifest.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.httpPort {
            os.write_uint32(2, v)?;
        }
        if let Some(ref v) = self.fromURL.as_ref() {
            os.write_string(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetEditLogManifestResponseProto {
        GetEditLogManifestResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::HdfsServer::RemoteEditLogManifestProto>>(
                "manifest",
                |m: &GetEditLogManifestResponseProto| { &m.manifest },
                |m: &mut GetEditLogManifestResponseProto| { &mut m.manifest },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "httpPort",
                |m: &GetEditLogManifestResponseProto| { &m.httpPort },
                |m: &mut GetEditLogManifestResponseProto| { &mut m.httpPort },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "fromURL",
                |m: &GetEditLogManifestResponseProto| { &m.fromURL },
                |m: &mut GetEditLogManifestResponseProto| { &mut m.fromURL },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetEditLogManifestResponseProto>(
                "GetEditLogManifestResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetEditLogManifestResponseProto {
        static instance: ::protobuf::rt::LazyV2<GetEditLogManifestResponseProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetEditLogManifestResponseProto::new)
    }
}

impl ::protobuf::Clear for GetEditLogManifestResponseProto {
    fn clear(&mut self) {
        self.manifest.clear();
        self.httpPort = ::std::option::Option::None;
        self.fromURL.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetEditLogManifestResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetEditLogManifestResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetJournaledEditsRequestProto {
    // message fields
    pub jid: ::protobuf::SingularPtrField<JournalIdProto>,
    sinceTxId: ::std::option::Option<u64>,
    maxTxns: ::std::option::Option<u32>,
    nameServiceId: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetJournaledEditsRequestProto {
    fn default() -> &'a GetJournaledEditsRequestProto {
        <GetJournaledEditsRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl GetJournaledEditsRequestProto {
    pub fn new() -> GetJournaledEditsRequestProto {
        ::std::default::Default::default()
    }

    // required .hadoop.hdfs.JournalIdProto jid = 1;


    pub fn get_jid(&self) -> &JournalIdProto {
        self.jid.as_ref().unwrap_or_else(|| <JournalIdProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_jid(&mut self) {
        self.jid.clear();
    }

    pub fn has_jid(&self) -> bool {
        self.jid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_jid(&mut self, v: JournalIdProto) {
        self.jid = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_jid(&mut self) -> &mut JournalIdProto {
        if self.jid.is_none() {
            self.jid.set_default();
        }
        self.jid.as_mut().unwrap()
    }

    // Take field
    pub fn take_jid(&mut self) -> JournalIdProto {
        self.jid.take().unwrap_or_else(|| JournalIdProto::new())
    }

    // required uint64 sinceTxId = 2;


    pub fn get_sinceTxId(&self) -> u64 {
        self.sinceTxId.unwrap_or(0)
    }
    pub fn clear_sinceTxId(&mut self) {
        self.sinceTxId = ::std::option::Option::None;
    }

    pub fn has_sinceTxId(&self) -> bool {
        self.sinceTxId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sinceTxId(&mut self, v: u64) {
        self.sinceTxId = ::std::option::Option::Some(v);
    }

    // required uint32 maxTxns = 3;


    pub fn get_maxTxns(&self) -> u32 {
        self.maxTxns.unwrap_or(0)
    }
    pub fn clear_maxTxns(&mut self) {
        self.maxTxns = ::std::option::Option::None;
    }

    pub fn has_maxTxns(&self) -> bool {
        self.maxTxns.is_some()
    }

    // Param is passed by value, moved
    pub fn set_maxTxns(&mut self, v: u32) {
        self.maxTxns = ::std::option::Option::Some(v);
    }

    // optional string nameServiceId = 4;


    pub fn get_nameServiceId(&self) -> &str {
        match self.nameServiceId.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_nameServiceId(&mut self) {
        self.nameServiceId.clear();
    }

    pub fn has_nameServiceId(&self) -> bool {
        self.nameServiceId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nameServiceId(&mut self, v: ::std::string::String) {
        self.nameServiceId = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_nameServiceId(&mut self) -> &mut ::std::string::String {
        if self.nameServiceId.is_none() {
            self.nameServiceId.set_default();
        }
        self.nameServiceId.as_mut().unwrap()
    }

    // Take field
    pub fn take_nameServiceId(&mut self) -> ::std::string::String {
        self.nameServiceId.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for GetJournaledEditsRequestProto {
    fn is_initialized(&self) -> bool {
        if self.jid.is_none() {
            return false;
        }
        if self.sinceTxId.is_none() {
            return false;
        }
        if self.maxTxns.is_none() {
            return false;
        }
        for v in &self.jid {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.jid)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.sinceTxId = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.maxTxns = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.nameServiceId)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.jid.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.sinceTxId {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.maxTxns {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.nameServiceId.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.jid.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.sinceTxId {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.maxTxns {
            os.write_uint32(3, v)?;
        }
        if let Some(ref v) = self.nameServiceId.as_ref() {
            os.write_string(4, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetJournaledEditsRequestProto {
        GetJournaledEditsRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<JournalIdProto>>(
                "jid",
                |m: &GetJournaledEditsRequestProto| { &m.jid },
                |m: &mut GetJournaledEditsRequestProto| { &mut m.jid },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "sinceTxId",
                |m: &GetJournaledEditsRequestProto| { &m.sinceTxId },
                |m: &mut GetJournaledEditsRequestProto| { &mut m.sinceTxId },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "maxTxns",
                |m: &GetJournaledEditsRequestProto| { &m.maxTxns },
                |m: &mut GetJournaledEditsRequestProto| { &mut m.maxTxns },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "nameServiceId",
                |m: &GetJournaledEditsRequestProto| { &m.nameServiceId },
                |m: &mut GetJournaledEditsRequestProto| { &mut m.nameServiceId },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetJournaledEditsRequestProto>(
                "GetJournaledEditsRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetJournaledEditsRequestProto {
        static instance: ::protobuf::rt::LazyV2<GetJournaledEditsRequestProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetJournaledEditsRequestProto::new)
    }
}

impl ::protobuf::Clear for GetJournaledEditsRequestProto {
    fn clear(&mut self) {
        self.jid.clear();
        self.sinceTxId = ::std::option::Option::None;
        self.maxTxns = ::std::option::Option::None;
        self.nameServiceId.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetJournaledEditsRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetJournaledEditsRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetJournaledEditsResponseProto {
    // message fields
    txnCount: ::std::option::Option<u32>,
    editLog: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetJournaledEditsResponseProto {
    fn default() -> &'a GetJournaledEditsResponseProto {
        <GetJournaledEditsResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl GetJournaledEditsResponseProto {
    pub fn new() -> GetJournaledEditsResponseProto {
        ::std::default::Default::default()
    }

    // required uint32 txnCount = 1;


    pub fn get_txnCount(&self) -> u32 {
        self.txnCount.unwrap_or(0)
    }
    pub fn clear_txnCount(&mut self) {
        self.txnCount = ::std::option::Option::None;
    }

    pub fn has_txnCount(&self) -> bool {
        self.txnCount.is_some()
    }

    // Param is passed by value, moved
    pub fn set_txnCount(&mut self, v: u32) {
        self.txnCount = ::std::option::Option::Some(v);
    }

    // optional bytes editLog = 2;


    pub fn get_editLog(&self) -> &[u8] {
        match self.editLog.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_editLog(&mut self) {
        self.editLog.clear();
    }

    pub fn has_editLog(&self) -> bool {
        self.editLog.is_some()
    }

    // Param is passed by value, moved
    pub fn set_editLog(&mut self, v: ::std::vec::Vec<u8>) {
        self.editLog = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_editLog(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.editLog.is_none() {
            self.editLog.set_default();
        }
        self.editLog.as_mut().unwrap()
    }

    // Take field
    pub fn take_editLog(&mut self) -> ::std::vec::Vec<u8> {
        self.editLog.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for GetJournaledEditsResponseProto {
    fn is_initialized(&self) -> bool {
        if self.txnCount.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.txnCount = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.editLog)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.txnCount {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.editLog.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.txnCount {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.editLog.as_ref() {
            os.write_bytes(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetJournaledEditsResponseProto {
        GetJournaledEditsResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "txnCount",
                |m: &GetJournaledEditsResponseProto| { &m.txnCount },
                |m: &mut GetJournaledEditsResponseProto| { &mut m.txnCount },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "editLog",
                |m: &GetJournaledEditsResponseProto| { &m.editLog },
                |m: &mut GetJournaledEditsResponseProto| { &mut m.editLog },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetJournaledEditsResponseProto>(
                "GetJournaledEditsResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetJournaledEditsResponseProto {
        static instance: ::protobuf::rt::LazyV2<GetJournaledEditsResponseProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetJournaledEditsResponseProto::new)
    }
}

impl ::protobuf::Clear for GetJournaledEditsResponseProto {
    fn clear(&mut self) {
        self.txnCount = ::std::option::Option::None;
        self.editLog.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetJournaledEditsResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetJournaledEditsResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PrepareRecoveryRequestProto {
    // message fields
    pub reqInfo: ::protobuf::SingularPtrField<RequestInfoProto>,
    segmentTxId: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PrepareRecoveryRequestProto {
    fn default() -> &'a PrepareRecoveryRequestProto {
        <PrepareRecoveryRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl PrepareRecoveryRequestProto {
    pub fn new() -> PrepareRecoveryRequestProto {
        ::std::default::Default::default()
    }

    // required .hadoop.hdfs.RequestInfoProto reqInfo = 1;


    pub fn get_reqInfo(&self) -> &RequestInfoProto {
        self.reqInfo.as_ref().unwrap_or_else(|| <RequestInfoProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_reqInfo(&mut self) {
        self.reqInfo.clear();
    }

    pub fn has_reqInfo(&self) -> bool {
        self.reqInfo.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reqInfo(&mut self, v: RequestInfoProto) {
        self.reqInfo = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reqInfo(&mut self) -> &mut RequestInfoProto {
        if self.reqInfo.is_none() {
            self.reqInfo.set_default();
        }
        self.reqInfo.as_mut().unwrap()
    }

    // Take field
    pub fn take_reqInfo(&mut self) -> RequestInfoProto {
        self.reqInfo.take().unwrap_or_else(|| RequestInfoProto::new())
    }

    // required uint64 segmentTxId = 2;


    pub fn get_segmentTxId(&self) -> u64 {
        self.segmentTxId.unwrap_or(0)
    }
    pub fn clear_segmentTxId(&mut self) {
        self.segmentTxId = ::std::option::Option::None;
    }

    pub fn has_segmentTxId(&self) -> bool {
        self.segmentTxId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_segmentTxId(&mut self, v: u64) {
        self.segmentTxId = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for PrepareRecoveryRequestProto {
    fn is_initialized(&self) -> bool {
        if self.reqInfo.is_none() {
            return false;
        }
        if self.segmentTxId.is_none() {
            return false;
        }
        for v in &self.reqInfo {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.reqInfo)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.segmentTxId = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.reqInfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.segmentTxId {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.reqInfo.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.segmentTxId {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PrepareRecoveryRequestProto {
        PrepareRecoveryRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RequestInfoProto>>(
                "reqInfo",
                |m: &PrepareRecoveryRequestProto| { &m.reqInfo },
                |m: &mut PrepareRecoveryRequestProto| { &mut m.reqInfo },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "segmentTxId",
                |m: &PrepareRecoveryRequestProto| { &m.segmentTxId },
                |m: &mut PrepareRecoveryRequestProto| { &mut m.segmentTxId },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PrepareRecoveryRequestProto>(
                "PrepareRecoveryRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PrepareRecoveryRequestProto {
        static instance: ::protobuf::rt::LazyV2<PrepareRecoveryRequestProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PrepareRecoveryRequestProto::new)
    }
}

impl ::protobuf::Clear for PrepareRecoveryRequestProto {
    fn clear(&mut self) {
        self.reqInfo.clear();
        self.segmentTxId = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PrepareRecoveryRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PrepareRecoveryRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PrepareRecoveryResponseProto {
    // message fields
    pub segmentState: ::protobuf::SingularPtrField<SegmentStateProto>,
    acceptedInEpoch: ::std::option::Option<u64>,
    lastWriterEpoch: ::std::option::Option<u64>,
    lastCommittedTxId: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PrepareRecoveryResponseProto {
    fn default() -> &'a PrepareRecoveryResponseProto {
        <PrepareRecoveryResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl PrepareRecoveryResponseProto {
    pub fn new() -> PrepareRecoveryResponseProto {
        ::std::default::Default::default()
    }

    // optional .hadoop.hdfs.SegmentStateProto segmentState = 1;


    pub fn get_segmentState(&self) -> &SegmentStateProto {
        self.segmentState.as_ref().unwrap_or_else(|| <SegmentStateProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_segmentState(&mut self) {
        self.segmentState.clear();
    }

    pub fn has_segmentState(&self) -> bool {
        self.segmentState.is_some()
    }

    // Param is passed by value, moved
    pub fn set_segmentState(&mut self, v: SegmentStateProto) {
        self.segmentState = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_segmentState(&mut self) -> &mut SegmentStateProto {
        if self.segmentState.is_none() {
            self.segmentState.set_default();
        }
        self.segmentState.as_mut().unwrap()
    }

    // Take field
    pub fn take_segmentState(&mut self) -> SegmentStateProto {
        self.segmentState.take().unwrap_or_else(|| SegmentStateProto::new())
    }

    // optional uint64 acceptedInEpoch = 2;


    pub fn get_acceptedInEpoch(&self) -> u64 {
        self.acceptedInEpoch.unwrap_or(0)
    }
    pub fn clear_acceptedInEpoch(&mut self) {
        self.acceptedInEpoch = ::std::option::Option::None;
    }

    pub fn has_acceptedInEpoch(&self) -> bool {
        self.acceptedInEpoch.is_some()
    }

    // Param is passed by value, moved
    pub fn set_acceptedInEpoch(&mut self, v: u64) {
        self.acceptedInEpoch = ::std::option::Option::Some(v);
    }

    // required uint64 lastWriterEpoch = 3;


    pub fn get_lastWriterEpoch(&self) -> u64 {
        self.lastWriterEpoch.unwrap_or(0)
    }
    pub fn clear_lastWriterEpoch(&mut self) {
        self.lastWriterEpoch = ::std::option::Option::None;
    }

    pub fn has_lastWriterEpoch(&self) -> bool {
        self.lastWriterEpoch.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lastWriterEpoch(&mut self, v: u64) {
        self.lastWriterEpoch = ::std::option::Option::Some(v);
    }

    // optional uint64 lastCommittedTxId = 4;


    pub fn get_lastCommittedTxId(&self) -> u64 {
        self.lastCommittedTxId.unwrap_or(0)
    }
    pub fn clear_lastCommittedTxId(&mut self) {
        self.lastCommittedTxId = ::std::option::Option::None;
    }

    pub fn has_lastCommittedTxId(&self) -> bool {
        self.lastCommittedTxId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lastCommittedTxId(&mut self, v: u64) {
        self.lastCommittedTxId = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for PrepareRecoveryResponseProto {
    fn is_initialized(&self) -> bool {
        if self.lastWriterEpoch.is_none() {
            return false;
        }
        for v in &self.segmentState {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.segmentState)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.acceptedInEpoch = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.lastWriterEpoch = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.lastCommittedTxId = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.segmentState.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.acceptedInEpoch {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.lastWriterEpoch {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.lastCommittedTxId {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.segmentState.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.acceptedInEpoch {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.lastWriterEpoch {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.lastCommittedTxId {
            os.write_uint64(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PrepareRecoveryResponseProto {
        PrepareRecoveryResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SegmentStateProto>>(
                "segmentState",
                |m: &PrepareRecoveryResponseProto| { &m.segmentState },
                |m: &mut PrepareRecoveryResponseProto| { &mut m.segmentState },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "acceptedInEpoch",
                |m: &PrepareRecoveryResponseProto| { &m.acceptedInEpoch },
                |m: &mut PrepareRecoveryResponseProto| { &mut m.acceptedInEpoch },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "lastWriterEpoch",
                |m: &PrepareRecoveryResponseProto| { &m.lastWriterEpoch },
                |m: &mut PrepareRecoveryResponseProto| { &mut m.lastWriterEpoch },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "lastCommittedTxId",
                |m: &PrepareRecoveryResponseProto| { &m.lastCommittedTxId },
                |m: &mut PrepareRecoveryResponseProto| { &mut m.lastCommittedTxId },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PrepareRecoveryResponseProto>(
                "PrepareRecoveryResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PrepareRecoveryResponseProto {
        static instance: ::protobuf::rt::LazyV2<PrepareRecoveryResponseProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PrepareRecoveryResponseProto::new)
    }
}

impl ::protobuf::Clear for PrepareRecoveryResponseProto {
    fn clear(&mut self) {
        self.segmentState.clear();
        self.acceptedInEpoch = ::std::option::Option::None;
        self.lastWriterEpoch = ::std::option::Option::None;
        self.lastCommittedTxId = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PrepareRecoveryResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PrepareRecoveryResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AcceptRecoveryRequestProto {
    // message fields
    pub reqInfo: ::protobuf::SingularPtrField<RequestInfoProto>,
    pub stateToAccept: ::protobuf::SingularPtrField<SegmentStateProto>,
    fromURL: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AcceptRecoveryRequestProto {
    fn default() -> &'a AcceptRecoveryRequestProto {
        <AcceptRecoveryRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl AcceptRecoveryRequestProto {
    pub fn new() -> AcceptRecoveryRequestProto {
        ::std::default::Default::default()
    }

    // required .hadoop.hdfs.RequestInfoProto reqInfo = 1;


    pub fn get_reqInfo(&self) -> &RequestInfoProto {
        self.reqInfo.as_ref().unwrap_or_else(|| <RequestInfoProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_reqInfo(&mut self) {
        self.reqInfo.clear();
    }

    pub fn has_reqInfo(&self) -> bool {
        self.reqInfo.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reqInfo(&mut self, v: RequestInfoProto) {
        self.reqInfo = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reqInfo(&mut self) -> &mut RequestInfoProto {
        if self.reqInfo.is_none() {
            self.reqInfo.set_default();
        }
        self.reqInfo.as_mut().unwrap()
    }

    // Take field
    pub fn take_reqInfo(&mut self) -> RequestInfoProto {
        self.reqInfo.take().unwrap_or_else(|| RequestInfoProto::new())
    }

    // required .hadoop.hdfs.SegmentStateProto stateToAccept = 2;


    pub fn get_stateToAccept(&self) -> &SegmentStateProto {
        self.stateToAccept.as_ref().unwrap_or_else(|| <SegmentStateProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_stateToAccept(&mut self) {
        self.stateToAccept.clear();
    }

    pub fn has_stateToAccept(&self) -> bool {
        self.stateToAccept.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stateToAccept(&mut self, v: SegmentStateProto) {
        self.stateToAccept = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_stateToAccept(&mut self) -> &mut SegmentStateProto {
        if self.stateToAccept.is_none() {
            self.stateToAccept.set_default();
        }
        self.stateToAccept.as_mut().unwrap()
    }

    // Take field
    pub fn take_stateToAccept(&mut self) -> SegmentStateProto {
        self.stateToAccept.take().unwrap_or_else(|| SegmentStateProto::new())
    }

    // required string fromURL = 3;


    pub fn get_fromURL(&self) -> &str {
        match self.fromURL.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_fromURL(&mut self) {
        self.fromURL.clear();
    }

    pub fn has_fromURL(&self) -> bool {
        self.fromURL.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fromURL(&mut self, v: ::std::string::String) {
        self.fromURL = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fromURL(&mut self) -> &mut ::std::string::String {
        if self.fromURL.is_none() {
            self.fromURL.set_default();
        }
        self.fromURL.as_mut().unwrap()
    }

    // Take field
    pub fn take_fromURL(&mut self) -> ::std::string::String {
        self.fromURL.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for AcceptRecoveryRequestProto {
    fn is_initialized(&self) -> bool {
        if self.reqInfo.is_none() {
            return false;
        }
        if self.stateToAccept.is_none() {
            return false;
        }
        if self.fromURL.is_none() {
            return false;
        }
        for v in &self.reqInfo {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.stateToAccept {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.reqInfo)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.stateToAccept)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.fromURL)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.reqInfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.stateToAccept.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.fromURL.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.reqInfo.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.stateToAccept.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.fromURL.as_ref() {
            os.write_string(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AcceptRecoveryRequestProto {
        AcceptRecoveryRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RequestInfoProto>>(
                "reqInfo",
                |m: &AcceptRecoveryRequestProto| { &m.reqInfo },
                |m: &mut AcceptRecoveryRequestProto| { &mut m.reqInfo },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SegmentStateProto>>(
                "stateToAccept",
                |m: &AcceptRecoveryRequestProto| { &m.stateToAccept },
                |m: &mut AcceptRecoveryRequestProto| { &mut m.stateToAccept },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "fromURL",
                |m: &AcceptRecoveryRequestProto| { &m.fromURL },
                |m: &mut AcceptRecoveryRequestProto| { &mut m.fromURL },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AcceptRecoveryRequestProto>(
                "AcceptRecoveryRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AcceptRecoveryRequestProto {
        static instance: ::protobuf::rt::LazyV2<AcceptRecoveryRequestProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AcceptRecoveryRequestProto::new)
    }
}

impl ::protobuf::Clear for AcceptRecoveryRequestProto {
    fn clear(&mut self) {
        self.reqInfo.clear();
        self.stateToAccept.clear();
        self.fromURL.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AcceptRecoveryRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AcceptRecoveryRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AcceptRecoveryResponseProto {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AcceptRecoveryResponseProto {
    fn default() -> &'a AcceptRecoveryResponseProto {
        <AcceptRecoveryResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl AcceptRecoveryResponseProto {
    pub fn new() -> AcceptRecoveryResponseProto {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for AcceptRecoveryResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AcceptRecoveryResponseProto {
        AcceptRecoveryResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AcceptRecoveryResponseProto>(
                "AcceptRecoveryResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AcceptRecoveryResponseProto {
        static instance: ::protobuf::rt::LazyV2<AcceptRecoveryResponseProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AcceptRecoveryResponseProto::new)
    }
}

impl ::protobuf::Clear for AcceptRecoveryResponseProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AcceptRecoveryResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AcceptRecoveryResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x16QJournalProtocol.proto\x12\x0bhadoop.hdfs\x1a\nhdfs.proto\x1a\x10H\
    dfsServer.proto\"4\n\x0eJournalIdProto\x12\x20\n\nidentifier\x18\x01\x20\
    \x02(\tR\nidentifierB\0:\0\"\xe5\x01\n\x10RequestInfoProto\x12;\n\tjourn\
    alId\x18\x01\x20\x02(\x0b2\x1b.hadoop.hdfs.JournalIdProtoR\tjournalIdB\0\
    \x12\x16\n\x05epoch\x18\x02\x20\x02(\x04R\x05epochB\0\x12*\n\x0fipcSeria\
    lNumber\x18\x03\x20\x02(\x04R\x0fipcSerialNumberB\0\x12&\n\rcommittedTxI\
    d\x18\x04\x20\x01(\x04R\rcommittedTxIdB\0\x12&\n\rnameServiceId\x18\x05\
    \x20\x01(\tR\rnameServiceIdB\0:\0\"w\n\x11SegmentStateProto\x12\x1e\n\ts\
    tartTxId\x18\x01\x20\x02(\x04R\tstartTxIdB\0\x12\x1a\n\x07endTxId\x18\
    \x02\x20\x02(\x04R\x07endTxIdB\0\x12$\n\x0cisInProgress\x18\x03\x20\x02(\
    \x08R\x0cisInProgressB\0:\0\"\x90\x01\n\x1aPersistedRecoveryPaxosData\
    \x12D\n\x0csegmentState\x18\x01\x20\x02(\x0b2\x1e.hadoop.hdfs.SegmentSta\
    teProtoR\x0csegmentStateB\0\x12*\n\x0facceptedInEpoch\x18\x02\x20\x02(\
    \x04R\x0facceptedInEpochB\0:\0\"\xfa\x01\n\x13JournalRequestProto\x129\n\
    \x07reqInfo\x18\x01\x20\x02(\x0b2\x1d.hadoop.hdfs.RequestInfoProtoR\x07r\
    eqInfoB\0\x12\x20\n\nfirstTxnId\x18\x02\x20\x02(\x04R\nfirstTxnIdB\0\x12\
    \x1a\n\x07numTxns\x18\x03\x20\x02(\rR\x07numTxnsB\0\x12\x1a\n\x07records\
    \x18\x04\x20\x02(\x0cR\x07recordsB\0\x12$\n\x0csegmentTxnId\x18\x05\x20\
    \x02(\x04R\x0csegmentTxnIdB\0\x12&\n\rnameServiceId\x18\x06\x20\x01(\tR\
    \rnameServiceIdB\0:\0\"\x18\n\x14JournalResponseProto:\0\"T\n\x15Heartbe\
    atRequestProto\x129\n\x07reqInfo\x18\x01\x20\x02(\x0b2\x1d.hadoop.hdfs.R\
    equestInfoProtoR\x07reqInfoB\0:\0\"\x1a\n\x16HeartbeatResponseProto:\0\"\
    \x98\x01\n\x1bStartLogSegmentRequestProto\x129\n\x07reqInfo\x18\x01\x20\
    \x02(\x0b2\x1d.hadoop.hdfs.RequestInfoProtoR\x07reqInfoB\0\x12\x14\n\x04\
    txid\x18\x02\x20\x02(\x04R\x04txidB\0\x12&\n\rlayoutVersion\x18\x03\x20\
    \x01(\x11R\rlayoutVersionB\0:\0\"\x20\n\x1cStartLogSegmentResponseProto:\
    \0\"\x99\x01\n\x1eFinalizeLogSegmentRequestProto\x129\n\x07reqInfo\x18\
    \x01\x20\x02(\x0b2\x1d.hadoop.hdfs.RequestInfoProtoR\x07reqInfoB\0\x12\
    \x1e\n\tstartTxId\x18\x02\x20\x02(\x04R\tstartTxIdB\0\x12\x1a\n\x07endTx\
    Id\x18\x03\x20\x02(\x04R\x07endTxIdB\0:\0\"#\n\x1fFinalizeLogSegmentResp\
    onseProto:\0\"|\n\x15PurgeLogsRequestProto\x129\n\x07reqInfo\x18\x01\x20\
    \x02(\x0b2\x1d.hadoop.hdfs.RequestInfoProtoR\x07reqInfoB\0\x12&\n\rminTx\
    IdToKeep\x18\x02\x20\x02(\x04R\rminTxIdToKeepB\0:\0\"\x1a\n\x16PurgeLogs\
    ResponseProto:\0\"t\n\x17IsFormattedRequestProto\x12/\n\x03jid\x18\x01\
    \x20\x02(\x0b2\x1b.hadoop.hdfs.JournalIdProtoR\x03jidB\0\x12&\n\rnameSer\
    viceId\x18\x02\x20\x01(\tR\rnameServiceIdB\0:\0\"@\n\x18IsFormattedRespo\
    nseProto\x12\"\n\x0bisFormatted\x18\x01\x20\x02(\x08R\x0bisFormattedB\0:\
    \0\"x\n\x1bGetJournalCTimeRequestProto\x12/\n\x03jid\x18\x01\x20\x02(\
    \x0b2\x1b.hadoop.hdfs.JournalIdProtoR\x03jidB\0\x12&\n\rnameServiceId\
    \x18\x02\x20\x01(\tR\rnameServiceIdB\0:\0\"D\n\x1cGetJournalCTimeRespons\
    eProto\x12\"\n\x0bresultCTime\x18\x01\x20\x02(\x03R\x0bresultCTimeB\0:\0\
    \"M\n\x18DoPreUpgradeRequestProto\x12/\n\x03jid\x18\x01\x20\x02(\x0b2\
    \x1b.hadoop.hdfs.JournalIdProtoR\x03jidB\0:\0\"\x1d\n\x19DoPreUpgradeRes\
    ponseProto:\0\"\x81\x01\n\x15DoUpgradeRequestProto\x12/\n\x03jid\x18\x01\
    \x20\x02(\x0b2\x1b.hadoop.hdfs.JournalIdProtoR\x03jidB\0\x125\n\x05sInfo\
    \x18\x02\x20\x02(\x0b2\x1d.hadoop.hdfs.StorageInfoProtoR\x05sInfoB\0:\0\
    \"\x1a\n\x16DoUpgradeResponseProto:\0\"s\n\x16DoFinalizeRequestProto\x12\
    /\n\x03jid\x18\x01\x20\x02(\x0b2\x1b.hadoop.hdfs.JournalIdProtoR\x03jidB\
    \0\x12&\n\rnameServiceId\x18\x02\x20\x01(\tR\rnameServiceIdB\0:\0\"\x1b\
    \n\x17DoFinalizeResponseProto:\0\"\xa6\x02\n\x17CanRollBackRequestProto\
    \x12/\n\x03jid\x18\x01\x20\x02(\x0b2\x1b.hadoop.hdfs.JournalIdProtoR\x03\
    jidB\0\x129\n\x07storage\x18\x02\x20\x02(\x0b2\x1d.hadoop.hdfs.StorageIn\
    foProtoR\x07storageB\0\x12A\n\x0bprevStorage\x18\x03\x20\x02(\x0b2\x1d.h\
    adoop.hdfs.StorageInfoProtoR\x0bprevStorageB\0\x122\n\x13targetLayoutVer\
    sion\x18\x04\x20\x02(\x05R\x13targetLayoutVersionB\0\x12&\n\rnameService\
    Id\x18\x05\x20\x01(\tR\rnameServiceIdB\0:\0\"@\n\x18CanRollBackResponseP\
    roto\x12\"\n\x0bcanRollBack\x18\x01\x20\x02(\x08R\x0bcanRollBackB\0:\0\"\
    s\n\x16DoRollbackRequestProto\x12/\n\x03jid\x18\x01\x20\x02(\x0b2\x1b.ha\
    doop.hdfs.JournalIdProtoR\x03jidB\0\x12&\n\rnameserviceId\x18\x02\x20\
    \x01(\tR\rnameserviceIdB\0:\0\"\x1b\n\x17DoRollbackResponseProto:\0\"\
    \x98\x01\n\x1bDiscardSegmentsRequestProto\x12/\n\x03jid\x18\x01\x20\x02(\
    \x0b2\x1b.hadoop.hdfs.JournalIdProtoR\x03jidB\0\x12\x1e\n\tstartTxId\x18\
    \x02\x20\x02(\x04R\tstartTxIdB\0\x12&\n\rnameServiceId\x18\x03\x20\x01(\
    \tR\rnameServiceIdB\0:\0\"\x20\n\x1cDiscardSegmentsResponseProto:\0\"x\n\
    \x1bGetJournalStateRequestProto\x12/\n\x03jid\x18\x01\x20\x02(\x0b2\x1b.\
    hadoop.hdfs.JournalIdProtoR\x03jidB\0\x12&\n\rnameServiceId\x18\x02\x20\
    \x01(\tR\rnameServiceIdB\0:\0\"\x8a\x01\n\x1cGetJournalStateResponseProt\
    o\x12.\n\x11lastPromisedEpoch\x18\x01\x20\x02(\x04R\x11lastPromisedEpoch\
    B\0\x12\x1c\n\x08httpPort\x18\x02\x20\x02(\rR\x08httpPortB\0\x12\x1a\n\
    \x07fromURL\x18\x03\x20\x01(\tR\x07fromURLB\0:\0\"\xc9\x01\n\x12FormatRe\
    questProto\x12/\n\x03jid\x18\x01\x20\x02(\x0b2\x1b.hadoop.hdfs.JournalId\
    ProtoR\x03jidB\0\x129\n\x06nsInfo\x18\x02\x20\x02(\x0b2\x1f.hadoop.hdfs.\
    NamespaceInfoProtoR\x06nsInfoB\0\x12&\n\rnameServiceId\x18\x03\x20\x01(\
    \tR\rnameServiceIdB\0\x12\x1d\n\x05force\x18\x04\x20\x01(\x08:\x05falseR\
    \x05forceB\0:\0\"\x17\n\x13FormatResponseProto:\0\"\xc4\x01\n\x14NewEpoc\
    hRequestProto\x12/\n\x03jid\x18\x01\x20\x02(\x0b2\x1b.hadoop.hdfs.Journa\
    lIdProtoR\x03jidB\0\x129\n\x06nsInfo\x18\x02\x20\x02(\x0b2\x1f.hadoop.hd\
    fs.NamespaceInfoProtoR\x06nsInfoB\0\x12\x16\n\x05epoch\x18\x03\x20\x02(\
    \x04R\x05epochB\0\x12&\n\rnameServiceId\x18\x04\x20\x01(\tR\rnameService\
    IdB\0:\0\"E\n\x15NewEpochResponseProto\x12*\n\x0flastSegmentTxId\x18\x01\
    \x20\x01(\x04R\x0flastSegmentTxIdB\0:\0\"\xc8\x01\n\x1eGetEditLogManifes\
    tRequestProto\x12/\n\x03jid\x18\x01\x20\x02(\x0b2\x1b.hadoop.hdfs.Journa\
    lIdProtoR\x03jidB\0\x12\x1e\n\tsinceTxId\x18\x02\x20\x02(\x04R\tsinceTxI\
    dB\0\x12+\n\x0cinProgressOk\x18\x04\x20\x01(\x08:\x05falseR\x0cinProgres\
    sOkB\0\x12&\n\rnameServiceId\x18\x05\x20\x01(\tR\rnameServiceIdB\0:\0\"\
    \xa4\x01\n\x1fGetEditLogManifestResponseProto\x12E\n\x08manifest\x18\x01\
    \x20\x02(\x0b2'.hadoop.hdfs.RemoteEditLogManifestProtoR\x08manifestB\0\
    \x12\x1c\n\x08httpPort\x18\x02\x20\x02(\rR\x08httpPortB\0\x12\x1a\n\x07f\
    romURL\x18\x03\x20\x01(\tR\x07fromURLB\0:\0\"\xb6\x01\n\x1dGetJournaledE\
    ditsRequestProto\x12/\n\x03jid\x18\x01\x20\x02(\x0b2\x1b.hadoop.hdfs.Jou\
    rnalIdProtoR\x03jidB\0\x12\x1e\n\tsinceTxId\x18\x02\x20\x02(\x04R\tsince\
    TxIdB\0\x12\x1a\n\x07maxTxns\x18\x03\x20\x02(\rR\x07maxTxnsB\0\x12&\n\rn\
    ameServiceId\x18\x04\x20\x01(\tR\rnameServiceIdB\0:\0\"\\\n\x1eGetJourna\
    ledEditsResponseProto\x12\x1c\n\x08txnCount\x18\x01\x20\x02(\rR\x08txnCo\
    untB\0\x12\x1a\n\x07editLog\x18\x02\x20\x01(\x0cR\x07editLogB\0:\0\"~\n\
    \x1bPrepareRecoveryRequestProto\x129\n\x07reqInfo\x18\x01\x20\x02(\x0b2\
    \x1d.hadoop.hdfs.RequestInfoProtoR\x07reqInfoB\0\x12\"\n\x0bsegmentTxId\
    \x18\x02\x20\x02(\x04R\x0bsegmentTxIdB\0:\0\"\xee\x01\n\x1cPrepareRecove\
    ryResponseProto\x12D\n\x0csegmentState\x18\x01\x20\x01(\x0b2\x1e.hadoop.\
    hdfs.SegmentStateProtoR\x0csegmentStateB\0\x12*\n\x0facceptedInEpoch\x18\
    \x02\x20\x01(\x04R\x0facceptedInEpochB\0\x12*\n\x0flastWriterEpoch\x18\
    \x03\x20\x02(\x04R\x0flastWriterEpochB\0\x12.\n\x11lastCommittedTxId\x18\
    \x04\x20\x01(\x04R\x11lastCommittedTxIdB\0:\0\"\xbd\x01\n\x1aAcceptRecov\
    eryRequestProto\x129\n\x07reqInfo\x18\x01\x20\x02(\x0b2\x1d.hadoop.hdfs.\
    RequestInfoProtoR\x07reqInfoB\0\x12F\n\rstateToAccept\x18\x02\x20\x02(\
    \x0b2\x1e.hadoop.hdfs.SegmentStateProtoR\rstateToAcceptB\0\x12\x1a\n\x07\
    fromURL\x18\x03\x20\x02(\tR\x07fromURLB\0:\0\"\x1f\n\x1bAcceptRecoveryRe\
    sponseProto:\0B\0b\x06proto2\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
