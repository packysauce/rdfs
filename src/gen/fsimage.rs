// This file is generated by rust-protobuf 2.20.0. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![rustfmt::skip]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `fsimage.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_20_0;

#[derive(PartialEq,Clone,Default)]
pub struct FileSummary {
    // message fields
    ondiskVersion: ::std::option::Option<u32>,
    layoutVersion: ::std::option::Option<u32>,
    codec: ::protobuf::SingularField<::std::string::String>,
    pub sections: ::protobuf::RepeatedField<FileSummary_Section>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FileSummary {
    fn default() -> &'a FileSummary {
        <FileSummary as ::protobuf::Message>::default_instance()
    }
}

impl FileSummary {
    pub fn new() -> FileSummary {
        ::std::default::Default::default()
    }

    // required uint32 ondiskVersion = 1;


    pub fn get_ondiskVersion(&self) -> u32 {
        self.ondiskVersion.unwrap_or(0)
    }
    pub fn clear_ondiskVersion(&mut self) {
        self.ondiskVersion = ::std::option::Option::None;
    }

    pub fn has_ondiskVersion(&self) -> bool {
        self.ondiskVersion.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ondiskVersion(&mut self, v: u32) {
        self.ondiskVersion = ::std::option::Option::Some(v);
    }

    // required uint32 layoutVersion = 2;


    pub fn get_layoutVersion(&self) -> u32 {
        self.layoutVersion.unwrap_or(0)
    }
    pub fn clear_layoutVersion(&mut self) {
        self.layoutVersion = ::std::option::Option::None;
    }

    pub fn has_layoutVersion(&self) -> bool {
        self.layoutVersion.is_some()
    }

    // Param is passed by value, moved
    pub fn set_layoutVersion(&mut self, v: u32) {
        self.layoutVersion = ::std::option::Option::Some(v);
    }

    // optional string codec = 3;


    pub fn get_codec(&self) -> &str {
        match self.codec.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_codec(&mut self) {
        self.codec.clear();
    }

    pub fn has_codec(&self) -> bool {
        self.codec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_codec(&mut self, v: ::std::string::String) {
        self.codec = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_codec(&mut self) -> &mut ::std::string::String {
        if self.codec.is_none() {
            self.codec.set_default();
        }
        self.codec.as_mut().unwrap()
    }

    // Take field
    pub fn take_codec(&mut self) -> ::std::string::String {
        self.codec.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated .hadoop.hdfs.FileSummary.Section sections = 4;


    pub fn get_sections(&self) -> &[FileSummary_Section] {
        &self.sections
    }
    pub fn clear_sections(&mut self) {
        self.sections.clear();
    }

    // Param is passed by value, moved
    pub fn set_sections(&mut self, v: ::protobuf::RepeatedField<FileSummary_Section>) {
        self.sections = v;
    }

    // Mutable pointer to the field.
    pub fn mut_sections(&mut self) -> &mut ::protobuf::RepeatedField<FileSummary_Section> {
        &mut self.sections
    }

    // Take field
    pub fn take_sections(&mut self) -> ::protobuf::RepeatedField<FileSummary_Section> {
        ::std::mem::replace(&mut self.sections, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for FileSummary {
    fn is_initialized(&self) -> bool {
        if self.ondiskVersion.is_none() {
            return false;
        }
        if self.layoutVersion.is_none() {
            return false;
        }
        for v in &self.sections {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.ondiskVersion = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.layoutVersion = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.codec)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.sections)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.ondiskVersion {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.layoutVersion {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.codec.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        for value in &self.sections {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.ondiskVersion {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.layoutVersion {
            os.write_uint32(2, v)?;
        }
        if let Some(ref v) = self.codec.as_ref() {
            os.write_string(3, &v)?;
        }
        for v in &self.sections {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FileSummary {
        FileSummary::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "ondiskVersion",
                |m: &FileSummary| { &m.ondiskVersion },
                |m: &mut FileSummary| { &mut m.ondiskVersion },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "layoutVersion",
                |m: &FileSummary| { &m.layoutVersion },
                |m: &mut FileSummary| { &mut m.layoutVersion },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "codec",
                |m: &FileSummary| { &m.codec },
                |m: &mut FileSummary| { &mut m.codec },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<FileSummary_Section>>(
                "sections",
                |m: &FileSummary| { &m.sections },
                |m: &mut FileSummary| { &mut m.sections },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<FileSummary>(
                "FileSummary",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static FileSummary {
        static instance: ::protobuf::rt::LazyV2<FileSummary> = ::protobuf::rt::LazyV2::INIT;
        instance.get(FileSummary::new)
    }
}

impl ::protobuf::Clear for FileSummary {
    fn clear(&mut self) {
        self.ondiskVersion = ::std::option::Option::None;
        self.layoutVersion = ::std::option::Option::None;
        self.codec.clear();
        self.sections.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FileSummary {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FileSummary {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FileSummary_Section {
    // message fields
    name: ::protobuf::SingularField<::std::string::String>,
    length: ::std::option::Option<u64>,
    offset: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FileSummary_Section {
    fn default() -> &'a FileSummary_Section {
        <FileSummary_Section as ::protobuf::Message>::default_instance()
    }
}

impl FileSummary_Section {
    pub fn new() -> FileSummary_Section {
        ::std::default::Default::default()
    }

    // optional string name = 1;


    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint64 length = 2;


    pub fn get_length(&self) -> u64 {
        self.length.unwrap_or(0)
    }
    pub fn clear_length(&mut self) {
        self.length = ::std::option::Option::None;
    }

    pub fn has_length(&self) -> bool {
        self.length.is_some()
    }

    // Param is passed by value, moved
    pub fn set_length(&mut self, v: u64) {
        self.length = ::std::option::Option::Some(v);
    }

    // optional uint64 offset = 3;


    pub fn get_offset(&self) -> u64 {
        self.offset.unwrap_or(0)
    }
    pub fn clear_offset(&mut self) {
        self.offset = ::std::option::Option::None;
    }

    pub fn has_offset(&self) -> bool {
        self.offset.is_some()
    }

    // Param is passed by value, moved
    pub fn set_offset(&mut self, v: u64) {
        self.offset = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for FileSummary_Section {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.length = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.offset = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.length {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.offset {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.length {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.offset {
            os.write_uint64(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FileSummary_Section {
        FileSummary_Section::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &FileSummary_Section| { &m.name },
                |m: &mut FileSummary_Section| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "length",
                |m: &FileSummary_Section| { &m.length },
                |m: &mut FileSummary_Section| { &mut m.length },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "offset",
                |m: &FileSummary_Section| { &m.offset },
                |m: &mut FileSummary_Section| { &mut m.offset },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<FileSummary_Section>(
                "FileSummary.Section",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static FileSummary_Section {
        static instance: ::protobuf::rt::LazyV2<FileSummary_Section> = ::protobuf::rt::LazyV2::INIT;
        instance.get(FileSummary_Section::new)
    }
}

impl ::protobuf::Clear for FileSummary_Section {
    fn clear(&mut self) {
        self.name.clear();
        self.length = ::std::option::Option::None;
        self.offset = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FileSummary_Section {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FileSummary_Section {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct NameSystemSection {
    // message fields
    namespaceId: ::std::option::Option<u32>,
    genstampV1: ::std::option::Option<u64>,
    genstampV2: ::std::option::Option<u64>,
    genstampV1Limit: ::std::option::Option<u64>,
    lastAllocatedBlockId: ::std::option::Option<u64>,
    transactionId: ::std::option::Option<u64>,
    rollingUpgradeStartTime: ::std::option::Option<u64>,
    lastAllocatedStripedBlockId: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a NameSystemSection {
    fn default() -> &'a NameSystemSection {
        <NameSystemSection as ::protobuf::Message>::default_instance()
    }
}

impl NameSystemSection {
    pub fn new() -> NameSystemSection {
        ::std::default::Default::default()
    }

    // optional uint32 namespaceId = 1;


    pub fn get_namespaceId(&self) -> u32 {
        self.namespaceId.unwrap_or(0)
    }
    pub fn clear_namespaceId(&mut self) {
        self.namespaceId = ::std::option::Option::None;
    }

    pub fn has_namespaceId(&self) -> bool {
        self.namespaceId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_namespaceId(&mut self, v: u32) {
        self.namespaceId = ::std::option::Option::Some(v);
    }

    // optional uint64 genstampV1 = 2;


    pub fn get_genstampV1(&self) -> u64 {
        self.genstampV1.unwrap_or(0)
    }
    pub fn clear_genstampV1(&mut self) {
        self.genstampV1 = ::std::option::Option::None;
    }

    pub fn has_genstampV1(&self) -> bool {
        self.genstampV1.is_some()
    }

    // Param is passed by value, moved
    pub fn set_genstampV1(&mut self, v: u64) {
        self.genstampV1 = ::std::option::Option::Some(v);
    }

    // optional uint64 genstampV2 = 3;


    pub fn get_genstampV2(&self) -> u64 {
        self.genstampV2.unwrap_or(0)
    }
    pub fn clear_genstampV2(&mut self) {
        self.genstampV2 = ::std::option::Option::None;
    }

    pub fn has_genstampV2(&self) -> bool {
        self.genstampV2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_genstampV2(&mut self, v: u64) {
        self.genstampV2 = ::std::option::Option::Some(v);
    }

    // optional uint64 genstampV1Limit = 4;


    pub fn get_genstampV1Limit(&self) -> u64 {
        self.genstampV1Limit.unwrap_or(0)
    }
    pub fn clear_genstampV1Limit(&mut self) {
        self.genstampV1Limit = ::std::option::Option::None;
    }

    pub fn has_genstampV1Limit(&self) -> bool {
        self.genstampV1Limit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_genstampV1Limit(&mut self, v: u64) {
        self.genstampV1Limit = ::std::option::Option::Some(v);
    }

    // optional uint64 lastAllocatedBlockId = 5;


    pub fn get_lastAllocatedBlockId(&self) -> u64 {
        self.lastAllocatedBlockId.unwrap_or(0)
    }
    pub fn clear_lastAllocatedBlockId(&mut self) {
        self.lastAllocatedBlockId = ::std::option::Option::None;
    }

    pub fn has_lastAllocatedBlockId(&self) -> bool {
        self.lastAllocatedBlockId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lastAllocatedBlockId(&mut self, v: u64) {
        self.lastAllocatedBlockId = ::std::option::Option::Some(v);
    }

    // optional uint64 transactionId = 6;


    pub fn get_transactionId(&self) -> u64 {
        self.transactionId.unwrap_or(0)
    }
    pub fn clear_transactionId(&mut self) {
        self.transactionId = ::std::option::Option::None;
    }

    pub fn has_transactionId(&self) -> bool {
        self.transactionId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_transactionId(&mut self, v: u64) {
        self.transactionId = ::std::option::Option::Some(v);
    }

    // optional uint64 rollingUpgradeStartTime = 7;


    pub fn get_rollingUpgradeStartTime(&self) -> u64 {
        self.rollingUpgradeStartTime.unwrap_or(0)
    }
    pub fn clear_rollingUpgradeStartTime(&mut self) {
        self.rollingUpgradeStartTime = ::std::option::Option::None;
    }

    pub fn has_rollingUpgradeStartTime(&self) -> bool {
        self.rollingUpgradeStartTime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rollingUpgradeStartTime(&mut self, v: u64) {
        self.rollingUpgradeStartTime = ::std::option::Option::Some(v);
    }

    // optional uint64 lastAllocatedStripedBlockId = 8;


    pub fn get_lastAllocatedStripedBlockId(&self) -> u64 {
        self.lastAllocatedStripedBlockId.unwrap_or(0)
    }
    pub fn clear_lastAllocatedStripedBlockId(&mut self) {
        self.lastAllocatedStripedBlockId = ::std::option::Option::None;
    }

    pub fn has_lastAllocatedStripedBlockId(&self) -> bool {
        self.lastAllocatedStripedBlockId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lastAllocatedStripedBlockId(&mut self, v: u64) {
        self.lastAllocatedStripedBlockId = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for NameSystemSection {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.namespaceId = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.genstampV1 = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.genstampV2 = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.genstampV1Limit = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.lastAllocatedBlockId = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.transactionId = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.rollingUpgradeStartTime = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.lastAllocatedStripedBlockId = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.namespaceId {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.genstampV1 {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.genstampV2 {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.genstampV1Limit {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.lastAllocatedBlockId {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.transactionId {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.rollingUpgradeStartTime {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.lastAllocatedStripedBlockId {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.namespaceId {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.genstampV1 {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.genstampV2 {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.genstampV1Limit {
            os.write_uint64(4, v)?;
        }
        if let Some(v) = self.lastAllocatedBlockId {
            os.write_uint64(5, v)?;
        }
        if let Some(v) = self.transactionId {
            os.write_uint64(6, v)?;
        }
        if let Some(v) = self.rollingUpgradeStartTime {
            os.write_uint64(7, v)?;
        }
        if let Some(v) = self.lastAllocatedStripedBlockId {
            os.write_uint64(8, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NameSystemSection {
        NameSystemSection::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "namespaceId",
                |m: &NameSystemSection| { &m.namespaceId },
                |m: &mut NameSystemSection| { &mut m.namespaceId },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "genstampV1",
                |m: &NameSystemSection| { &m.genstampV1 },
                |m: &mut NameSystemSection| { &mut m.genstampV1 },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "genstampV2",
                |m: &NameSystemSection| { &m.genstampV2 },
                |m: &mut NameSystemSection| { &mut m.genstampV2 },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "genstampV1Limit",
                |m: &NameSystemSection| { &m.genstampV1Limit },
                |m: &mut NameSystemSection| { &mut m.genstampV1Limit },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "lastAllocatedBlockId",
                |m: &NameSystemSection| { &m.lastAllocatedBlockId },
                |m: &mut NameSystemSection| { &mut m.lastAllocatedBlockId },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "transactionId",
                |m: &NameSystemSection| { &m.transactionId },
                |m: &mut NameSystemSection| { &mut m.transactionId },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "rollingUpgradeStartTime",
                |m: &NameSystemSection| { &m.rollingUpgradeStartTime },
                |m: &mut NameSystemSection| { &mut m.rollingUpgradeStartTime },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "lastAllocatedStripedBlockId",
                |m: &NameSystemSection| { &m.lastAllocatedStripedBlockId },
                |m: &mut NameSystemSection| { &mut m.lastAllocatedStripedBlockId },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<NameSystemSection>(
                "NameSystemSection",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static NameSystemSection {
        static instance: ::protobuf::rt::LazyV2<NameSystemSection> = ::protobuf::rt::LazyV2::INIT;
        instance.get(NameSystemSection::new)
    }
}

impl ::protobuf::Clear for NameSystemSection {
    fn clear(&mut self) {
        self.namespaceId = ::std::option::Option::None;
        self.genstampV1 = ::std::option::Option::None;
        self.genstampV2 = ::std::option::Option::None;
        self.genstampV1Limit = ::std::option::Option::None;
        self.lastAllocatedBlockId = ::std::option::Option::None;
        self.transactionId = ::std::option::Option::None;
        self.rollingUpgradeStartTime = ::std::option::Option::None;
        self.lastAllocatedStripedBlockId = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NameSystemSection {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NameSystemSection {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct INodeSection {
    // message fields
    lastInodeId: ::std::option::Option<u64>,
    numInodes: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a INodeSection {
    fn default() -> &'a INodeSection {
        <INodeSection as ::protobuf::Message>::default_instance()
    }
}

impl INodeSection {
    pub fn new() -> INodeSection {
        ::std::default::Default::default()
    }

    // optional uint64 lastInodeId = 1;


    pub fn get_lastInodeId(&self) -> u64 {
        self.lastInodeId.unwrap_or(0)
    }
    pub fn clear_lastInodeId(&mut self) {
        self.lastInodeId = ::std::option::Option::None;
    }

    pub fn has_lastInodeId(&self) -> bool {
        self.lastInodeId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lastInodeId(&mut self, v: u64) {
        self.lastInodeId = ::std::option::Option::Some(v);
    }

    // optional uint64 numInodes = 2;


    pub fn get_numInodes(&self) -> u64 {
        self.numInodes.unwrap_or(0)
    }
    pub fn clear_numInodes(&mut self) {
        self.numInodes = ::std::option::Option::None;
    }

    pub fn has_numInodes(&self) -> bool {
        self.numInodes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_numInodes(&mut self, v: u64) {
        self.numInodes = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for INodeSection {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.lastInodeId = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.numInodes = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.lastInodeId {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.numInodes {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.lastInodeId {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.numInodes {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> INodeSection {
        INodeSection::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "lastInodeId",
                |m: &INodeSection| { &m.lastInodeId },
                |m: &mut INodeSection| { &mut m.lastInodeId },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "numInodes",
                |m: &INodeSection| { &m.numInodes },
                |m: &mut INodeSection| { &mut m.numInodes },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<INodeSection>(
                "INodeSection",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static INodeSection {
        static instance: ::protobuf::rt::LazyV2<INodeSection> = ::protobuf::rt::LazyV2::INIT;
        instance.get(INodeSection::new)
    }
}

impl ::protobuf::Clear for INodeSection {
    fn clear(&mut self) {
        self.lastInodeId = ::std::option::Option::None;
        self.numInodes = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for INodeSection {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for INodeSection {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct INodeSection_FileUnderConstructionFeature {
    // message fields
    clientName: ::protobuf::SingularField<::std::string::String>,
    clientMachine: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a INodeSection_FileUnderConstructionFeature {
    fn default() -> &'a INodeSection_FileUnderConstructionFeature {
        <INodeSection_FileUnderConstructionFeature as ::protobuf::Message>::default_instance()
    }
}

impl INodeSection_FileUnderConstructionFeature {
    pub fn new() -> INodeSection_FileUnderConstructionFeature {
        ::std::default::Default::default()
    }

    // optional string clientName = 1;


    pub fn get_clientName(&self) -> &str {
        match self.clientName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_clientName(&mut self) {
        self.clientName.clear();
    }

    pub fn has_clientName(&self) -> bool {
        self.clientName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_clientName(&mut self, v: ::std::string::String) {
        self.clientName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_clientName(&mut self) -> &mut ::std::string::String {
        if self.clientName.is_none() {
            self.clientName.set_default();
        }
        self.clientName.as_mut().unwrap()
    }

    // Take field
    pub fn take_clientName(&mut self) -> ::std::string::String {
        self.clientName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string clientMachine = 2;


    pub fn get_clientMachine(&self) -> &str {
        match self.clientMachine.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_clientMachine(&mut self) {
        self.clientMachine.clear();
    }

    pub fn has_clientMachine(&self) -> bool {
        self.clientMachine.is_some()
    }

    // Param is passed by value, moved
    pub fn set_clientMachine(&mut self, v: ::std::string::String) {
        self.clientMachine = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_clientMachine(&mut self) -> &mut ::std::string::String {
        if self.clientMachine.is_none() {
            self.clientMachine.set_default();
        }
        self.clientMachine.as_mut().unwrap()
    }

    // Take field
    pub fn take_clientMachine(&mut self) -> ::std::string::String {
        self.clientMachine.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for INodeSection_FileUnderConstructionFeature {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.clientName)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.clientMachine)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.clientName.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.clientMachine.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.clientName.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.clientMachine.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> INodeSection_FileUnderConstructionFeature {
        INodeSection_FileUnderConstructionFeature::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "clientName",
                |m: &INodeSection_FileUnderConstructionFeature| { &m.clientName },
                |m: &mut INodeSection_FileUnderConstructionFeature| { &mut m.clientName },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "clientMachine",
                |m: &INodeSection_FileUnderConstructionFeature| { &m.clientMachine },
                |m: &mut INodeSection_FileUnderConstructionFeature| { &mut m.clientMachine },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<INodeSection_FileUnderConstructionFeature>(
                "INodeSection.FileUnderConstructionFeature",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static INodeSection_FileUnderConstructionFeature {
        static instance: ::protobuf::rt::LazyV2<INodeSection_FileUnderConstructionFeature> = ::protobuf::rt::LazyV2::INIT;
        instance.get(INodeSection_FileUnderConstructionFeature::new)
    }
}

impl ::protobuf::Clear for INodeSection_FileUnderConstructionFeature {
    fn clear(&mut self) {
        self.clientName.clear();
        self.clientMachine.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for INodeSection_FileUnderConstructionFeature {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for INodeSection_FileUnderConstructionFeature {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct INodeSection_AclFeatureProto {
    // message fields
    pub entries: ::std::vec::Vec<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a INodeSection_AclFeatureProto {
    fn default() -> &'a INodeSection_AclFeatureProto {
        <INodeSection_AclFeatureProto as ::protobuf::Message>::default_instance()
    }
}

impl INodeSection_AclFeatureProto {
    pub fn new() -> INodeSection_AclFeatureProto {
        ::std::default::Default::default()
    }

    // repeated fixed32 entries = 2;


    pub fn get_entries(&self) -> &[u32] {
        &self.entries
    }
    pub fn clear_entries(&mut self) {
        self.entries.clear();
    }

    // Param is passed by value, moved
    pub fn set_entries(&mut self, v: ::std::vec::Vec<u32>) {
        self.entries = v;
    }

    // Mutable pointer to the field.
    pub fn mut_entries(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.entries
    }

    // Take field
    pub fn take_entries(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.entries, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for INodeSection_AclFeatureProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                2 => {
                    ::protobuf::rt::read_repeated_fixed32_into(wire_type, is, &mut self.entries)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.entries.is_empty() {
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size((self.entries.len() * 4) as u32) + (self.entries.len() * 4) as u32;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.entries.is_empty() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            // TODO: Data size is computed again, it should be cached
            os.write_raw_varint32((self.entries.len() * 4) as u32)?;
            for v in &self.entries {
                os.write_fixed32_no_tag(*v)?;
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> INodeSection_AclFeatureProto {
        INodeSection_AclFeatureProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "entries",
                |m: &INodeSection_AclFeatureProto| { &m.entries },
                |m: &mut INodeSection_AclFeatureProto| { &mut m.entries },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<INodeSection_AclFeatureProto>(
                "INodeSection.AclFeatureProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static INodeSection_AclFeatureProto {
        static instance: ::protobuf::rt::LazyV2<INodeSection_AclFeatureProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(INodeSection_AclFeatureProto::new)
    }
}

impl ::protobuf::Clear for INodeSection_AclFeatureProto {
    fn clear(&mut self) {
        self.entries.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for INodeSection_AclFeatureProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for INodeSection_AclFeatureProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct INodeSection_XAttrCompactProto {
    // message fields
    name: ::std::option::Option<u32>,
    value: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a INodeSection_XAttrCompactProto {
    fn default() -> &'a INodeSection_XAttrCompactProto {
        <INodeSection_XAttrCompactProto as ::protobuf::Message>::default_instance()
    }
}

impl INodeSection_XAttrCompactProto {
    pub fn new() -> INodeSection_XAttrCompactProto {
        ::std::default::Default::default()
    }

    // required fixed32 name = 1;


    pub fn get_name(&self) -> u32 {
        self.name.unwrap_or(0)
    }
    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: u32) {
        self.name = ::std::option::Option::Some(v);
    }

    // optional bytes value = 2;


    pub fn get_value(&self) -> &[u8] {
        match self.value.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::vec::Vec<u8>) {
        self.value = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.value.is_none() {
            self.value.set_default();
        }
        self.value.as_mut().unwrap()
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::vec::Vec<u8> {
        self.value.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for INodeSection_XAttrCompactProto {
    fn is_initialized(&self) -> bool {
        if self.name.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.name = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.value)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.name {
            my_size += 5;
        }
        if let Some(ref v) = self.value.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.name {
            os.write_fixed32(1, v)?;
        }
        if let Some(ref v) = self.value.as_ref() {
            os.write_bytes(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> INodeSection_XAttrCompactProto {
        INodeSection_XAttrCompactProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "name",
                |m: &INodeSection_XAttrCompactProto| { &m.name },
                |m: &mut INodeSection_XAttrCompactProto| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "value",
                |m: &INodeSection_XAttrCompactProto| { &m.value },
                |m: &mut INodeSection_XAttrCompactProto| { &mut m.value },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<INodeSection_XAttrCompactProto>(
                "INodeSection.XAttrCompactProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static INodeSection_XAttrCompactProto {
        static instance: ::protobuf::rt::LazyV2<INodeSection_XAttrCompactProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(INodeSection_XAttrCompactProto::new)
    }
}

impl ::protobuf::Clear for INodeSection_XAttrCompactProto {
    fn clear(&mut self) {
        self.name = ::std::option::Option::None;
        self.value.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for INodeSection_XAttrCompactProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for INodeSection_XAttrCompactProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct INodeSection_XAttrFeatureProto {
    // message fields
    pub xAttrs: ::protobuf::RepeatedField<INodeSection_XAttrCompactProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a INodeSection_XAttrFeatureProto {
    fn default() -> &'a INodeSection_XAttrFeatureProto {
        <INodeSection_XAttrFeatureProto as ::protobuf::Message>::default_instance()
    }
}

impl INodeSection_XAttrFeatureProto {
    pub fn new() -> INodeSection_XAttrFeatureProto {
        ::std::default::Default::default()
    }

    // repeated .hadoop.hdfs.INodeSection.XAttrCompactProto xAttrs = 1;


    pub fn get_xAttrs(&self) -> &[INodeSection_XAttrCompactProto] {
        &self.xAttrs
    }
    pub fn clear_xAttrs(&mut self) {
        self.xAttrs.clear();
    }

    // Param is passed by value, moved
    pub fn set_xAttrs(&mut self, v: ::protobuf::RepeatedField<INodeSection_XAttrCompactProto>) {
        self.xAttrs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_xAttrs(&mut self) -> &mut ::protobuf::RepeatedField<INodeSection_XAttrCompactProto> {
        &mut self.xAttrs
    }

    // Take field
    pub fn take_xAttrs(&mut self) -> ::protobuf::RepeatedField<INodeSection_XAttrCompactProto> {
        ::std::mem::replace(&mut self.xAttrs, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for INodeSection_XAttrFeatureProto {
    fn is_initialized(&self) -> bool {
        for v in &self.xAttrs {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.xAttrs)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.xAttrs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.xAttrs {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> INodeSection_XAttrFeatureProto {
        INodeSection_XAttrFeatureProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<INodeSection_XAttrCompactProto>>(
                "xAttrs",
                |m: &INodeSection_XAttrFeatureProto| { &m.xAttrs },
                |m: &mut INodeSection_XAttrFeatureProto| { &mut m.xAttrs },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<INodeSection_XAttrFeatureProto>(
                "INodeSection.XAttrFeatureProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static INodeSection_XAttrFeatureProto {
        static instance: ::protobuf::rt::LazyV2<INodeSection_XAttrFeatureProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(INodeSection_XAttrFeatureProto::new)
    }
}

impl ::protobuf::Clear for INodeSection_XAttrFeatureProto {
    fn clear(&mut self) {
        self.xAttrs.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for INodeSection_XAttrFeatureProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for INodeSection_XAttrFeatureProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct INodeSection_INodeFile {
    // message fields
    replication: ::std::option::Option<u32>,
    modificationTime: ::std::option::Option<u64>,
    accessTime: ::std::option::Option<u64>,
    preferredBlockSize: ::std::option::Option<u64>,
    permission: ::std::option::Option<u64>,
    pub blocks: ::protobuf::RepeatedField<super::hdfs::BlockProto>,
    pub fileUC: ::protobuf::SingularPtrField<INodeSection_FileUnderConstructionFeature>,
    pub acl: ::protobuf::SingularPtrField<INodeSection_AclFeatureProto>,
    pub xAttrs: ::protobuf::SingularPtrField<INodeSection_XAttrFeatureProto>,
    storagePolicyID: ::std::option::Option<u32>,
    blockType: ::std::option::Option<super::hdfs::BlockTypeProto>,
    erasureCodingPolicyID: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a INodeSection_INodeFile {
    fn default() -> &'a INodeSection_INodeFile {
        <INodeSection_INodeFile as ::protobuf::Message>::default_instance()
    }
}

impl INodeSection_INodeFile {
    pub fn new() -> INodeSection_INodeFile {
        ::std::default::Default::default()
    }

    // optional uint32 replication = 1;


    pub fn get_replication(&self) -> u32 {
        self.replication.unwrap_or(0)
    }
    pub fn clear_replication(&mut self) {
        self.replication = ::std::option::Option::None;
    }

    pub fn has_replication(&self) -> bool {
        self.replication.is_some()
    }

    // Param is passed by value, moved
    pub fn set_replication(&mut self, v: u32) {
        self.replication = ::std::option::Option::Some(v);
    }

    // optional uint64 modificationTime = 2;


    pub fn get_modificationTime(&self) -> u64 {
        self.modificationTime.unwrap_or(0)
    }
    pub fn clear_modificationTime(&mut self) {
        self.modificationTime = ::std::option::Option::None;
    }

    pub fn has_modificationTime(&self) -> bool {
        self.modificationTime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_modificationTime(&mut self, v: u64) {
        self.modificationTime = ::std::option::Option::Some(v);
    }

    // optional uint64 accessTime = 3;


    pub fn get_accessTime(&self) -> u64 {
        self.accessTime.unwrap_or(0)
    }
    pub fn clear_accessTime(&mut self) {
        self.accessTime = ::std::option::Option::None;
    }

    pub fn has_accessTime(&self) -> bool {
        self.accessTime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_accessTime(&mut self, v: u64) {
        self.accessTime = ::std::option::Option::Some(v);
    }

    // optional uint64 preferredBlockSize = 4;


    pub fn get_preferredBlockSize(&self) -> u64 {
        self.preferredBlockSize.unwrap_or(0)
    }
    pub fn clear_preferredBlockSize(&mut self) {
        self.preferredBlockSize = ::std::option::Option::None;
    }

    pub fn has_preferredBlockSize(&self) -> bool {
        self.preferredBlockSize.is_some()
    }

    // Param is passed by value, moved
    pub fn set_preferredBlockSize(&mut self, v: u64) {
        self.preferredBlockSize = ::std::option::Option::Some(v);
    }

    // optional fixed64 permission = 5;


    pub fn get_permission(&self) -> u64 {
        self.permission.unwrap_or(0)
    }
    pub fn clear_permission(&mut self) {
        self.permission = ::std::option::Option::None;
    }

    pub fn has_permission(&self) -> bool {
        self.permission.is_some()
    }

    // Param is passed by value, moved
    pub fn set_permission(&mut self, v: u64) {
        self.permission = ::std::option::Option::Some(v);
    }

    // repeated .hadoop.hdfs.BlockProto blocks = 6;


    pub fn get_blocks(&self) -> &[super::hdfs::BlockProto] {
        &self.blocks
    }
    pub fn clear_blocks(&mut self) {
        self.blocks.clear();
    }

    // Param is passed by value, moved
    pub fn set_blocks(&mut self, v: ::protobuf::RepeatedField<super::hdfs::BlockProto>) {
        self.blocks = v;
    }

    // Mutable pointer to the field.
    pub fn mut_blocks(&mut self) -> &mut ::protobuf::RepeatedField<super::hdfs::BlockProto> {
        &mut self.blocks
    }

    // Take field
    pub fn take_blocks(&mut self) -> ::protobuf::RepeatedField<super::hdfs::BlockProto> {
        ::std::mem::replace(&mut self.blocks, ::protobuf::RepeatedField::new())
    }

    // optional .hadoop.hdfs.INodeSection.FileUnderConstructionFeature fileUC = 7;


    pub fn get_fileUC(&self) -> &INodeSection_FileUnderConstructionFeature {
        self.fileUC.as_ref().unwrap_or_else(|| <INodeSection_FileUnderConstructionFeature as ::protobuf::Message>::default_instance())
    }
    pub fn clear_fileUC(&mut self) {
        self.fileUC.clear();
    }

    pub fn has_fileUC(&self) -> bool {
        self.fileUC.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fileUC(&mut self, v: INodeSection_FileUnderConstructionFeature) {
        self.fileUC = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fileUC(&mut self) -> &mut INodeSection_FileUnderConstructionFeature {
        if self.fileUC.is_none() {
            self.fileUC.set_default();
        }
        self.fileUC.as_mut().unwrap()
    }

    // Take field
    pub fn take_fileUC(&mut self) -> INodeSection_FileUnderConstructionFeature {
        self.fileUC.take().unwrap_or_else(|| INodeSection_FileUnderConstructionFeature::new())
    }

    // optional .hadoop.hdfs.INodeSection.AclFeatureProto acl = 8;


    pub fn get_acl(&self) -> &INodeSection_AclFeatureProto {
        self.acl.as_ref().unwrap_or_else(|| <INodeSection_AclFeatureProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_acl(&mut self) {
        self.acl.clear();
    }

    pub fn has_acl(&self) -> bool {
        self.acl.is_some()
    }

    // Param is passed by value, moved
    pub fn set_acl(&mut self, v: INodeSection_AclFeatureProto) {
        self.acl = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_acl(&mut self) -> &mut INodeSection_AclFeatureProto {
        if self.acl.is_none() {
            self.acl.set_default();
        }
        self.acl.as_mut().unwrap()
    }

    // Take field
    pub fn take_acl(&mut self) -> INodeSection_AclFeatureProto {
        self.acl.take().unwrap_or_else(|| INodeSection_AclFeatureProto::new())
    }

    // optional .hadoop.hdfs.INodeSection.XAttrFeatureProto xAttrs = 9;


    pub fn get_xAttrs(&self) -> &INodeSection_XAttrFeatureProto {
        self.xAttrs.as_ref().unwrap_or_else(|| <INodeSection_XAttrFeatureProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_xAttrs(&mut self) {
        self.xAttrs.clear();
    }

    pub fn has_xAttrs(&self) -> bool {
        self.xAttrs.is_some()
    }

    // Param is passed by value, moved
    pub fn set_xAttrs(&mut self, v: INodeSection_XAttrFeatureProto) {
        self.xAttrs = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_xAttrs(&mut self) -> &mut INodeSection_XAttrFeatureProto {
        if self.xAttrs.is_none() {
            self.xAttrs.set_default();
        }
        self.xAttrs.as_mut().unwrap()
    }

    // Take field
    pub fn take_xAttrs(&mut self) -> INodeSection_XAttrFeatureProto {
        self.xAttrs.take().unwrap_or_else(|| INodeSection_XAttrFeatureProto::new())
    }

    // optional uint32 storagePolicyID = 10;


    pub fn get_storagePolicyID(&self) -> u32 {
        self.storagePolicyID.unwrap_or(0)
    }
    pub fn clear_storagePolicyID(&mut self) {
        self.storagePolicyID = ::std::option::Option::None;
    }

    pub fn has_storagePolicyID(&self) -> bool {
        self.storagePolicyID.is_some()
    }

    // Param is passed by value, moved
    pub fn set_storagePolicyID(&mut self, v: u32) {
        self.storagePolicyID = ::std::option::Option::Some(v);
    }

    // optional .hadoop.hdfs.BlockTypeProto blockType = 11;


    pub fn get_blockType(&self) -> super::hdfs::BlockTypeProto {
        self.blockType.unwrap_or(super::hdfs::BlockTypeProto::CONTIGUOUS)
    }
    pub fn clear_blockType(&mut self) {
        self.blockType = ::std::option::Option::None;
    }

    pub fn has_blockType(&self) -> bool {
        self.blockType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_blockType(&mut self, v: super::hdfs::BlockTypeProto) {
        self.blockType = ::std::option::Option::Some(v);
    }

    // optional uint32 erasureCodingPolicyID = 12;


    pub fn get_erasureCodingPolicyID(&self) -> u32 {
        self.erasureCodingPolicyID.unwrap_or(0)
    }
    pub fn clear_erasureCodingPolicyID(&mut self) {
        self.erasureCodingPolicyID = ::std::option::Option::None;
    }

    pub fn has_erasureCodingPolicyID(&self) -> bool {
        self.erasureCodingPolicyID.is_some()
    }

    // Param is passed by value, moved
    pub fn set_erasureCodingPolicyID(&mut self, v: u32) {
        self.erasureCodingPolicyID = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for INodeSection_INodeFile {
    fn is_initialized(&self) -> bool {
        for v in &self.blocks {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.fileUC {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.acl {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.xAttrs {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.replication = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.modificationTime = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.accessTime = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.preferredBlockSize = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.permission = ::std::option::Option::Some(tmp);
                },
                6 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.blocks)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.fileUC)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.acl)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.xAttrs)?;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.storagePolicyID = ::std::option::Option::Some(tmp);
                },
                11 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.blockType, 11, &mut self.unknown_fields)?
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.erasureCodingPolicyID = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.replication {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.modificationTime {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.accessTime {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.preferredBlockSize {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.permission {
            my_size += 9;
        }
        for value in &self.blocks {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.fileUC.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.acl.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.xAttrs.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.storagePolicyID {
            my_size += ::protobuf::rt::value_size(10, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.blockType {
            my_size += ::protobuf::rt::enum_size(11, v);
        }
        if let Some(v) = self.erasureCodingPolicyID {
            my_size += ::protobuf::rt::value_size(12, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.replication {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.modificationTime {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.accessTime {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.preferredBlockSize {
            os.write_uint64(4, v)?;
        }
        if let Some(v) = self.permission {
            os.write_fixed64(5, v)?;
        }
        for v in &self.blocks {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.fileUC.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.acl.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.xAttrs.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.storagePolicyID {
            os.write_uint32(10, v)?;
        }
        if let Some(v) = self.blockType {
            os.write_enum(11, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(v) = self.erasureCodingPolicyID {
            os.write_uint32(12, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> INodeSection_INodeFile {
        INodeSection_INodeFile::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "replication",
                |m: &INodeSection_INodeFile| { &m.replication },
                |m: &mut INodeSection_INodeFile| { &mut m.replication },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "modificationTime",
                |m: &INodeSection_INodeFile| { &m.modificationTime },
                |m: &mut INodeSection_INodeFile| { &mut m.modificationTime },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "accessTime",
                |m: &INodeSection_INodeFile| { &m.accessTime },
                |m: &mut INodeSection_INodeFile| { &mut m.accessTime },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "preferredBlockSize",
                |m: &INodeSection_INodeFile| { &m.preferredBlockSize },
                |m: &mut INodeSection_INodeFile| { &mut m.preferredBlockSize },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "permission",
                |m: &INodeSection_INodeFile| { &m.permission },
                |m: &mut INodeSection_INodeFile| { &mut m.permission },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::hdfs::BlockProto>>(
                "blocks",
                |m: &INodeSection_INodeFile| { &m.blocks },
                |m: &mut INodeSection_INodeFile| { &mut m.blocks },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<INodeSection_FileUnderConstructionFeature>>(
                "fileUC",
                |m: &INodeSection_INodeFile| { &m.fileUC },
                |m: &mut INodeSection_INodeFile| { &mut m.fileUC },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<INodeSection_AclFeatureProto>>(
                "acl",
                |m: &INodeSection_INodeFile| { &m.acl },
                |m: &mut INodeSection_INodeFile| { &mut m.acl },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<INodeSection_XAttrFeatureProto>>(
                "xAttrs",
                |m: &INodeSection_INodeFile| { &m.xAttrs },
                |m: &mut INodeSection_INodeFile| { &mut m.xAttrs },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "storagePolicyID",
                |m: &INodeSection_INodeFile| { &m.storagePolicyID },
                |m: &mut INodeSection_INodeFile| { &mut m.storagePolicyID },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<super::hdfs::BlockTypeProto>>(
                "blockType",
                |m: &INodeSection_INodeFile| { &m.blockType },
                |m: &mut INodeSection_INodeFile| { &mut m.blockType },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "erasureCodingPolicyID",
                |m: &INodeSection_INodeFile| { &m.erasureCodingPolicyID },
                |m: &mut INodeSection_INodeFile| { &mut m.erasureCodingPolicyID },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<INodeSection_INodeFile>(
                "INodeSection.INodeFile",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static INodeSection_INodeFile {
        static instance: ::protobuf::rt::LazyV2<INodeSection_INodeFile> = ::protobuf::rt::LazyV2::INIT;
        instance.get(INodeSection_INodeFile::new)
    }
}

impl ::protobuf::Clear for INodeSection_INodeFile {
    fn clear(&mut self) {
        self.replication = ::std::option::Option::None;
        self.modificationTime = ::std::option::Option::None;
        self.accessTime = ::std::option::Option::None;
        self.preferredBlockSize = ::std::option::Option::None;
        self.permission = ::std::option::Option::None;
        self.blocks.clear();
        self.fileUC.clear();
        self.acl.clear();
        self.xAttrs.clear();
        self.storagePolicyID = ::std::option::Option::None;
        self.blockType = ::std::option::Option::None;
        self.erasureCodingPolicyID = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for INodeSection_INodeFile {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for INodeSection_INodeFile {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct INodeSection_QuotaByStorageTypeEntryProto {
    // message fields
    storageType: ::std::option::Option<super::hdfs::StorageTypeProto>,
    quota: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a INodeSection_QuotaByStorageTypeEntryProto {
    fn default() -> &'a INodeSection_QuotaByStorageTypeEntryProto {
        <INodeSection_QuotaByStorageTypeEntryProto as ::protobuf::Message>::default_instance()
    }
}

impl INodeSection_QuotaByStorageTypeEntryProto {
    pub fn new() -> INodeSection_QuotaByStorageTypeEntryProto {
        ::std::default::Default::default()
    }

    // required .hadoop.hdfs.StorageTypeProto storageType = 1;


    pub fn get_storageType(&self) -> super::hdfs::StorageTypeProto {
        self.storageType.unwrap_or(super::hdfs::StorageTypeProto::DISK)
    }
    pub fn clear_storageType(&mut self) {
        self.storageType = ::std::option::Option::None;
    }

    pub fn has_storageType(&self) -> bool {
        self.storageType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_storageType(&mut self, v: super::hdfs::StorageTypeProto) {
        self.storageType = ::std::option::Option::Some(v);
    }

    // required uint64 quota = 2;


    pub fn get_quota(&self) -> u64 {
        self.quota.unwrap_or(0)
    }
    pub fn clear_quota(&mut self) {
        self.quota = ::std::option::Option::None;
    }

    pub fn has_quota(&self) -> bool {
        self.quota.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quota(&mut self, v: u64) {
        self.quota = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for INodeSection_QuotaByStorageTypeEntryProto {
    fn is_initialized(&self) -> bool {
        if self.storageType.is_none() {
            return false;
        }
        if self.quota.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.storageType, 1, &mut self.unknown_fields)?
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.quota = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.storageType {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        if let Some(v) = self.quota {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.storageType {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(v) = self.quota {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> INodeSection_QuotaByStorageTypeEntryProto {
        INodeSection_QuotaByStorageTypeEntryProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<super::hdfs::StorageTypeProto>>(
                "storageType",
                |m: &INodeSection_QuotaByStorageTypeEntryProto| { &m.storageType },
                |m: &mut INodeSection_QuotaByStorageTypeEntryProto| { &mut m.storageType },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "quota",
                |m: &INodeSection_QuotaByStorageTypeEntryProto| { &m.quota },
                |m: &mut INodeSection_QuotaByStorageTypeEntryProto| { &mut m.quota },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<INodeSection_QuotaByStorageTypeEntryProto>(
                "INodeSection.QuotaByStorageTypeEntryProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static INodeSection_QuotaByStorageTypeEntryProto {
        static instance: ::protobuf::rt::LazyV2<INodeSection_QuotaByStorageTypeEntryProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(INodeSection_QuotaByStorageTypeEntryProto::new)
    }
}

impl ::protobuf::Clear for INodeSection_QuotaByStorageTypeEntryProto {
    fn clear(&mut self) {
        self.storageType = ::std::option::Option::None;
        self.quota = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for INodeSection_QuotaByStorageTypeEntryProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for INodeSection_QuotaByStorageTypeEntryProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct INodeSection_QuotaByStorageTypeFeatureProto {
    // message fields
    pub quotas: ::protobuf::RepeatedField<INodeSection_QuotaByStorageTypeEntryProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a INodeSection_QuotaByStorageTypeFeatureProto {
    fn default() -> &'a INodeSection_QuotaByStorageTypeFeatureProto {
        <INodeSection_QuotaByStorageTypeFeatureProto as ::protobuf::Message>::default_instance()
    }
}

impl INodeSection_QuotaByStorageTypeFeatureProto {
    pub fn new() -> INodeSection_QuotaByStorageTypeFeatureProto {
        ::std::default::Default::default()
    }

    // repeated .hadoop.hdfs.INodeSection.QuotaByStorageTypeEntryProto quotas = 1;


    pub fn get_quotas(&self) -> &[INodeSection_QuotaByStorageTypeEntryProto] {
        &self.quotas
    }
    pub fn clear_quotas(&mut self) {
        self.quotas.clear();
    }

    // Param is passed by value, moved
    pub fn set_quotas(&mut self, v: ::protobuf::RepeatedField<INodeSection_QuotaByStorageTypeEntryProto>) {
        self.quotas = v;
    }

    // Mutable pointer to the field.
    pub fn mut_quotas(&mut self) -> &mut ::protobuf::RepeatedField<INodeSection_QuotaByStorageTypeEntryProto> {
        &mut self.quotas
    }

    // Take field
    pub fn take_quotas(&mut self) -> ::protobuf::RepeatedField<INodeSection_QuotaByStorageTypeEntryProto> {
        ::std::mem::replace(&mut self.quotas, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for INodeSection_QuotaByStorageTypeFeatureProto {
    fn is_initialized(&self) -> bool {
        for v in &self.quotas {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.quotas)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.quotas {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.quotas {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> INodeSection_QuotaByStorageTypeFeatureProto {
        INodeSection_QuotaByStorageTypeFeatureProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<INodeSection_QuotaByStorageTypeEntryProto>>(
                "quotas",
                |m: &INodeSection_QuotaByStorageTypeFeatureProto| { &m.quotas },
                |m: &mut INodeSection_QuotaByStorageTypeFeatureProto| { &mut m.quotas },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<INodeSection_QuotaByStorageTypeFeatureProto>(
                "INodeSection.QuotaByStorageTypeFeatureProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static INodeSection_QuotaByStorageTypeFeatureProto {
        static instance: ::protobuf::rt::LazyV2<INodeSection_QuotaByStorageTypeFeatureProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(INodeSection_QuotaByStorageTypeFeatureProto::new)
    }
}

impl ::protobuf::Clear for INodeSection_QuotaByStorageTypeFeatureProto {
    fn clear(&mut self) {
        self.quotas.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for INodeSection_QuotaByStorageTypeFeatureProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for INodeSection_QuotaByStorageTypeFeatureProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct INodeSection_INodeDirectory {
    // message fields
    modificationTime: ::std::option::Option<u64>,
    nsQuota: ::std::option::Option<u64>,
    dsQuota: ::std::option::Option<u64>,
    permission: ::std::option::Option<u64>,
    pub acl: ::protobuf::SingularPtrField<INodeSection_AclFeatureProto>,
    pub xAttrs: ::protobuf::SingularPtrField<INodeSection_XAttrFeatureProto>,
    pub typeQuotas: ::protobuf::SingularPtrField<INodeSection_QuotaByStorageTypeFeatureProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a INodeSection_INodeDirectory {
    fn default() -> &'a INodeSection_INodeDirectory {
        <INodeSection_INodeDirectory as ::protobuf::Message>::default_instance()
    }
}

impl INodeSection_INodeDirectory {
    pub fn new() -> INodeSection_INodeDirectory {
        ::std::default::Default::default()
    }

    // optional uint64 modificationTime = 1;


    pub fn get_modificationTime(&self) -> u64 {
        self.modificationTime.unwrap_or(0)
    }
    pub fn clear_modificationTime(&mut self) {
        self.modificationTime = ::std::option::Option::None;
    }

    pub fn has_modificationTime(&self) -> bool {
        self.modificationTime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_modificationTime(&mut self, v: u64) {
        self.modificationTime = ::std::option::Option::Some(v);
    }

    // optional uint64 nsQuota = 2;


    pub fn get_nsQuota(&self) -> u64 {
        self.nsQuota.unwrap_or(0)
    }
    pub fn clear_nsQuota(&mut self) {
        self.nsQuota = ::std::option::Option::None;
    }

    pub fn has_nsQuota(&self) -> bool {
        self.nsQuota.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nsQuota(&mut self, v: u64) {
        self.nsQuota = ::std::option::Option::Some(v);
    }

    // optional uint64 dsQuota = 3;


    pub fn get_dsQuota(&self) -> u64 {
        self.dsQuota.unwrap_or(0)
    }
    pub fn clear_dsQuota(&mut self) {
        self.dsQuota = ::std::option::Option::None;
    }

    pub fn has_dsQuota(&self) -> bool {
        self.dsQuota.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dsQuota(&mut self, v: u64) {
        self.dsQuota = ::std::option::Option::Some(v);
    }

    // optional fixed64 permission = 4;


    pub fn get_permission(&self) -> u64 {
        self.permission.unwrap_or(0)
    }
    pub fn clear_permission(&mut self) {
        self.permission = ::std::option::Option::None;
    }

    pub fn has_permission(&self) -> bool {
        self.permission.is_some()
    }

    // Param is passed by value, moved
    pub fn set_permission(&mut self, v: u64) {
        self.permission = ::std::option::Option::Some(v);
    }

    // optional .hadoop.hdfs.INodeSection.AclFeatureProto acl = 5;


    pub fn get_acl(&self) -> &INodeSection_AclFeatureProto {
        self.acl.as_ref().unwrap_or_else(|| <INodeSection_AclFeatureProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_acl(&mut self) {
        self.acl.clear();
    }

    pub fn has_acl(&self) -> bool {
        self.acl.is_some()
    }

    // Param is passed by value, moved
    pub fn set_acl(&mut self, v: INodeSection_AclFeatureProto) {
        self.acl = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_acl(&mut self) -> &mut INodeSection_AclFeatureProto {
        if self.acl.is_none() {
            self.acl.set_default();
        }
        self.acl.as_mut().unwrap()
    }

    // Take field
    pub fn take_acl(&mut self) -> INodeSection_AclFeatureProto {
        self.acl.take().unwrap_or_else(|| INodeSection_AclFeatureProto::new())
    }

    // optional .hadoop.hdfs.INodeSection.XAttrFeatureProto xAttrs = 6;


    pub fn get_xAttrs(&self) -> &INodeSection_XAttrFeatureProto {
        self.xAttrs.as_ref().unwrap_or_else(|| <INodeSection_XAttrFeatureProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_xAttrs(&mut self) {
        self.xAttrs.clear();
    }

    pub fn has_xAttrs(&self) -> bool {
        self.xAttrs.is_some()
    }

    // Param is passed by value, moved
    pub fn set_xAttrs(&mut self, v: INodeSection_XAttrFeatureProto) {
        self.xAttrs = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_xAttrs(&mut self) -> &mut INodeSection_XAttrFeatureProto {
        if self.xAttrs.is_none() {
            self.xAttrs.set_default();
        }
        self.xAttrs.as_mut().unwrap()
    }

    // Take field
    pub fn take_xAttrs(&mut self) -> INodeSection_XAttrFeatureProto {
        self.xAttrs.take().unwrap_or_else(|| INodeSection_XAttrFeatureProto::new())
    }

    // optional .hadoop.hdfs.INodeSection.QuotaByStorageTypeFeatureProto typeQuotas = 7;


    pub fn get_typeQuotas(&self) -> &INodeSection_QuotaByStorageTypeFeatureProto {
        self.typeQuotas.as_ref().unwrap_or_else(|| <INodeSection_QuotaByStorageTypeFeatureProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_typeQuotas(&mut self) {
        self.typeQuotas.clear();
    }

    pub fn has_typeQuotas(&self) -> bool {
        self.typeQuotas.is_some()
    }

    // Param is passed by value, moved
    pub fn set_typeQuotas(&mut self, v: INodeSection_QuotaByStorageTypeFeatureProto) {
        self.typeQuotas = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_typeQuotas(&mut self) -> &mut INodeSection_QuotaByStorageTypeFeatureProto {
        if self.typeQuotas.is_none() {
            self.typeQuotas.set_default();
        }
        self.typeQuotas.as_mut().unwrap()
    }

    // Take field
    pub fn take_typeQuotas(&mut self) -> INodeSection_QuotaByStorageTypeFeatureProto {
        self.typeQuotas.take().unwrap_or_else(|| INodeSection_QuotaByStorageTypeFeatureProto::new())
    }
}

impl ::protobuf::Message for INodeSection_INodeDirectory {
    fn is_initialized(&self) -> bool {
        for v in &self.acl {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.xAttrs {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.typeQuotas {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.modificationTime = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.nsQuota = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.dsQuota = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.permission = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.acl)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.xAttrs)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.typeQuotas)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.modificationTime {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.nsQuota {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.dsQuota {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.permission {
            my_size += 9;
        }
        if let Some(ref v) = self.acl.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.xAttrs.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.typeQuotas.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.modificationTime {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.nsQuota {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.dsQuota {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.permission {
            os.write_fixed64(4, v)?;
        }
        if let Some(ref v) = self.acl.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.xAttrs.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.typeQuotas.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> INodeSection_INodeDirectory {
        INodeSection_INodeDirectory::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "modificationTime",
                |m: &INodeSection_INodeDirectory| { &m.modificationTime },
                |m: &mut INodeSection_INodeDirectory| { &mut m.modificationTime },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "nsQuota",
                |m: &INodeSection_INodeDirectory| { &m.nsQuota },
                |m: &mut INodeSection_INodeDirectory| { &mut m.nsQuota },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "dsQuota",
                |m: &INodeSection_INodeDirectory| { &m.dsQuota },
                |m: &mut INodeSection_INodeDirectory| { &mut m.dsQuota },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "permission",
                |m: &INodeSection_INodeDirectory| { &m.permission },
                |m: &mut INodeSection_INodeDirectory| { &mut m.permission },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<INodeSection_AclFeatureProto>>(
                "acl",
                |m: &INodeSection_INodeDirectory| { &m.acl },
                |m: &mut INodeSection_INodeDirectory| { &mut m.acl },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<INodeSection_XAttrFeatureProto>>(
                "xAttrs",
                |m: &INodeSection_INodeDirectory| { &m.xAttrs },
                |m: &mut INodeSection_INodeDirectory| { &mut m.xAttrs },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<INodeSection_QuotaByStorageTypeFeatureProto>>(
                "typeQuotas",
                |m: &INodeSection_INodeDirectory| { &m.typeQuotas },
                |m: &mut INodeSection_INodeDirectory| { &mut m.typeQuotas },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<INodeSection_INodeDirectory>(
                "INodeSection.INodeDirectory",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static INodeSection_INodeDirectory {
        static instance: ::protobuf::rt::LazyV2<INodeSection_INodeDirectory> = ::protobuf::rt::LazyV2::INIT;
        instance.get(INodeSection_INodeDirectory::new)
    }
}

impl ::protobuf::Clear for INodeSection_INodeDirectory {
    fn clear(&mut self) {
        self.modificationTime = ::std::option::Option::None;
        self.nsQuota = ::std::option::Option::None;
        self.dsQuota = ::std::option::Option::None;
        self.permission = ::std::option::Option::None;
        self.acl.clear();
        self.xAttrs.clear();
        self.typeQuotas.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for INodeSection_INodeDirectory {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for INodeSection_INodeDirectory {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct INodeSection_INodeSymlink {
    // message fields
    permission: ::std::option::Option<u64>,
    target: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    modificationTime: ::std::option::Option<u64>,
    accessTime: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a INodeSection_INodeSymlink {
    fn default() -> &'a INodeSection_INodeSymlink {
        <INodeSection_INodeSymlink as ::protobuf::Message>::default_instance()
    }
}

impl INodeSection_INodeSymlink {
    pub fn new() -> INodeSection_INodeSymlink {
        ::std::default::Default::default()
    }

    // optional fixed64 permission = 1;


    pub fn get_permission(&self) -> u64 {
        self.permission.unwrap_or(0)
    }
    pub fn clear_permission(&mut self) {
        self.permission = ::std::option::Option::None;
    }

    pub fn has_permission(&self) -> bool {
        self.permission.is_some()
    }

    // Param is passed by value, moved
    pub fn set_permission(&mut self, v: u64) {
        self.permission = ::std::option::Option::Some(v);
    }

    // optional bytes target = 2;


    pub fn get_target(&self) -> &[u8] {
        match self.target.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_target(&mut self) {
        self.target.clear();
    }

    pub fn has_target(&self) -> bool {
        self.target.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target(&mut self, v: ::std::vec::Vec<u8>) {
        self.target = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_target(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.target.is_none() {
            self.target.set_default();
        }
        self.target.as_mut().unwrap()
    }

    // Take field
    pub fn take_target(&mut self) -> ::std::vec::Vec<u8> {
        self.target.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint64 modificationTime = 3;


    pub fn get_modificationTime(&self) -> u64 {
        self.modificationTime.unwrap_or(0)
    }
    pub fn clear_modificationTime(&mut self) {
        self.modificationTime = ::std::option::Option::None;
    }

    pub fn has_modificationTime(&self) -> bool {
        self.modificationTime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_modificationTime(&mut self, v: u64) {
        self.modificationTime = ::std::option::Option::Some(v);
    }

    // optional uint64 accessTime = 4;


    pub fn get_accessTime(&self) -> u64 {
        self.accessTime.unwrap_or(0)
    }
    pub fn clear_accessTime(&mut self) {
        self.accessTime = ::std::option::Option::None;
    }

    pub fn has_accessTime(&self) -> bool {
        self.accessTime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_accessTime(&mut self, v: u64) {
        self.accessTime = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for INodeSection_INodeSymlink {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.permission = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.target)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.modificationTime = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.accessTime = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.permission {
            my_size += 9;
        }
        if let Some(ref v) = self.target.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(v) = self.modificationTime {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.accessTime {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.permission {
            os.write_fixed64(1, v)?;
        }
        if let Some(ref v) = self.target.as_ref() {
            os.write_bytes(2, &v)?;
        }
        if let Some(v) = self.modificationTime {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.accessTime {
            os.write_uint64(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> INodeSection_INodeSymlink {
        INodeSection_INodeSymlink::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "permission",
                |m: &INodeSection_INodeSymlink| { &m.permission },
                |m: &mut INodeSection_INodeSymlink| { &mut m.permission },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "target",
                |m: &INodeSection_INodeSymlink| { &m.target },
                |m: &mut INodeSection_INodeSymlink| { &mut m.target },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "modificationTime",
                |m: &INodeSection_INodeSymlink| { &m.modificationTime },
                |m: &mut INodeSection_INodeSymlink| { &mut m.modificationTime },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "accessTime",
                |m: &INodeSection_INodeSymlink| { &m.accessTime },
                |m: &mut INodeSection_INodeSymlink| { &mut m.accessTime },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<INodeSection_INodeSymlink>(
                "INodeSection.INodeSymlink",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static INodeSection_INodeSymlink {
        static instance: ::protobuf::rt::LazyV2<INodeSection_INodeSymlink> = ::protobuf::rt::LazyV2::INIT;
        instance.get(INodeSection_INodeSymlink::new)
    }
}

impl ::protobuf::Clear for INodeSection_INodeSymlink {
    fn clear(&mut self) {
        self.permission = ::std::option::Option::None;
        self.target.clear();
        self.modificationTime = ::std::option::Option::None;
        self.accessTime = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for INodeSection_INodeSymlink {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for INodeSection_INodeSymlink {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct INodeSection_INode {
    // message fields
    field_type: ::std::option::Option<INodeSection_INode_Type>,
    id: ::std::option::Option<u64>,
    name: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    pub file: ::protobuf::SingularPtrField<INodeSection_INodeFile>,
    pub directory: ::protobuf::SingularPtrField<INodeSection_INodeDirectory>,
    pub symlink: ::protobuf::SingularPtrField<INodeSection_INodeSymlink>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a INodeSection_INode {
    fn default() -> &'a INodeSection_INode {
        <INodeSection_INode as ::protobuf::Message>::default_instance()
    }
}

impl INodeSection_INode {
    pub fn new() -> INodeSection_INode {
        ::std::default::Default::default()
    }

    // required .hadoop.hdfs.INodeSection.INode.Type type = 1;


    pub fn get_field_type(&self) -> INodeSection_INode_Type {
        self.field_type.unwrap_or(INodeSection_INode_Type::FILE)
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: INodeSection_INode_Type) {
        self.field_type = ::std::option::Option::Some(v);
    }

    // required uint64 id = 2;


    pub fn get_id(&self) -> u64 {
        self.id.unwrap_or(0)
    }
    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: u64) {
        self.id = ::std::option::Option::Some(v);
    }

    // optional bytes name = 3;


    pub fn get_name(&self) -> &[u8] {
        match self.name.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::vec::Vec<u8>) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::vec::Vec<u8> {
        self.name.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional .hadoop.hdfs.INodeSection.INodeFile file = 4;


    pub fn get_file(&self) -> &INodeSection_INodeFile {
        self.file.as_ref().unwrap_or_else(|| <INodeSection_INodeFile as ::protobuf::Message>::default_instance())
    }
    pub fn clear_file(&mut self) {
        self.file.clear();
    }

    pub fn has_file(&self) -> bool {
        self.file.is_some()
    }

    // Param is passed by value, moved
    pub fn set_file(&mut self, v: INodeSection_INodeFile) {
        self.file = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_file(&mut self) -> &mut INodeSection_INodeFile {
        if self.file.is_none() {
            self.file.set_default();
        }
        self.file.as_mut().unwrap()
    }

    // Take field
    pub fn take_file(&mut self) -> INodeSection_INodeFile {
        self.file.take().unwrap_or_else(|| INodeSection_INodeFile::new())
    }

    // optional .hadoop.hdfs.INodeSection.INodeDirectory directory = 5;


    pub fn get_directory(&self) -> &INodeSection_INodeDirectory {
        self.directory.as_ref().unwrap_or_else(|| <INodeSection_INodeDirectory as ::protobuf::Message>::default_instance())
    }
    pub fn clear_directory(&mut self) {
        self.directory.clear();
    }

    pub fn has_directory(&self) -> bool {
        self.directory.is_some()
    }

    // Param is passed by value, moved
    pub fn set_directory(&mut self, v: INodeSection_INodeDirectory) {
        self.directory = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_directory(&mut self) -> &mut INodeSection_INodeDirectory {
        if self.directory.is_none() {
            self.directory.set_default();
        }
        self.directory.as_mut().unwrap()
    }

    // Take field
    pub fn take_directory(&mut self) -> INodeSection_INodeDirectory {
        self.directory.take().unwrap_or_else(|| INodeSection_INodeDirectory::new())
    }

    // optional .hadoop.hdfs.INodeSection.INodeSymlink symlink = 6;


    pub fn get_symlink(&self) -> &INodeSection_INodeSymlink {
        self.symlink.as_ref().unwrap_or_else(|| <INodeSection_INodeSymlink as ::protobuf::Message>::default_instance())
    }
    pub fn clear_symlink(&mut self) {
        self.symlink.clear();
    }

    pub fn has_symlink(&self) -> bool {
        self.symlink.is_some()
    }

    // Param is passed by value, moved
    pub fn set_symlink(&mut self, v: INodeSection_INodeSymlink) {
        self.symlink = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_symlink(&mut self) -> &mut INodeSection_INodeSymlink {
        if self.symlink.is_none() {
            self.symlink.set_default();
        }
        self.symlink.as_mut().unwrap()
    }

    // Take field
    pub fn take_symlink(&mut self) -> INodeSection_INodeSymlink {
        self.symlink.take().unwrap_or_else(|| INodeSection_INodeSymlink::new())
    }
}

impl ::protobuf::Message for INodeSection_INode {
    fn is_initialized(&self) -> bool {
        if self.field_type.is_none() {
            return false;
        }
        if self.id.is_none() {
            return false;
        }
        for v in &self.file {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.directory {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.symlink {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 1, &mut self.unknown_fields)?
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.name)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.file)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.directory)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.symlink)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.field_type {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        if let Some(v) = self.id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        if let Some(ref v) = self.file.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.directory.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.symlink.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.field_type {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(v) = self.id {
            os.write_uint64(2, v)?;
        }
        if let Some(ref v) = self.name.as_ref() {
            os.write_bytes(3, &v)?;
        }
        if let Some(ref v) = self.file.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.directory.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.symlink.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> INodeSection_INode {
        INodeSection_INode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<INodeSection_INode_Type>>(
                "type",
                |m: &INodeSection_INode| { &m.field_type },
                |m: &mut INodeSection_INode| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "id",
                |m: &INodeSection_INode| { &m.id },
                |m: &mut INodeSection_INode| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "name",
                |m: &INodeSection_INode| { &m.name },
                |m: &mut INodeSection_INode| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<INodeSection_INodeFile>>(
                "file",
                |m: &INodeSection_INode| { &m.file },
                |m: &mut INodeSection_INode| { &mut m.file },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<INodeSection_INodeDirectory>>(
                "directory",
                |m: &INodeSection_INode| { &m.directory },
                |m: &mut INodeSection_INode| { &mut m.directory },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<INodeSection_INodeSymlink>>(
                "symlink",
                |m: &INodeSection_INode| { &m.symlink },
                |m: &mut INodeSection_INode| { &mut m.symlink },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<INodeSection_INode>(
                "INodeSection.INode",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static INodeSection_INode {
        static instance: ::protobuf::rt::LazyV2<INodeSection_INode> = ::protobuf::rt::LazyV2::INIT;
        instance.get(INodeSection_INode::new)
    }
}

impl ::protobuf::Clear for INodeSection_INode {
    fn clear(&mut self) {
        self.field_type = ::std::option::Option::None;
        self.id = ::std::option::Option::None;
        self.name.clear();
        self.file.clear();
        self.directory.clear();
        self.symlink.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for INodeSection_INode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for INodeSection_INode {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum INodeSection_INode_Type {
    FILE = 1,
    DIRECTORY = 2,
    SYMLINK = 3,
}

impl ::protobuf::ProtobufEnum for INodeSection_INode_Type {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<INodeSection_INode_Type> {
        match value {
            1 => ::std::option::Option::Some(INodeSection_INode_Type::FILE),
            2 => ::std::option::Option::Some(INodeSection_INode_Type::DIRECTORY),
            3 => ::std::option::Option::Some(INodeSection_INode_Type::SYMLINK),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [INodeSection_INode_Type] = &[
            INodeSection_INode_Type::FILE,
            INodeSection_INode_Type::DIRECTORY,
            INodeSection_INode_Type::SYMLINK,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<INodeSection_INode_Type>("INodeSection.INode.Type", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for INodeSection_INode_Type {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for INodeSection_INode_Type {
    fn default() -> Self {
        INodeSection_INode_Type::FILE
    }
}

impl ::protobuf::reflect::ProtobufValue for INodeSection_INode_Type {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FilesUnderConstructionSection {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FilesUnderConstructionSection {
    fn default() -> &'a FilesUnderConstructionSection {
        <FilesUnderConstructionSection as ::protobuf::Message>::default_instance()
    }
}

impl FilesUnderConstructionSection {
    pub fn new() -> FilesUnderConstructionSection {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for FilesUnderConstructionSection {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FilesUnderConstructionSection {
        FilesUnderConstructionSection::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<FilesUnderConstructionSection>(
                "FilesUnderConstructionSection",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static FilesUnderConstructionSection {
        static instance: ::protobuf::rt::LazyV2<FilesUnderConstructionSection> = ::protobuf::rt::LazyV2::INIT;
        instance.get(FilesUnderConstructionSection::new)
    }
}

impl ::protobuf::Clear for FilesUnderConstructionSection {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FilesUnderConstructionSection {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FilesUnderConstructionSection {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FilesUnderConstructionSection_FileUnderConstructionEntry {
    // message fields
    inodeId: ::std::option::Option<u64>,
    fullPath: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FilesUnderConstructionSection_FileUnderConstructionEntry {
    fn default() -> &'a FilesUnderConstructionSection_FileUnderConstructionEntry {
        <FilesUnderConstructionSection_FileUnderConstructionEntry as ::protobuf::Message>::default_instance()
    }
}

impl FilesUnderConstructionSection_FileUnderConstructionEntry {
    pub fn new() -> FilesUnderConstructionSection_FileUnderConstructionEntry {
        ::std::default::Default::default()
    }

    // optional uint64 inodeId = 1;


    pub fn get_inodeId(&self) -> u64 {
        self.inodeId.unwrap_or(0)
    }
    pub fn clear_inodeId(&mut self) {
        self.inodeId = ::std::option::Option::None;
    }

    pub fn has_inodeId(&self) -> bool {
        self.inodeId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_inodeId(&mut self, v: u64) {
        self.inodeId = ::std::option::Option::Some(v);
    }

    // optional string fullPath = 2;


    pub fn get_fullPath(&self) -> &str {
        match self.fullPath.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_fullPath(&mut self) {
        self.fullPath.clear();
    }

    pub fn has_fullPath(&self) -> bool {
        self.fullPath.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fullPath(&mut self, v: ::std::string::String) {
        self.fullPath = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fullPath(&mut self) -> &mut ::std::string::String {
        if self.fullPath.is_none() {
            self.fullPath.set_default();
        }
        self.fullPath.as_mut().unwrap()
    }

    // Take field
    pub fn take_fullPath(&mut self) -> ::std::string::String {
        self.fullPath.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for FilesUnderConstructionSection_FileUnderConstructionEntry {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.inodeId = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.fullPath)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.inodeId {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.fullPath.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.inodeId {
            os.write_uint64(1, v)?;
        }
        if let Some(ref v) = self.fullPath.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FilesUnderConstructionSection_FileUnderConstructionEntry {
        FilesUnderConstructionSection_FileUnderConstructionEntry::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "inodeId",
                |m: &FilesUnderConstructionSection_FileUnderConstructionEntry| { &m.inodeId },
                |m: &mut FilesUnderConstructionSection_FileUnderConstructionEntry| { &mut m.inodeId },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "fullPath",
                |m: &FilesUnderConstructionSection_FileUnderConstructionEntry| { &m.fullPath },
                |m: &mut FilesUnderConstructionSection_FileUnderConstructionEntry| { &mut m.fullPath },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<FilesUnderConstructionSection_FileUnderConstructionEntry>(
                "FilesUnderConstructionSection.FileUnderConstructionEntry",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static FilesUnderConstructionSection_FileUnderConstructionEntry {
        static instance: ::protobuf::rt::LazyV2<FilesUnderConstructionSection_FileUnderConstructionEntry> = ::protobuf::rt::LazyV2::INIT;
        instance.get(FilesUnderConstructionSection_FileUnderConstructionEntry::new)
    }
}

impl ::protobuf::Clear for FilesUnderConstructionSection_FileUnderConstructionEntry {
    fn clear(&mut self) {
        self.inodeId = ::std::option::Option::None;
        self.fullPath.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FilesUnderConstructionSection_FileUnderConstructionEntry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FilesUnderConstructionSection_FileUnderConstructionEntry {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct INodeDirectorySection {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a INodeDirectorySection {
    fn default() -> &'a INodeDirectorySection {
        <INodeDirectorySection as ::protobuf::Message>::default_instance()
    }
}

impl INodeDirectorySection {
    pub fn new() -> INodeDirectorySection {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for INodeDirectorySection {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> INodeDirectorySection {
        INodeDirectorySection::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<INodeDirectorySection>(
                "INodeDirectorySection",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static INodeDirectorySection {
        static instance: ::protobuf::rt::LazyV2<INodeDirectorySection> = ::protobuf::rt::LazyV2::INIT;
        instance.get(INodeDirectorySection::new)
    }
}

impl ::protobuf::Clear for INodeDirectorySection {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for INodeDirectorySection {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for INodeDirectorySection {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct INodeDirectorySection_DirEntry {
    // message fields
    parent: ::std::option::Option<u64>,
    pub children: ::std::vec::Vec<u64>,
    pub refChildren: ::std::vec::Vec<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a INodeDirectorySection_DirEntry {
    fn default() -> &'a INodeDirectorySection_DirEntry {
        <INodeDirectorySection_DirEntry as ::protobuf::Message>::default_instance()
    }
}

impl INodeDirectorySection_DirEntry {
    pub fn new() -> INodeDirectorySection_DirEntry {
        ::std::default::Default::default()
    }

    // optional uint64 parent = 1;


    pub fn get_parent(&self) -> u64 {
        self.parent.unwrap_or(0)
    }
    pub fn clear_parent(&mut self) {
        self.parent = ::std::option::Option::None;
    }

    pub fn has_parent(&self) -> bool {
        self.parent.is_some()
    }

    // Param is passed by value, moved
    pub fn set_parent(&mut self, v: u64) {
        self.parent = ::std::option::Option::Some(v);
    }

    // repeated uint64 children = 2;


    pub fn get_children(&self) -> &[u64] {
        &self.children
    }
    pub fn clear_children(&mut self) {
        self.children.clear();
    }

    // Param is passed by value, moved
    pub fn set_children(&mut self, v: ::std::vec::Vec<u64>) {
        self.children = v;
    }

    // Mutable pointer to the field.
    pub fn mut_children(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.children
    }

    // Take field
    pub fn take_children(&mut self) -> ::std::vec::Vec<u64> {
        ::std::mem::replace(&mut self.children, ::std::vec::Vec::new())
    }

    // repeated uint32 refChildren = 3;


    pub fn get_refChildren(&self) -> &[u32] {
        &self.refChildren
    }
    pub fn clear_refChildren(&mut self) {
        self.refChildren.clear();
    }

    // Param is passed by value, moved
    pub fn set_refChildren(&mut self, v: ::std::vec::Vec<u32>) {
        self.refChildren = v;
    }

    // Mutable pointer to the field.
    pub fn mut_refChildren(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.refChildren
    }

    // Take field
    pub fn take_refChildren(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.refChildren, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for INodeDirectorySection_DirEntry {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.parent = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_uint64_into(wire_type, is, &mut self.children)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.refChildren)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.parent {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.children.is_empty() {
            my_size += ::protobuf::rt::vec_packed_varint_size(2, &self.children);
        }
        if !self.refChildren.is_empty() {
            my_size += ::protobuf::rt::vec_packed_varint_size(3, &self.refChildren);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.parent {
            os.write_uint64(1, v)?;
        }
        if !self.children.is_empty() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            // TODO: Data size is computed again, it should be cached
            os.write_raw_varint32(::protobuf::rt::vec_packed_varint_data_size(&self.children))?;
            for v in &self.children {
                os.write_uint64_no_tag(*v)?;
            };
        }
        if !self.refChildren.is_empty() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            // TODO: Data size is computed again, it should be cached
            os.write_raw_varint32(::protobuf::rt::vec_packed_varint_data_size(&self.refChildren))?;
            for v in &self.refChildren {
                os.write_uint32_no_tag(*v)?;
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> INodeDirectorySection_DirEntry {
        INodeDirectorySection_DirEntry::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "parent",
                |m: &INodeDirectorySection_DirEntry| { &m.parent },
                |m: &mut INodeDirectorySection_DirEntry| { &mut m.parent },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "children",
                |m: &INodeDirectorySection_DirEntry| { &m.children },
                |m: &mut INodeDirectorySection_DirEntry| { &mut m.children },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "refChildren",
                |m: &INodeDirectorySection_DirEntry| { &m.refChildren },
                |m: &mut INodeDirectorySection_DirEntry| { &mut m.refChildren },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<INodeDirectorySection_DirEntry>(
                "INodeDirectorySection.DirEntry",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static INodeDirectorySection_DirEntry {
        static instance: ::protobuf::rt::LazyV2<INodeDirectorySection_DirEntry> = ::protobuf::rt::LazyV2::INIT;
        instance.get(INodeDirectorySection_DirEntry::new)
    }
}

impl ::protobuf::Clear for INodeDirectorySection_DirEntry {
    fn clear(&mut self) {
        self.parent = ::std::option::Option::None;
        self.children.clear();
        self.refChildren.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for INodeDirectorySection_DirEntry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for INodeDirectorySection_DirEntry {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct INodeReferenceSection {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a INodeReferenceSection {
    fn default() -> &'a INodeReferenceSection {
        <INodeReferenceSection as ::protobuf::Message>::default_instance()
    }
}

impl INodeReferenceSection {
    pub fn new() -> INodeReferenceSection {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for INodeReferenceSection {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> INodeReferenceSection {
        INodeReferenceSection::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<INodeReferenceSection>(
                "INodeReferenceSection",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static INodeReferenceSection {
        static instance: ::protobuf::rt::LazyV2<INodeReferenceSection> = ::protobuf::rt::LazyV2::INIT;
        instance.get(INodeReferenceSection::new)
    }
}

impl ::protobuf::Clear for INodeReferenceSection {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for INodeReferenceSection {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for INodeReferenceSection {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct INodeReferenceSection_INodeReference {
    // message fields
    referredId: ::std::option::Option<u64>,
    name: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    dstSnapshotId: ::std::option::Option<u32>,
    lastSnapshotId: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a INodeReferenceSection_INodeReference {
    fn default() -> &'a INodeReferenceSection_INodeReference {
        <INodeReferenceSection_INodeReference as ::protobuf::Message>::default_instance()
    }
}

impl INodeReferenceSection_INodeReference {
    pub fn new() -> INodeReferenceSection_INodeReference {
        ::std::default::Default::default()
    }

    // optional uint64 referredId = 1;


    pub fn get_referredId(&self) -> u64 {
        self.referredId.unwrap_or(0)
    }
    pub fn clear_referredId(&mut self) {
        self.referredId = ::std::option::Option::None;
    }

    pub fn has_referredId(&self) -> bool {
        self.referredId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_referredId(&mut self, v: u64) {
        self.referredId = ::std::option::Option::Some(v);
    }

    // optional bytes name = 2;


    pub fn get_name(&self) -> &[u8] {
        match self.name.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::vec::Vec<u8>) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::vec::Vec<u8> {
        self.name.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 dstSnapshotId = 3;


    pub fn get_dstSnapshotId(&self) -> u32 {
        self.dstSnapshotId.unwrap_or(0)
    }
    pub fn clear_dstSnapshotId(&mut self) {
        self.dstSnapshotId = ::std::option::Option::None;
    }

    pub fn has_dstSnapshotId(&self) -> bool {
        self.dstSnapshotId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dstSnapshotId(&mut self, v: u32) {
        self.dstSnapshotId = ::std::option::Option::Some(v);
    }

    // optional uint32 lastSnapshotId = 4;


    pub fn get_lastSnapshotId(&self) -> u32 {
        self.lastSnapshotId.unwrap_or(0)
    }
    pub fn clear_lastSnapshotId(&mut self) {
        self.lastSnapshotId = ::std::option::Option::None;
    }

    pub fn has_lastSnapshotId(&self) -> bool {
        self.lastSnapshotId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lastSnapshotId(&mut self, v: u32) {
        self.lastSnapshotId = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for INodeReferenceSection_INodeReference {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.referredId = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.name)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.dstSnapshotId = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.lastSnapshotId = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.referredId {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(v) = self.dstSnapshotId {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.lastSnapshotId {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.referredId {
            os.write_uint64(1, v)?;
        }
        if let Some(ref v) = self.name.as_ref() {
            os.write_bytes(2, &v)?;
        }
        if let Some(v) = self.dstSnapshotId {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.lastSnapshotId {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> INodeReferenceSection_INodeReference {
        INodeReferenceSection_INodeReference::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "referredId",
                |m: &INodeReferenceSection_INodeReference| { &m.referredId },
                |m: &mut INodeReferenceSection_INodeReference| { &mut m.referredId },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "name",
                |m: &INodeReferenceSection_INodeReference| { &m.name },
                |m: &mut INodeReferenceSection_INodeReference| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "dstSnapshotId",
                |m: &INodeReferenceSection_INodeReference| { &m.dstSnapshotId },
                |m: &mut INodeReferenceSection_INodeReference| { &mut m.dstSnapshotId },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "lastSnapshotId",
                |m: &INodeReferenceSection_INodeReference| { &m.lastSnapshotId },
                |m: &mut INodeReferenceSection_INodeReference| { &mut m.lastSnapshotId },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<INodeReferenceSection_INodeReference>(
                "INodeReferenceSection.INodeReference",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static INodeReferenceSection_INodeReference {
        static instance: ::protobuf::rt::LazyV2<INodeReferenceSection_INodeReference> = ::protobuf::rt::LazyV2::INIT;
        instance.get(INodeReferenceSection_INodeReference::new)
    }
}

impl ::protobuf::Clear for INodeReferenceSection_INodeReference {
    fn clear(&mut self) {
        self.referredId = ::std::option::Option::None;
        self.name.clear();
        self.dstSnapshotId = ::std::option::Option::None;
        self.lastSnapshotId = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for INodeReferenceSection_INodeReference {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for INodeReferenceSection_INodeReference {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SnapshotSection {
    // message fields
    snapshotCounter: ::std::option::Option<u32>,
    pub snapshottableDir: ::std::vec::Vec<u64>,
    numSnapshots: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SnapshotSection {
    fn default() -> &'a SnapshotSection {
        <SnapshotSection as ::protobuf::Message>::default_instance()
    }
}

impl SnapshotSection {
    pub fn new() -> SnapshotSection {
        ::std::default::Default::default()
    }

    // optional uint32 snapshotCounter = 1;


    pub fn get_snapshotCounter(&self) -> u32 {
        self.snapshotCounter.unwrap_or(0)
    }
    pub fn clear_snapshotCounter(&mut self) {
        self.snapshotCounter = ::std::option::Option::None;
    }

    pub fn has_snapshotCounter(&self) -> bool {
        self.snapshotCounter.is_some()
    }

    // Param is passed by value, moved
    pub fn set_snapshotCounter(&mut self, v: u32) {
        self.snapshotCounter = ::std::option::Option::Some(v);
    }

    // repeated uint64 snapshottableDir = 2;


    pub fn get_snapshottableDir(&self) -> &[u64] {
        &self.snapshottableDir
    }
    pub fn clear_snapshottableDir(&mut self) {
        self.snapshottableDir.clear();
    }

    // Param is passed by value, moved
    pub fn set_snapshottableDir(&mut self, v: ::std::vec::Vec<u64>) {
        self.snapshottableDir = v;
    }

    // Mutable pointer to the field.
    pub fn mut_snapshottableDir(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.snapshottableDir
    }

    // Take field
    pub fn take_snapshottableDir(&mut self) -> ::std::vec::Vec<u64> {
        ::std::mem::replace(&mut self.snapshottableDir, ::std::vec::Vec::new())
    }

    // optional uint32 numSnapshots = 3;


    pub fn get_numSnapshots(&self) -> u32 {
        self.numSnapshots.unwrap_or(0)
    }
    pub fn clear_numSnapshots(&mut self) {
        self.numSnapshots = ::std::option::Option::None;
    }

    pub fn has_numSnapshots(&self) -> bool {
        self.numSnapshots.is_some()
    }

    // Param is passed by value, moved
    pub fn set_numSnapshots(&mut self, v: u32) {
        self.numSnapshots = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for SnapshotSection {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.snapshotCounter = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_uint64_into(wire_type, is, &mut self.snapshottableDir)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.numSnapshots = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.snapshotCounter {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.snapshottableDir.is_empty() {
            my_size += ::protobuf::rt::vec_packed_varint_size(2, &self.snapshottableDir);
        }
        if let Some(v) = self.numSnapshots {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.snapshotCounter {
            os.write_uint32(1, v)?;
        }
        if !self.snapshottableDir.is_empty() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            // TODO: Data size is computed again, it should be cached
            os.write_raw_varint32(::protobuf::rt::vec_packed_varint_data_size(&self.snapshottableDir))?;
            for v in &self.snapshottableDir {
                os.write_uint64_no_tag(*v)?;
            };
        }
        if let Some(v) = self.numSnapshots {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SnapshotSection {
        SnapshotSection::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "snapshotCounter",
                |m: &SnapshotSection| { &m.snapshotCounter },
                |m: &mut SnapshotSection| { &mut m.snapshotCounter },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "snapshottableDir",
                |m: &SnapshotSection| { &m.snapshottableDir },
                |m: &mut SnapshotSection| { &mut m.snapshottableDir },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "numSnapshots",
                |m: &SnapshotSection| { &m.numSnapshots },
                |m: &mut SnapshotSection| { &mut m.numSnapshots },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SnapshotSection>(
                "SnapshotSection",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SnapshotSection {
        static instance: ::protobuf::rt::LazyV2<SnapshotSection> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SnapshotSection::new)
    }
}

impl ::protobuf::Clear for SnapshotSection {
    fn clear(&mut self) {
        self.snapshotCounter = ::std::option::Option::None;
        self.snapshottableDir.clear();
        self.numSnapshots = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SnapshotSection {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SnapshotSection {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SnapshotSection_Snapshot {
    // message fields
    snapshotId: ::std::option::Option<u32>,
    pub root: ::protobuf::SingularPtrField<INodeSection_INode>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SnapshotSection_Snapshot {
    fn default() -> &'a SnapshotSection_Snapshot {
        <SnapshotSection_Snapshot as ::protobuf::Message>::default_instance()
    }
}

impl SnapshotSection_Snapshot {
    pub fn new() -> SnapshotSection_Snapshot {
        ::std::default::Default::default()
    }

    // optional uint32 snapshotId = 1;


    pub fn get_snapshotId(&self) -> u32 {
        self.snapshotId.unwrap_or(0)
    }
    pub fn clear_snapshotId(&mut self) {
        self.snapshotId = ::std::option::Option::None;
    }

    pub fn has_snapshotId(&self) -> bool {
        self.snapshotId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_snapshotId(&mut self, v: u32) {
        self.snapshotId = ::std::option::Option::Some(v);
    }

    // optional .hadoop.hdfs.INodeSection.INode root = 2;


    pub fn get_root(&self) -> &INodeSection_INode {
        self.root.as_ref().unwrap_or_else(|| <INodeSection_INode as ::protobuf::Message>::default_instance())
    }
    pub fn clear_root(&mut self) {
        self.root.clear();
    }

    pub fn has_root(&self) -> bool {
        self.root.is_some()
    }

    // Param is passed by value, moved
    pub fn set_root(&mut self, v: INodeSection_INode) {
        self.root = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_root(&mut self) -> &mut INodeSection_INode {
        if self.root.is_none() {
            self.root.set_default();
        }
        self.root.as_mut().unwrap()
    }

    // Take field
    pub fn take_root(&mut self) -> INodeSection_INode {
        self.root.take().unwrap_or_else(|| INodeSection_INode::new())
    }
}

impl ::protobuf::Message for SnapshotSection_Snapshot {
    fn is_initialized(&self) -> bool {
        for v in &self.root {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.snapshotId = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.root)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.snapshotId {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.root.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.snapshotId {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.root.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SnapshotSection_Snapshot {
        SnapshotSection_Snapshot::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "snapshotId",
                |m: &SnapshotSection_Snapshot| { &m.snapshotId },
                |m: &mut SnapshotSection_Snapshot| { &mut m.snapshotId },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<INodeSection_INode>>(
                "root",
                |m: &SnapshotSection_Snapshot| { &m.root },
                |m: &mut SnapshotSection_Snapshot| { &mut m.root },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SnapshotSection_Snapshot>(
                "SnapshotSection.Snapshot",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SnapshotSection_Snapshot {
        static instance: ::protobuf::rt::LazyV2<SnapshotSection_Snapshot> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SnapshotSection_Snapshot::new)
    }
}

impl ::protobuf::Clear for SnapshotSection_Snapshot {
    fn clear(&mut self) {
        self.snapshotId = ::std::option::Option::None;
        self.root.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SnapshotSection_Snapshot {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SnapshotSection_Snapshot {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SnapshotDiffSection {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SnapshotDiffSection {
    fn default() -> &'a SnapshotDiffSection {
        <SnapshotDiffSection as ::protobuf::Message>::default_instance()
    }
}

impl SnapshotDiffSection {
    pub fn new() -> SnapshotDiffSection {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for SnapshotDiffSection {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SnapshotDiffSection {
        SnapshotDiffSection::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SnapshotDiffSection>(
                "SnapshotDiffSection",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SnapshotDiffSection {
        static instance: ::protobuf::rt::LazyV2<SnapshotDiffSection> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SnapshotDiffSection::new)
    }
}

impl ::protobuf::Clear for SnapshotDiffSection {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SnapshotDiffSection {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SnapshotDiffSection {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SnapshotDiffSection_CreatedListEntry {
    // message fields
    name: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SnapshotDiffSection_CreatedListEntry {
    fn default() -> &'a SnapshotDiffSection_CreatedListEntry {
        <SnapshotDiffSection_CreatedListEntry as ::protobuf::Message>::default_instance()
    }
}

impl SnapshotDiffSection_CreatedListEntry {
    pub fn new() -> SnapshotDiffSection_CreatedListEntry {
        ::std::default::Default::default()
    }

    // optional bytes name = 1;


    pub fn get_name(&self) -> &[u8] {
        match self.name.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::vec::Vec<u8>) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::vec::Vec<u8> {
        self.name.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for SnapshotDiffSection_CreatedListEntry {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.name.as_ref() {
            os.write_bytes(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SnapshotDiffSection_CreatedListEntry {
        SnapshotDiffSection_CreatedListEntry::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "name",
                |m: &SnapshotDiffSection_CreatedListEntry| { &m.name },
                |m: &mut SnapshotDiffSection_CreatedListEntry| { &mut m.name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SnapshotDiffSection_CreatedListEntry>(
                "SnapshotDiffSection.CreatedListEntry",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SnapshotDiffSection_CreatedListEntry {
        static instance: ::protobuf::rt::LazyV2<SnapshotDiffSection_CreatedListEntry> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SnapshotDiffSection_CreatedListEntry::new)
    }
}

impl ::protobuf::Clear for SnapshotDiffSection_CreatedListEntry {
    fn clear(&mut self) {
        self.name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SnapshotDiffSection_CreatedListEntry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SnapshotDiffSection_CreatedListEntry {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SnapshotDiffSection_DirectoryDiff {
    // message fields
    snapshotId: ::std::option::Option<u32>,
    childrenSize: ::std::option::Option<u32>,
    isSnapshotRoot: ::std::option::Option<bool>,
    name: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    pub snapshotCopy: ::protobuf::SingularPtrField<INodeSection_INodeDirectory>,
    createdListSize: ::std::option::Option<u32>,
    pub deletedINode: ::std::vec::Vec<u64>,
    pub deletedINodeRef: ::std::vec::Vec<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SnapshotDiffSection_DirectoryDiff {
    fn default() -> &'a SnapshotDiffSection_DirectoryDiff {
        <SnapshotDiffSection_DirectoryDiff as ::protobuf::Message>::default_instance()
    }
}

impl SnapshotDiffSection_DirectoryDiff {
    pub fn new() -> SnapshotDiffSection_DirectoryDiff {
        ::std::default::Default::default()
    }

    // optional uint32 snapshotId = 1;


    pub fn get_snapshotId(&self) -> u32 {
        self.snapshotId.unwrap_or(0)
    }
    pub fn clear_snapshotId(&mut self) {
        self.snapshotId = ::std::option::Option::None;
    }

    pub fn has_snapshotId(&self) -> bool {
        self.snapshotId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_snapshotId(&mut self, v: u32) {
        self.snapshotId = ::std::option::Option::Some(v);
    }

    // optional uint32 childrenSize = 2;


    pub fn get_childrenSize(&self) -> u32 {
        self.childrenSize.unwrap_or(0)
    }
    pub fn clear_childrenSize(&mut self) {
        self.childrenSize = ::std::option::Option::None;
    }

    pub fn has_childrenSize(&self) -> bool {
        self.childrenSize.is_some()
    }

    // Param is passed by value, moved
    pub fn set_childrenSize(&mut self, v: u32) {
        self.childrenSize = ::std::option::Option::Some(v);
    }

    // optional bool isSnapshotRoot = 3;


    pub fn get_isSnapshotRoot(&self) -> bool {
        self.isSnapshotRoot.unwrap_or(false)
    }
    pub fn clear_isSnapshotRoot(&mut self) {
        self.isSnapshotRoot = ::std::option::Option::None;
    }

    pub fn has_isSnapshotRoot(&self) -> bool {
        self.isSnapshotRoot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_isSnapshotRoot(&mut self, v: bool) {
        self.isSnapshotRoot = ::std::option::Option::Some(v);
    }

    // optional bytes name = 4;


    pub fn get_name(&self) -> &[u8] {
        match self.name.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::vec::Vec<u8>) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::vec::Vec<u8> {
        self.name.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional .hadoop.hdfs.INodeSection.INodeDirectory snapshotCopy = 5;


    pub fn get_snapshotCopy(&self) -> &INodeSection_INodeDirectory {
        self.snapshotCopy.as_ref().unwrap_or_else(|| <INodeSection_INodeDirectory as ::protobuf::Message>::default_instance())
    }
    pub fn clear_snapshotCopy(&mut self) {
        self.snapshotCopy.clear();
    }

    pub fn has_snapshotCopy(&self) -> bool {
        self.snapshotCopy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_snapshotCopy(&mut self, v: INodeSection_INodeDirectory) {
        self.snapshotCopy = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_snapshotCopy(&mut self) -> &mut INodeSection_INodeDirectory {
        if self.snapshotCopy.is_none() {
            self.snapshotCopy.set_default();
        }
        self.snapshotCopy.as_mut().unwrap()
    }

    // Take field
    pub fn take_snapshotCopy(&mut self) -> INodeSection_INodeDirectory {
        self.snapshotCopy.take().unwrap_or_else(|| INodeSection_INodeDirectory::new())
    }

    // optional uint32 createdListSize = 6;


    pub fn get_createdListSize(&self) -> u32 {
        self.createdListSize.unwrap_or(0)
    }
    pub fn clear_createdListSize(&mut self) {
        self.createdListSize = ::std::option::Option::None;
    }

    pub fn has_createdListSize(&self) -> bool {
        self.createdListSize.is_some()
    }

    // Param is passed by value, moved
    pub fn set_createdListSize(&mut self, v: u32) {
        self.createdListSize = ::std::option::Option::Some(v);
    }

    // repeated uint64 deletedINode = 7;


    pub fn get_deletedINode(&self) -> &[u64] {
        &self.deletedINode
    }
    pub fn clear_deletedINode(&mut self) {
        self.deletedINode.clear();
    }

    // Param is passed by value, moved
    pub fn set_deletedINode(&mut self, v: ::std::vec::Vec<u64>) {
        self.deletedINode = v;
    }

    // Mutable pointer to the field.
    pub fn mut_deletedINode(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.deletedINode
    }

    // Take field
    pub fn take_deletedINode(&mut self) -> ::std::vec::Vec<u64> {
        ::std::mem::replace(&mut self.deletedINode, ::std::vec::Vec::new())
    }

    // repeated uint32 deletedINodeRef = 8;


    pub fn get_deletedINodeRef(&self) -> &[u32] {
        &self.deletedINodeRef
    }
    pub fn clear_deletedINodeRef(&mut self) {
        self.deletedINodeRef.clear();
    }

    // Param is passed by value, moved
    pub fn set_deletedINodeRef(&mut self, v: ::std::vec::Vec<u32>) {
        self.deletedINodeRef = v;
    }

    // Mutable pointer to the field.
    pub fn mut_deletedINodeRef(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.deletedINodeRef
    }

    // Take field
    pub fn take_deletedINodeRef(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.deletedINodeRef, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for SnapshotDiffSection_DirectoryDiff {
    fn is_initialized(&self) -> bool {
        for v in &self.snapshotCopy {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.snapshotId = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.childrenSize = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.isSnapshotRoot = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.name)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.snapshotCopy)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.createdListSize = ::std::option::Option::Some(tmp);
                },
                7 => {
                    ::protobuf::rt::read_repeated_uint64_into(wire_type, is, &mut self.deletedINode)?;
                },
                8 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.deletedINodeRef)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.snapshotId {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.childrenSize {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.isSnapshotRoot {
            my_size += 2;
        }
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        if let Some(ref v) = self.snapshotCopy.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.createdListSize {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.deletedINode.is_empty() {
            my_size += ::protobuf::rt::vec_packed_varint_size(7, &self.deletedINode);
        }
        if !self.deletedINodeRef.is_empty() {
            my_size += ::protobuf::rt::vec_packed_varint_size(8, &self.deletedINodeRef);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.snapshotId {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.childrenSize {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.isSnapshotRoot {
            os.write_bool(3, v)?;
        }
        if let Some(ref v) = self.name.as_ref() {
            os.write_bytes(4, &v)?;
        }
        if let Some(ref v) = self.snapshotCopy.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.createdListSize {
            os.write_uint32(6, v)?;
        }
        if !self.deletedINode.is_empty() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            // TODO: Data size is computed again, it should be cached
            os.write_raw_varint32(::protobuf::rt::vec_packed_varint_data_size(&self.deletedINode))?;
            for v in &self.deletedINode {
                os.write_uint64_no_tag(*v)?;
            };
        }
        if !self.deletedINodeRef.is_empty() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            // TODO: Data size is computed again, it should be cached
            os.write_raw_varint32(::protobuf::rt::vec_packed_varint_data_size(&self.deletedINodeRef))?;
            for v in &self.deletedINodeRef {
                os.write_uint32_no_tag(*v)?;
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SnapshotDiffSection_DirectoryDiff {
        SnapshotDiffSection_DirectoryDiff::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "snapshotId",
                |m: &SnapshotDiffSection_DirectoryDiff| { &m.snapshotId },
                |m: &mut SnapshotDiffSection_DirectoryDiff| { &mut m.snapshotId },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "childrenSize",
                |m: &SnapshotDiffSection_DirectoryDiff| { &m.childrenSize },
                |m: &mut SnapshotDiffSection_DirectoryDiff| { &mut m.childrenSize },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "isSnapshotRoot",
                |m: &SnapshotDiffSection_DirectoryDiff| { &m.isSnapshotRoot },
                |m: &mut SnapshotDiffSection_DirectoryDiff| { &mut m.isSnapshotRoot },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "name",
                |m: &SnapshotDiffSection_DirectoryDiff| { &m.name },
                |m: &mut SnapshotDiffSection_DirectoryDiff| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<INodeSection_INodeDirectory>>(
                "snapshotCopy",
                |m: &SnapshotDiffSection_DirectoryDiff| { &m.snapshotCopy },
                |m: &mut SnapshotDiffSection_DirectoryDiff| { &mut m.snapshotCopy },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "createdListSize",
                |m: &SnapshotDiffSection_DirectoryDiff| { &m.createdListSize },
                |m: &mut SnapshotDiffSection_DirectoryDiff| { &mut m.createdListSize },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "deletedINode",
                |m: &SnapshotDiffSection_DirectoryDiff| { &m.deletedINode },
                |m: &mut SnapshotDiffSection_DirectoryDiff| { &mut m.deletedINode },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "deletedINodeRef",
                |m: &SnapshotDiffSection_DirectoryDiff| { &m.deletedINodeRef },
                |m: &mut SnapshotDiffSection_DirectoryDiff| { &mut m.deletedINodeRef },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SnapshotDiffSection_DirectoryDiff>(
                "SnapshotDiffSection.DirectoryDiff",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SnapshotDiffSection_DirectoryDiff {
        static instance: ::protobuf::rt::LazyV2<SnapshotDiffSection_DirectoryDiff> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SnapshotDiffSection_DirectoryDiff::new)
    }
}

impl ::protobuf::Clear for SnapshotDiffSection_DirectoryDiff {
    fn clear(&mut self) {
        self.snapshotId = ::std::option::Option::None;
        self.childrenSize = ::std::option::Option::None;
        self.isSnapshotRoot = ::std::option::Option::None;
        self.name.clear();
        self.snapshotCopy.clear();
        self.createdListSize = ::std::option::Option::None;
        self.deletedINode.clear();
        self.deletedINodeRef.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SnapshotDiffSection_DirectoryDiff {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SnapshotDiffSection_DirectoryDiff {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SnapshotDiffSection_FileDiff {
    // message fields
    snapshotId: ::std::option::Option<u32>,
    fileSize: ::std::option::Option<u64>,
    name: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    pub snapshotCopy: ::protobuf::SingularPtrField<INodeSection_INodeFile>,
    pub blocks: ::protobuf::RepeatedField<super::hdfs::BlockProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SnapshotDiffSection_FileDiff {
    fn default() -> &'a SnapshotDiffSection_FileDiff {
        <SnapshotDiffSection_FileDiff as ::protobuf::Message>::default_instance()
    }
}

impl SnapshotDiffSection_FileDiff {
    pub fn new() -> SnapshotDiffSection_FileDiff {
        ::std::default::Default::default()
    }

    // optional uint32 snapshotId = 1;


    pub fn get_snapshotId(&self) -> u32 {
        self.snapshotId.unwrap_or(0)
    }
    pub fn clear_snapshotId(&mut self) {
        self.snapshotId = ::std::option::Option::None;
    }

    pub fn has_snapshotId(&self) -> bool {
        self.snapshotId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_snapshotId(&mut self, v: u32) {
        self.snapshotId = ::std::option::Option::Some(v);
    }

    // optional uint64 fileSize = 2;


    pub fn get_fileSize(&self) -> u64 {
        self.fileSize.unwrap_or(0)
    }
    pub fn clear_fileSize(&mut self) {
        self.fileSize = ::std::option::Option::None;
    }

    pub fn has_fileSize(&self) -> bool {
        self.fileSize.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fileSize(&mut self, v: u64) {
        self.fileSize = ::std::option::Option::Some(v);
    }

    // optional bytes name = 3;


    pub fn get_name(&self) -> &[u8] {
        match self.name.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::vec::Vec<u8>) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::vec::Vec<u8> {
        self.name.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional .hadoop.hdfs.INodeSection.INodeFile snapshotCopy = 4;


    pub fn get_snapshotCopy(&self) -> &INodeSection_INodeFile {
        self.snapshotCopy.as_ref().unwrap_or_else(|| <INodeSection_INodeFile as ::protobuf::Message>::default_instance())
    }
    pub fn clear_snapshotCopy(&mut self) {
        self.snapshotCopy.clear();
    }

    pub fn has_snapshotCopy(&self) -> bool {
        self.snapshotCopy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_snapshotCopy(&mut self, v: INodeSection_INodeFile) {
        self.snapshotCopy = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_snapshotCopy(&mut self) -> &mut INodeSection_INodeFile {
        if self.snapshotCopy.is_none() {
            self.snapshotCopy.set_default();
        }
        self.snapshotCopy.as_mut().unwrap()
    }

    // Take field
    pub fn take_snapshotCopy(&mut self) -> INodeSection_INodeFile {
        self.snapshotCopy.take().unwrap_or_else(|| INodeSection_INodeFile::new())
    }

    // repeated .hadoop.hdfs.BlockProto blocks = 5;


    pub fn get_blocks(&self) -> &[super::hdfs::BlockProto] {
        &self.blocks
    }
    pub fn clear_blocks(&mut self) {
        self.blocks.clear();
    }

    // Param is passed by value, moved
    pub fn set_blocks(&mut self, v: ::protobuf::RepeatedField<super::hdfs::BlockProto>) {
        self.blocks = v;
    }

    // Mutable pointer to the field.
    pub fn mut_blocks(&mut self) -> &mut ::protobuf::RepeatedField<super::hdfs::BlockProto> {
        &mut self.blocks
    }

    // Take field
    pub fn take_blocks(&mut self) -> ::protobuf::RepeatedField<super::hdfs::BlockProto> {
        ::std::mem::replace(&mut self.blocks, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for SnapshotDiffSection_FileDiff {
    fn is_initialized(&self) -> bool {
        for v in &self.snapshotCopy {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.blocks {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.snapshotId = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.fileSize = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.name)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.snapshotCopy)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.blocks)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.snapshotId {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.fileSize {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        if let Some(ref v) = self.snapshotCopy.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.blocks {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.snapshotId {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.fileSize {
            os.write_uint64(2, v)?;
        }
        if let Some(ref v) = self.name.as_ref() {
            os.write_bytes(3, &v)?;
        }
        if let Some(ref v) = self.snapshotCopy.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.blocks {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SnapshotDiffSection_FileDiff {
        SnapshotDiffSection_FileDiff::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "snapshotId",
                |m: &SnapshotDiffSection_FileDiff| { &m.snapshotId },
                |m: &mut SnapshotDiffSection_FileDiff| { &mut m.snapshotId },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "fileSize",
                |m: &SnapshotDiffSection_FileDiff| { &m.fileSize },
                |m: &mut SnapshotDiffSection_FileDiff| { &mut m.fileSize },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "name",
                |m: &SnapshotDiffSection_FileDiff| { &m.name },
                |m: &mut SnapshotDiffSection_FileDiff| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<INodeSection_INodeFile>>(
                "snapshotCopy",
                |m: &SnapshotDiffSection_FileDiff| { &m.snapshotCopy },
                |m: &mut SnapshotDiffSection_FileDiff| { &mut m.snapshotCopy },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::hdfs::BlockProto>>(
                "blocks",
                |m: &SnapshotDiffSection_FileDiff| { &m.blocks },
                |m: &mut SnapshotDiffSection_FileDiff| { &mut m.blocks },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SnapshotDiffSection_FileDiff>(
                "SnapshotDiffSection.FileDiff",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SnapshotDiffSection_FileDiff {
        static instance: ::protobuf::rt::LazyV2<SnapshotDiffSection_FileDiff> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SnapshotDiffSection_FileDiff::new)
    }
}

impl ::protobuf::Clear for SnapshotDiffSection_FileDiff {
    fn clear(&mut self) {
        self.snapshotId = ::std::option::Option::None;
        self.fileSize = ::std::option::Option::None;
        self.name.clear();
        self.snapshotCopy.clear();
        self.blocks.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SnapshotDiffSection_FileDiff {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SnapshotDiffSection_FileDiff {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SnapshotDiffSection_DiffEntry {
    // message fields
    field_type: ::std::option::Option<SnapshotDiffSection_DiffEntry_Type>,
    inodeId: ::std::option::Option<u64>,
    numOfDiff: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SnapshotDiffSection_DiffEntry {
    fn default() -> &'a SnapshotDiffSection_DiffEntry {
        <SnapshotDiffSection_DiffEntry as ::protobuf::Message>::default_instance()
    }
}

impl SnapshotDiffSection_DiffEntry {
    pub fn new() -> SnapshotDiffSection_DiffEntry {
        ::std::default::Default::default()
    }

    // required .hadoop.hdfs.SnapshotDiffSection.DiffEntry.Type type = 1;


    pub fn get_field_type(&self) -> SnapshotDiffSection_DiffEntry_Type {
        self.field_type.unwrap_or(SnapshotDiffSection_DiffEntry_Type::FILEDIFF)
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: SnapshotDiffSection_DiffEntry_Type) {
        self.field_type = ::std::option::Option::Some(v);
    }

    // optional uint64 inodeId = 2;


    pub fn get_inodeId(&self) -> u64 {
        self.inodeId.unwrap_or(0)
    }
    pub fn clear_inodeId(&mut self) {
        self.inodeId = ::std::option::Option::None;
    }

    pub fn has_inodeId(&self) -> bool {
        self.inodeId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_inodeId(&mut self, v: u64) {
        self.inodeId = ::std::option::Option::Some(v);
    }

    // optional uint32 numOfDiff = 3;


    pub fn get_numOfDiff(&self) -> u32 {
        self.numOfDiff.unwrap_or(0)
    }
    pub fn clear_numOfDiff(&mut self) {
        self.numOfDiff = ::std::option::Option::None;
    }

    pub fn has_numOfDiff(&self) -> bool {
        self.numOfDiff.is_some()
    }

    // Param is passed by value, moved
    pub fn set_numOfDiff(&mut self, v: u32) {
        self.numOfDiff = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for SnapshotDiffSection_DiffEntry {
    fn is_initialized(&self) -> bool {
        if self.field_type.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 1, &mut self.unknown_fields)?
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.inodeId = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.numOfDiff = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.field_type {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        if let Some(v) = self.inodeId {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.numOfDiff {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.field_type {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(v) = self.inodeId {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.numOfDiff {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SnapshotDiffSection_DiffEntry {
        SnapshotDiffSection_DiffEntry::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<SnapshotDiffSection_DiffEntry_Type>>(
                "type",
                |m: &SnapshotDiffSection_DiffEntry| { &m.field_type },
                |m: &mut SnapshotDiffSection_DiffEntry| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "inodeId",
                |m: &SnapshotDiffSection_DiffEntry| { &m.inodeId },
                |m: &mut SnapshotDiffSection_DiffEntry| { &mut m.inodeId },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "numOfDiff",
                |m: &SnapshotDiffSection_DiffEntry| { &m.numOfDiff },
                |m: &mut SnapshotDiffSection_DiffEntry| { &mut m.numOfDiff },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SnapshotDiffSection_DiffEntry>(
                "SnapshotDiffSection.DiffEntry",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SnapshotDiffSection_DiffEntry {
        static instance: ::protobuf::rt::LazyV2<SnapshotDiffSection_DiffEntry> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SnapshotDiffSection_DiffEntry::new)
    }
}

impl ::protobuf::Clear for SnapshotDiffSection_DiffEntry {
    fn clear(&mut self) {
        self.field_type = ::std::option::Option::None;
        self.inodeId = ::std::option::Option::None;
        self.numOfDiff = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SnapshotDiffSection_DiffEntry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SnapshotDiffSection_DiffEntry {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum SnapshotDiffSection_DiffEntry_Type {
    FILEDIFF = 1,
    DIRECTORYDIFF = 2,
}

impl ::protobuf::ProtobufEnum for SnapshotDiffSection_DiffEntry_Type {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<SnapshotDiffSection_DiffEntry_Type> {
        match value {
            1 => ::std::option::Option::Some(SnapshotDiffSection_DiffEntry_Type::FILEDIFF),
            2 => ::std::option::Option::Some(SnapshotDiffSection_DiffEntry_Type::DIRECTORYDIFF),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [SnapshotDiffSection_DiffEntry_Type] = &[
            SnapshotDiffSection_DiffEntry_Type::FILEDIFF,
            SnapshotDiffSection_DiffEntry_Type::DIRECTORYDIFF,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<SnapshotDiffSection_DiffEntry_Type>("SnapshotDiffSection.DiffEntry.Type", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for SnapshotDiffSection_DiffEntry_Type {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for SnapshotDiffSection_DiffEntry_Type {
    fn default() -> Self {
        SnapshotDiffSection_DiffEntry_Type::FILEDIFF
    }
}

impl ::protobuf::reflect::ProtobufValue for SnapshotDiffSection_DiffEntry_Type {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StringTableSection {
    // message fields
    numEntry: ::std::option::Option<u32>,
    maskBits: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StringTableSection {
    fn default() -> &'a StringTableSection {
        <StringTableSection as ::protobuf::Message>::default_instance()
    }
}

impl StringTableSection {
    pub fn new() -> StringTableSection {
        ::std::default::Default::default()
    }

    // optional uint32 numEntry = 1;


    pub fn get_numEntry(&self) -> u32 {
        self.numEntry.unwrap_or(0)
    }
    pub fn clear_numEntry(&mut self) {
        self.numEntry = ::std::option::Option::None;
    }

    pub fn has_numEntry(&self) -> bool {
        self.numEntry.is_some()
    }

    // Param is passed by value, moved
    pub fn set_numEntry(&mut self, v: u32) {
        self.numEntry = ::std::option::Option::Some(v);
    }

    // optional uint32 maskBits = 2;


    pub fn get_maskBits(&self) -> u32 {
        self.maskBits.unwrap_or(0u32)
    }
    pub fn clear_maskBits(&mut self) {
        self.maskBits = ::std::option::Option::None;
    }

    pub fn has_maskBits(&self) -> bool {
        self.maskBits.is_some()
    }

    // Param is passed by value, moved
    pub fn set_maskBits(&mut self, v: u32) {
        self.maskBits = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for StringTableSection {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.numEntry = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.maskBits = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.numEntry {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.maskBits {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.numEntry {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.maskBits {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StringTableSection {
        StringTableSection::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "numEntry",
                |m: &StringTableSection| { &m.numEntry },
                |m: &mut StringTableSection| { &mut m.numEntry },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "maskBits",
                |m: &StringTableSection| { &m.maskBits },
                |m: &mut StringTableSection| { &mut m.maskBits },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<StringTableSection>(
                "StringTableSection",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static StringTableSection {
        static instance: ::protobuf::rt::LazyV2<StringTableSection> = ::protobuf::rt::LazyV2::INIT;
        instance.get(StringTableSection::new)
    }
}

impl ::protobuf::Clear for StringTableSection {
    fn clear(&mut self) {
        self.numEntry = ::std::option::Option::None;
        self.maskBits = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StringTableSection {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StringTableSection {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StringTableSection_Entry {
    // message fields
    id: ::std::option::Option<u32>,
    str: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StringTableSection_Entry {
    fn default() -> &'a StringTableSection_Entry {
        <StringTableSection_Entry as ::protobuf::Message>::default_instance()
    }
}

impl StringTableSection_Entry {
    pub fn new() -> StringTableSection_Entry {
        ::std::default::Default::default()
    }

    // optional uint32 id = 1;


    pub fn get_id(&self) -> u32 {
        self.id.unwrap_or(0)
    }
    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: u32) {
        self.id = ::std::option::Option::Some(v);
    }

    // optional string str = 2;


    pub fn get_str(&self) -> &str {
        match self.str.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_str(&mut self) {
        self.str.clear();
    }

    pub fn has_str(&self) -> bool {
        self.str.is_some()
    }

    // Param is passed by value, moved
    pub fn set_str(&mut self, v: ::std::string::String) {
        self.str = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_str(&mut self) -> &mut ::std::string::String {
        if self.str.is_none() {
            self.str.set_default();
        }
        self.str.as_mut().unwrap()
    }

    // Take field
    pub fn take_str(&mut self) -> ::std::string::String {
        self.str.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for StringTableSection_Entry {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.str)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.str.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.id {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.str.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StringTableSection_Entry {
        StringTableSection_Entry::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "id",
                |m: &StringTableSection_Entry| { &m.id },
                |m: &mut StringTableSection_Entry| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "str",
                |m: &StringTableSection_Entry| { &m.str },
                |m: &mut StringTableSection_Entry| { &mut m.str },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<StringTableSection_Entry>(
                "StringTableSection.Entry",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static StringTableSection_Entry {
        static instance: ::protobuf::rt::LazyV2<StringTableSection_Entry> = ::protobuf::rt::LazyV2::INIT;
        instance.get(StringTableSection_Entry::new)
    }
}

impl ::protobuf::Clear for StringTableSection_Entry {
    fn clear(&mut self) {
        self.id = ::std::option::Option::None;
        self.str.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StringTableSection_Entry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StringTableSection_Entry {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SecretManagerSection {
    // message fields
    currentId: ::std::option::Option<u32>,
    tokenSequenceNumber: ::std::option::Option<u32>,
    numKeys: ::std::option::Option<u32>,
    numTokens: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SecretManagerSection {
    fn default() -> &'a SecretManagerSection {
        <SecretManagerSection as ::protobuf::Message>::default_instance()
    }
}

impl SecretManagerSection {
    pub fn new() -> SecretManagerSection {
        ::std::default::Default::default()
    }

    // optional uint32 currentId = 1;


    pub fn get_currentId(&self) -> u32 {
        self.currentId.unwrap_or(0)
    }
    pub fn clear_currentId(&mut self) {
        self.currentId = ::std::option::Option::None;
    }

    pub fn has_currentId(&self) -> bool {
        self.currentId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_currentId(&mut self, v: u32) {
        self.currentId = ::std::option::Option::Some(v);
    }

    // optional uint32 tokenSequenceNumber = 2;


    pub fn get_tokenSequenceNumber(&self) -> u32 {
        self.tokenSequenceNumber.unwrap_or(0)
    }
    pub fn clear_tokenSequenceNumber(&mut self) {
        self.tokenSequenceNumber = ::std::option::Option::None;
    }

    pub fn has_tokenSequenceNumber(&self) -> bool {
        self.tokenSequenceNumber.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tokenSequenceNumber(&mut self, v: u32) {
        self.tokenSequenceNumber = ::std::option::Option::Some(v);
    }

    // optional uint32 numKeys = 3;


    pub fn get_numKeys(&self) -> u32 {
        self.numKeys.unwrap_or(0)
    }
    pub fn clear_numKeys(&mut self) {
        self.numKeys = ::std::option::Option::None;
    }

    pub fn has_numKeys(&self) -> bool {
        self.numKeys.is_some()
    }

    // Param is passed by value, moved
    pub fn set_numKeys(&mut self, v: u32) {
        self.numKeys = ::std::option::Option::Some(v);
    }

    // optional uint32 numTokens = 4;


    pub fn get_numTokens(&self) -> u32 {
        self.numTokens.unwrap_or(0)
    }
    pub fn clear_numTokens(&mut self) {
        self.numTokens = ::std::option::Option::None;
    }

    pub fn has_numTokens(&self) -> bool {
        self.numTokens.is_some()
    }

    // Param is passed by value, moved
    pub fn set_numTokens(&mut self, v: u32) {
        self.numTokens = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for SecretManagerSection {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.currentId = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.tokenSequenceNumber = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.numKeys = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.numTokens = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.currentId {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.tokenSequenceNumber {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.numKeys {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.numTokens {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.currentId {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.tokenSequenceNumber {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.numKeys {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.numTokens {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SecretManagerSection {
        SecretManagerSection::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "currentId",
                |m: &SecretManagerSection| { &m.currentId },
                |m: &mut SecretManagerSection| { &mut m.currentId },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "tokenSequenceNumber",
                |m: &SecretManagerSection| { &m.tokenSequenceNumber },
                |m: &mut SecretManagerSection| { &mut m.tokenSequenceNumber },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "numKeys",
                |m: &SecretManagerSection| { &m.numKeys },
                |m: &mut SecretManagerSection| { &mut m.numKeys },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "numTokens",
                |m: &SecretManagerSection| { &m.numTokens },
                |m: &mut SecretManagerSection| { &mut m.numTokens },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SecretManagerSection>(
                "SecretManagerSection",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SecretManagerSection {
        static instance: ::protobuf::rt::LazyV2<SecretManagerSection> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SecretManagerSection::new)
    }
}

impl ::protobuf::Clear for SecretManagerSection {
    fn clear(&mut self) {
        self.currentId = ::std::option::Option::None;
        self.tokenSequenceNumber = ::std::option::Option::None;
        self.numKeys = ::std::option::Option::None;
        self.numTokens = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SecretManagerSection {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SecretManagerSection {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SecretManagerSection_DelegationKey {
    // message fields
    id: ::std::option::Option<u32>,
    expiryDate: ::std::option::Option<u64>,
    key: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SecretManagerSection_DelegationKey {
    fn default() -> &'a SecretManagerSection_DelegationKey {
        <SecretManagerSection_DelegationKey as ::protobuf::Message>::default_instance()
    }
}

impl SecretManagerSection_DelegationKey {
    pub fn new() -> SecretManagerSection_DelegationKey {
        ::std::default::Default::default()
    }

    // optional uint32 id = 1;


    pub fn get_id(&self) -> u32 {
        self.id.unwrap_or(0)
    }
    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: u32) {
        self.id = ::std::option::Option::Some(v);
    }

    // optional uint64 expiryDate = 2;


    pub fn get_expiryDate(&self) -> u64 {
        self.expiryDate.unwrap_or(0)
    }
    pub fn clear_expiryDate(&mut self) {
        self.expiryDate = ::std::option::Option::None;
    }

    pub fn has_expiryDate(&self) -> bool {
        self.expiryDate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_expiryDate(&mut self, v: u64) {
        self.expiryDate = ::std::option::Option::Some(v);
    }

    // optional bytes key = 3;


    pub fn get_key(&self) -> &[u8] {
        match self.key.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    pub fn has_key(&self) -> bool {
        self.key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.key = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.key.is_none() {
            self.key.set_default();
        }
        self.key.as_mut().unwrap()
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::vec::Vec<u8> {
        self.key.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for SecretManagerSection_DelegationKey {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.expiryDate = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.key)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.expiryDate {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.key.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.expiryDate {
            os.write_uint64(2, v)?;
        }
        if let Some(ref v) = self.key.as_ref() {
            os.write_bytes(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SecretManagerSection_DelegationKey {
        SecretManagerSection_DelegationKey::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "id",
                |m: &SecretManagerSection_DelegationKey| { &m.id },
                |m: &mut SecretManagerSection_DelegationKey| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "expiryDate",
                |m: &SecretManagerSection_DelegationKey| { &m.expiryDate },
                |m: &mut SecretManagerSection_DelegationKey| { &mut m.expiryDate },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "key",
                |m: &SecretManagerSection_DelegationKey| { &m.key },
                |m: &mut SecretManagerSection_DelegationKey| { &mut m.key },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SecretManagerSection_DelegationKey>(
                "SecretManagerSection.DelegationKey",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SecretManagerSection_DelegationKey {
        static instance: ::protobuf::rt::LazyV2<SecretManagerSection_DelegationKey> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SecretManagerSection_DelegationKey::new)
    }
}

impl ::protobuf::Clear for SecretManagerSection_DelegationKey {
    fn clear(&mut self) {
        self.id = ::std::option::Option::None;
        self.expiryDate = ::std::option::Option::None;
        self.key.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SecretManagerSection_DelegationKey {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SecretManagerSection_DelegationKey {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SecretManagerSection_PersistToken {
    // message fields
    version: ::std::option::Option<u32>,
    owner: ::protobuf::SingularField<::std::string::String>,
    renewer: ::protobuf::SingularField<::std::string::String>,
    realUser: ::protobuf::SingularField<::std::string::String>,
    issueDate: ::std::option::Option<u64>,
    maxDate: ::std::option::Option<u64>,
    sequenceNumber: ::std::option::Option<u32>,
    masterKeyId: ::std::option::Option<u32>,
    expiryDate: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SecretManagerSection_PersistToken {
    fn default() -> &'a SecretManagerSection_PersistToken {
        <SecretManagerSection_PersistToken as ::protobuf::Message>::default_instance()
    }
}

impl SecretManagerSection_PersistToken {
    pub fn new() -> SecretManagerSection_PersistToken {
        ::std::default::Default::default()
    }

    // optional uint32 version = 1;


    pub fn get_version(&self) -> u32 {
        self.version.unwrap_or(0)
    }
    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: u32) {
        self.version = ::std::option::Option::Some(v);
    }

    // optional string owner = 2;


    pub fn get_owner(&self) -> &str {
        match self.owner.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_owner(&mut self) {
        self.owner.clear();
    }

    pub fn has_owner(&self) -> bool {
        self.owner.is_some()
    }

    // Param is passed by value, moved
    pub fn set_owner(&mut self, v: ::std::string::String) {
        self.owner = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_owner(&mut self) -> &mut ::std::string::String {
        if self.owner.is_none() {
            self.owner.set_default();
        }
        self.owner.as_mut().unwrap()
    }

    // Take field
    pub fn take_owner(&mut self) -> ::std::string::String {
        self.owner.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string renewer = 3;


    pub fn get_renewer(&self) -> &str {
        match self.renewer.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_renewer(&mut self) {
        self.renewer.clear();
    }

    pub fn has_renewer(&self) -> bool {
        self.renewer.is_some()
    }

    // Param is passed by value, moved
    pub fn set_renewer(&mut self, v: ::std::string::String) {
        self.renewer = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_renewer(&mut self) -> &mut ::std::string::String {
        if self.renewer.is_none() {
            self.renewer.set_default();
        }
        self.renewer.as_mut().unwrap()
    }

    // Take field
    pub fn take_renewer(&mut self) -> ::std::string::String {
        self.renewer.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string realUser = 4;


    pub fn get_realUser(&self) -> &str {
        match self.realUser.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_realUser(&mut self) {
        self.realUser.clear();
    }

    pub fn has_realUser(&self) -> bool {
        self.realUser.is_some()
    }

    // Param is passed by value, moved
    pub fn set_realUser(&mut self, v: ::std::string::String) {
        self.realUser = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_realUser(&mut self) -> &mut ::std::string::String {
        if self.realUser.is_none() {
            self.realUser.set_default();
        }
        self.realUser.as_mut().unwrap()
    }

    // Take field
    pub fn take_realUser(&mut self) -> ::std::string::String {
        self.realUser.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint64 issueDate = 5;


    pub fn get_issueDate(&self) -> u64 {
        self.issueDate.unwrap_or(0)
    }
    pub fn clear_issueDate(&mut self) {
        self.issueDate = ::std::option::Option::None;
    }

    pub fn has_issueDate(&self) -> bool {
        self.issueDate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_issueDate(&mut self, v: u64) {
        self.issueDate = ::std::option::Option::Some(v);
    }

    // optional uint64 maxDate = 6;


    pub fn get_maxDate(&self) -> u64 {
        self.maxDate.unwrap_or(0)
    }
    pub fn clear_maxDate(&mut self) {
        self.maxDate = ::std::option::Option::None;
    }

    pub fn has_maxDate(&self) -> bool {
        self.maxDate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_maxDate(&mut self, v: u64) {
        self.maxDate = ::std::option::Option::Some(v);
    }

    // optional uint32 sequenceNumber = 7;


    pub fn get_sequenceNumber(&self) -> u32 {
        self.sequenceNumber.unwrap_or(0)
    }
    pub fn clear_sequenceNumber(&mut self) {
        self.sequenceNumber = ::std::option::Option::None;
    }

    pub fn has_sequenceNumber(&self) -> bool {
        self.sequenceNumber.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sequenceNumber(&mut self, v: u32) {
        self.sequenceNumber = ::std::option::Option::Some(v);
    }

    // optional uint32 masterKeyId = 8;


    pub fn get_masterKeyId(&self) -> u32 {
        self.masterKeyId.unwrap_or(0)
    }
    pub fn clear_masterKeyId(&mut self) {
        self.masterKeyId = ::std::option::Option::None;
    }

    pub fn has_masterKeyId(&self) -> bool {
        self.masterKeyId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_masterKeyId(&mut self, v: u32) {
        self.masterKeyId = ::std::option::Option::Some(v);
    }

    // optional uint64 expiryDate = 9;


    pub fn get_expiryDate(&self) -> u64 {
        self.expiryDate.unwrap_or(0)
    }
    pub fn clear_expiryDate(&mut self) {
        self.expiryDate = ::std::option::Option::None;
    }

    pub fn has_expiryDate(&self) -> bool {
        self.expiryDate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_expiryDate(&mut self, v: u64) {
        self.expiryDate = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for SecretManagerSection_PersistToken {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.version = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.owner)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.renewer)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.realUser)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.issueDate = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.maxDate = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.sequenceNumber = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.masterKeyId = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.expiryDate = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.version {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.owner.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.renewer.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.realUser.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.issueDate {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.maxDate {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.sequenceNumber {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.masterKeyId {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.expiryDate {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.version {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.owner.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.renewer.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.realUser.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(v) = self.issueDate {
            os.write_uint64(5, v)?;
        }
        if let Some(v) = self.maxDate {
            os.write_uint64(6, v)?;
        }
        if let Some(v) = self.sequenceNumber {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.masterKeyId {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.expiryDate {
            os.write_uint64(9, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SecretManagerSection_PersistToken {
        SecretManagerSection_PersistToken::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "version",
                |m: &SecretManagerSection_PersistToken| { &m.version },
                |m: &mut SecretManagerSection_PersistToken| { &mut m.version },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "owner",
                |m: &SecretManagerSection_PersistToken| { &m.owner },
                |m: &mut SecretManagerSection_PersistToken| { &mut m.owner },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "renewer",
                |m: &SecretManagerSection_PersistToken| { &m.renewer },
                |m: &mut SecretManagerSection_PersistToken| { &mut m.renewer },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "realUser",
                |m: &SecretManagerSection_PersistToken| { &m.realUser },
                |m: &mut SecretManagerSection_PersistToken| { &mut m.realUser },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "issueDate",
                |m: &SecretManagerSection_PersistToken| { &m.issueDate },
                |m: &mut SecretManagerSection_PersistToken| { &mut m.issueDate },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "maxDate",
                |m: &SecretManagerSection_PersistToken| { &m.maxDate },
                |m: &mut SecretManagerSection_PersistToken| { &mut m.maxDate },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "sequenceNumber",
                |m: &SecretManagerSection_PersistToken| { &m.sequenceNumber },
                |m: &mut SecretManagerSection_PersistToken| { &mut m.sequenceNumber },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "masterKeyId",
                |m: &SecretManagerSection_PersistToken| { &m.masterKeyId },
                |m: &mut SecretManagerSection_PersistToken| { &mut m.masterKeyId },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "expiryDate",
                |m: &SecretManagerSection_PersistToken| { &m.expiryDate },
                |m: &mut SecretManagerSection_PersistToken| { &mut m.expiryDate },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SecretManagerSection_PersistToken>(
                "SecretManagerSection.PersistToken",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SecretManagerSection_PersistToken {
        static instance: ::protobuf::rt::LazyV2<SecretManagerSection_PersistToken> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SecretManagerSection_PersistToken::new)
    }
}

impl ::protobuf::Clear for SecretManagerSection_PersistToken {
    fn clear(&mut self) {
        self.version = ::std::option::Option::None;
        self.owner.clear();
        self.renewer.clear();
        self.realUser.clear();
        self.issueDate = ::std::option::Option::None;
        self.maxDate = ::std::option::Option::None;
        self.sequenceNumber = ::std::option::Option::None;
        self.masterKeyId = ::std::option::Option::None;
        self.expiryDate = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SecretManagerSection_PersistToken {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SecretManagerSection_PersistToken {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CacheManagerSection {
    // message fields
    nextDirectiveId: ::std::option::Option<u64>,
    numPools: ::std::option::Option<u32>,
    numDirectives: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CacheManagerSection {
    fn default() -> &'a CacheManagerSection {
        <CacheManagerSection as ::protobuf::Message>::default_instance()
    }
}

impl CacheManagerSection {
    pub fn new() -> CacheManagerSection {
        ::std::default::Default::default()
    }

    // required uint64 nextDirectiveId = 1;


    pub fn get_nextDirectiveId(&self) -> u64 {
        self.nextDirectiveId.unwrap_or(0)
    }
    pub fn clear_nextDirectiveId(&mut self) {
        self.nextDirectiveId = ::std::option::Option::None;
    }

    pub fn has_nextDirectiveId(&self) -> bool {
        self.nextDirectiveId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nextDirectiveId(&mut self, v: u64) {
        self.nextDirectiveId = ::std::option::Option::Some(v);
    }

    // required uint32 numPools = 2;


    pub fn get_numPools(&self) -> u32 {
        self.numPools.unwrap_or(0)
    }
    pub fn clear_numPools(&mut self) {
        self.numPools = ::std::option::Option::None;
    }

    pub fn has_numPools(&self) -> bool {
        self.numPools.is_some()
    }

    // Param is passed by value, moved
    pub fn set_numPools(&mut self, v: u32) {
        self.numPools = ::std::option::Option::Some(v);
    }

    // required uint32 numDirectives = 3;


    pub fn get_numDirectives(&self) -> u32 {
        self.numDirectives.unwrap_or(0)
    }
    pub fn clear_numDirectives(&mut self) {
        self.numDirectives = ::std::option::Option::None;
    }

    pub fn has_numDirectives(&self) -> bool {
        self.numDirectives.is_some()
    }

    // Param is passed by value, moved
    pub fn set_numDirectives(&mut self, v: u32) {
        self.numDirectives = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CacheManagerSection {
    fn is_initialized(&self) -> bool {
        if self.nextDirectiveId.is_none() {
            return false;
        }
        if self.numPools.is_none() {
            return false;
        }
        if self.numDirectives.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.nextDirectiveId = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.numPools = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.numDirectives = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.nextDirectiveId {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.numPools {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.numDirectives {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.nextDirectiveId {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.numPools {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.numDirectives {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CacheManagerSection {
        CacheManagerSection::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "nextDirectiveId",
                |m: &CacheManagerSection| { &m.nextDirectiveId },
                |m: &mut CacheManagerSection| { &mut m.nextDirectiveId },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "numPools",
                |m: &CacheManagerSection| { &m.numPools },
                |m: &mut CacheManagerSection| { &mut m.numPools },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "numDirectives",
                |m: &CacheManagerSection| { &m.numDirectives },
                |m: &mut CacheManagerSection| { &mut m.numDirectives },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CacheManagerSection>(
                "CacheManagerSection",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CacheManagerSection {
        static instance: ::protobuf::rt::LazyV2<CacheManagerSection> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CacheManagerSection::new)
    }
}

impl ::protobuf::Clear for CacheManagerSection {
    fn clear(&mut self) {
        self.nextDirectiveId = ::std::option::Option::None;
        self.numPools = ::std::option::Option::None;
        self.numDirectives = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CacheManagerSection {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CacheManagerSection {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ErasureCodingSection {
    // message fields
    pub policies: ::protobuf::RepeatedField<super::hdfs::ErasureCodingPolicyProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ErasureCodingSection {
    fn default() -> &'a ErasureCodingSection {
        <ErasureCodingSection as ::protobuf::Message>::default_instance()
    }
}

impl ErasureCodingSection {
    pub fn new() -> ErasureCodingSection {
        ::std::default::Default::default()
    }

    // repeated .hadoop.hdfs.ErasureCodingPolicyProto policies = 1;


    pub fn get_policies(&self) -> &[super::hdfs::ErasureCodingPolicyProto] {
        &self.policies
    }
    pub fn clear_policies(&mut self) {
        self.policies.clear();
    }

    // Param is passed by value, moved
    pub fn set_policies(&mut self, v: ::protobuf::RepeatedField<super::hdfs::ErasureCodingPolicyProto>) {
        self.policies = v;
    }

    // Mutable pointer to the field.
    pub fn mut_policies(&mut self) -> &mut ::protobuf::RepeatedField<super::hdfs::ErasureCodingPolicyProto> {
        &mut self.policies
    }

    // Take field
    pub fn take_policies(&mut self) -> ::protobuf::RepeatedField<super::hdfs::ErasureCodingPolicyProto> {
        ::std::mem::replace(&mut self.policies, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ErasureCodingSection {
    fn is_initialized(&self) -> bool {
        for v in &self.policies {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.policies)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.policies {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.policies {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ErasureCodingSection {
        ErasureCodingSection::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::hdfs::ErasureCodingPolicyProto>>(
                "policies",
                |m: &ErasureCodingSection| { &m.policies },
                |m: &mut ErasureCodingSection| { &mut m.policies },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ErasureCodingSection>(
                "ErasureCodingSection",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ErasureCodingSection {
        static instance: ::protobuf::rt::LazyV2<ErasureCodingSection> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ErasureCodingSection::new)
    }
}

impl ::protobuf::Clear for ErasureCodingSection {
    fn clear(&mut self) {
        self.policies.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ErasureCodingSection {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ErasureCodingSection {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\rfsimage.proto\x12\x0bhadoop.hdfs\x1a\nhdfs.proto\x1a\tacl.proto\x1a\
    \x0bxattr.proto\"\x8e\x02\n\x0bFileSummary\x12&\n\rondiskVersion\x18\x01\
    \x20\x02(\rR\rondiskVersionB\0\x12&\n\rlayoutVersion\x18\x02\x20\x02(\rR\
    \rlayoutVersionB\0\x12\x16\n\x05codec\x18\x03\x20\x01(\tR\x05codecB\0\
    \x12>\n\x08sections\x18\x04\x20\x03(\x0b2\x20.hadoop.hdfs.FileSummary.Se\
    ctionR\x08sectionsB\0\x1aU\n\x07Section\x12\x14\n\x04name\x18\x01\x20\
    \x01(\tR\x04nameB\0\x12\x18\n\x06length\x18\x02\x20\x01(\x04R\x06lengthB\
    \0\x12\x18\n\x06offset\x18\x03\x20\x01(\x04R\x06offsetB\0:\0:\0\"\x87\
    \x03\n\x11NameSystemSection\x12\"\n\x0bnamespaceId\x18\x01\x20\x01(\rR\
    \x0bnamespaceIdB\0\x12\x20\n\ngenstampV1\x18\x02\x20\x01(\x04R\ngenstamp\
    V1B\0\x12\x20\n\ngenstampV2\x18\x03\x20\x01(\x04R\ngenstampV2B\0\x12*\n\
    \x0fgenstampV1Limit\x18\x04\x20\x01(\x04R\x0fgenstampV1LimitB\0\x124\n\
    \x14lastAllocatedBlockId\x18\x05\x20\x01(\x04R\x14lastAllocatedBlockIdB\
    \0\x12&\n\rtransactionId\x18\x06\x20\x01(\x04R\rtransactionIdB\0\x12:\n\
    \x17rollingUpgradeStartTime\x18\x07\x20\x01(\x04R\x17rollingUpgradeStart\
    TimeB\0\x12B\n\x1blastAllocatedStripedBlockId\x18\x08\x20\x01(\x04R\x1bl\
    astAllocatedStripedBlockIdB\0:\0\"\x94\x11\n\x0cINodeSection\x12\"\n\x0b\
    lastInodeId\x18\x01\x20\x01(\x04R\x0blastInodeIdB\0\x12\x1e\n\tnumInodes\
    \x18\x02\x20\x01(\x04R\tnumInodesB\0\x1aj\n\x1cFileUnderConstructionFeat\
    ure\x12\x20\n\nclientName\x18\x01\x20\x01(\tR\nclientNameB\0\x12&\n\rcli\
    entMachine\x18\x02\x20\x01(\tR\rclientMachineB\0:\0\x1a1\n\x0fAclFeature\
    Proto\x12\x1c\n\x07entries\x18\x02\x20\x03(\x07R\x07entriesB\x02\x10\x01\
    :\0\x1aC\n\x11XAttrCompactProto\x12\x14\n\x04name\x18\x01\x20\x02(\x07R\
    \x04nameB\0\x12\x16\n\x05value\x18\x02\x20\x01(\x0cR\x05valueB\0:\0\x1a\
    \\\n\x11XAttrFeatureProto\x12E\n\x06xAttrs\x18\x01\x20\x03(\x0b2+.hadoop\
    .hdfs.INodeSection.XAttrCompactProtoR\x06xAttrsB\0:\0\x1a\x81\x05\n\tINo\
    deFile\x12\"\n\x0breplication\x18\x01\x20\x01(\rR\x0breplicationB\0\x12,\
    \n\x10modificationTime\x18\x02\x20\x01(\x04R\x10modificationTimeB\0\x12\
    \x20\n\naccessTime\x18\x03\x20\x01(\x04R\naccessTimeB\0\x120\n\x12prefer\
    redBlockSize\x18\x04\x20\x01(\x04R\x12preferredBlockSizeB\0\x12\x20\n\np\
    ermission\x18\x05\x20\x01(\x06R\npermissionB\0\x121\n\x06blocks\x18\x06\
    \x20\x03(\x0b2\x17.hadoop.hdfs.BlockProtoR\x06blocksB\0\x12P\n\x06fileUC\
    \x18\x07\x20\x01(\x0b26.hadoop.hdfs.INodeSection.FileUnderConstructionFe\
    atureR\x06fileUCB\0\x12=\n\x03acl\x18\x08\x20\x01(\x0b2).hadoop.hdfs.INo\
    deSection.AclFeatureProtoR\x03aclB\0\x12E\n\x06xAttrs\x18\t\x20\x01(\x0b\
    2+.hadoop.hdfs.INodeSection.XAttrFeatureProtoR\x06xAttrsB\0\x12*\n\x0fst\
    oragePolicyID\x18\n\x20\x01(\rR\x0fstoragePolicyIDB\0\x12;\n\tblockType\
    \x18\x0b\x20\x01(\x0e2\x1b.hadoop.hdfs.BlockTypeProtoR\tblockTypeB\0\x12\
    6\n\x15erasureCodingPolicyID\x18\x0c\x20\x01(\rR\x15erasureCodingPolicyI\
    DB\0:\0\x1a{\n\x1cQuotaByStorageTypeEntryProto\x12A\n\x0bstorageType\x18\
    \x01\x20\x02(\x0e2\x1d.hadoop.hdfs.StorageTypeProtoR\x0bstorageTypeB\0\
    \x12\x16\n\x05quota\x18\x02\x20\x02(\x04R\x05quotaB\0:\0\x1at\n\x1eQuota\
    ByStorageTypeFeatureProto\x12P\n\x06quotas\x18\x01\x20\x03(\x0b26.hadoop\
    .hdfs.INodeSection.QuotaByStorageTypeEntryProtoR\x06quotasB\0:\0\x1a\xfc\
    \x02\n\x0eINodeDirectory\x12,\n\x10modificationTime\x18\x01\x20\x01(\x04\
    R\x10modificationTimeB\0\x12\x1a\n\x07nsQuota\x18\x02\x20\x01(\x04R\x07n\
    sQuotaB\0\x12\x1a\n\x07dsQuota\x18\x03\x20\x01(\x04R\x07dsQuotaB\0\x12\
    \x20\n\npermission\x18\x04\x20\x01(\x06R\npermissionB\0\x12=\n\x03acl\
    \x18\x05\x20\x01(\x0b2).hadoop.hdfs.INodeSection.AclFeatureProtoR\x03acl\
    B\0\x12E\n\x06xAttrs\x18\x06\x20\x01(\x0b2+.hadoop.hdfs.INodeSection.XAt\
    trFeatureProtoR\x06xAttrsB\0\x12Z\n\ntypeQuotas\x18\x07\x20\x01(\x0b28.h\
    adoop.hdfs.INodeSection.QuotaByStorageTypeFeatureProtoR\ntypeQuotasB\0:\
    \0\x1a\x9c\x01\n\x0cINodeSymlink\x12\x20\n\npermission\x18\x01\x20\x01(\
    \x06R\npermissionB\0\x12\x18\n\x06target\x18\x02\x20\x01(\x0cR\x06target\
    B\0\x12,\n\x10modificationTime\x18\x03\x20\x01(\x04R\x10modificationTime\
    B\0\x12\x20\n\naccessTime\x18\x04\x20\x01(\x04R\naccessTimeB\0:\0\x1a\
    \xe6\x02\n\x05INode\x12:\n\x04type\x18\x01\x20\x02(\x0e2$.hadoop.hdfs.IN\
    odeSection.INode.TypeR\x04typeB\0\x12\x10\n\x02id\x18\x02\x20\x02(\x04R\
    \x02idB\0\x12\x14\n\x04name\x18\x03\x20\x01(\x0cR\x04nameB\0\x129\n\x04f\
    ile\x18\x04\x20\x01(\x0b2#.hadoop.hdfs.INodeSection.INodeFileR\x04fileB\
    \0\x12H\n\tdirectory\x18\x05\x20\x01(\x0b2(.hadoop.hdfs.INodeSection.INo\
    deDirectoryR\tdirectoryB\0\x12B\n\x07symlink\x18\x06\x20\x01(\x0b2&.hado\
    op.hdfs.INodeSection.INodeSymlinkR\x07symlinkB\0\".\n\x04Type\x12\x08\n\
    \x04FILE\x10\x01\x12\r\n\tDIRECTORY\x10\x02\x12\x0b\n\x07SYMLINK\x10\x03\
    \x1a\0:\0:\0\"{\n\x1dFilesUnderConstructionSection\x1aX\n\x1aFileUnderCo\
    nstructionEntry\x12\x1a\n\x07inodeId\x18\x01\x20\x01(\x04R\x07inodeIdB\0\
    \x12\x1c\n\x08fullPath\x18\x02\x20\x01(\tR\x08fullPathB\0:\0:\0\"\x87\
    \x01\n\x15INodeDirectorySection\x1al\n\x08DirEntry\x12\x18\n\x06parent\
    \x18\x01\x20\x01(\x04R\x06parentB\0\x12\x1e\n\x08children\x18\x02\x20\
    \x03(\x04R\x08childrenB\x02\x10\x01\x12$\n\x0brefChildren\x18\x03\x20\
    \x03(\rR\x0brefChildrenB\x02\x10\x01:\0:\0\"\xb8\x01\n\x15INodeReference\
    Section\x1a\x9c\x01\n\x0eINodeReference\x12\x20\n\nreferredId\x18\x01\
    \x20\x01(\x04R\nreferredIdB\0\x12\x14\n\x04name\x18\x02\x20\x01(\x0cR\
    \x04nameB\0\x12&\n\rdstSnapshotId\x18\x03\x20\x01(\rR\rdstSnapshotIdB\0\
    \x12(\n\x0elastSnapshotId\x18\x04\x20\x01(\rR\x0elastSnapshotIdB\0:\0:\0\
    \"\xfc\x01\n\x0fSnapshotSection\x12*\n\x0fsnapshotCounter\x18\x01\x20\
    \x01(\rR\x0fsnapshotCounterB\0\x12.\n\x10snapshottableDir\x18\x02\x20\
    \x03(\x04R\x10snapshottableDirB\x02\x10\x01\x12$\n\x0cnumSnapshots\x18\
    \x03\x20\x01(\rR\x0cnumSnapshotsB\0\x1ae\n\x08Snapshot\x12\x20\n\nsnapsh\
    otId\x18\x01\x20\x01(\rR\nsnapshotIdB\0\x125\n\x04root\x18\x02\x20\x01(\
    \x0b2\x1f.hadoop.hdfs.INodeSection.INodeR\x04rootB\0:\0:\0\"\xd2\x06\n\
    \x13SnapshotDiffSection\x1a*\n\x10CreatedListEntry\x12\x14\n\x04name\x18\
    \x01\x20\x01(\x0cR\x04nameB\0:\0\x1a\xeb\x02\n\rDirectoryDiff\x12\x20\n\
    \nsnapshotId\x18\x01\x20\x01(\rR\nsnapshotIdB\0\x12$\n\x0cchildrenSize\
    \x18\x02\x20\x01(\rR\x0cchildrenSizeB\0\x12(\n\x0eisSnapshotRoot\x18\x03\
    \x20\x01(\x08R\x0eisSnapshotRootB\0\x12\x14\n\x04name\x18\x04\x20\x01(\
    \x0cR\x04nameB\0\x12N\n\x0csnapshotCopy\x18\x05\x20\x01(\x0b2(.hadoop.hd\
    fs.INodeSection.INodeDirectoryR\x0csnapshotCopyB\0\x12*\n\x0fcreatedList\
    Size\x18\x06\x20\x01(\rR\x0fcreatedListSizeB\0\x12&\n\x0cdeletedINode\
    \x18\x07\x20\x03(\x04R\x0cdeletedINodeB\x02\x10\x01\x12,\n\x0fdeletedINo\
    deRef\x18\x08\x20\x03(\rR\x0fdeletedINodeRefB\x02\x10\x01:\0\x1a\xe0\x01\
    \n\x08FileDiff\x12\x20\n\nsnapshotId\x18\x01\x20\x01(\rR\nsnapshotIdB\0\
    \x12\x1c\n\x08fileSize\x18\x02\x20\x01(\x04R\x08fileSizeB\0\x12\x14\n\
    \x04name\x18\x03\x20\x01(\x0cR\x04nameB\0\x12I\n\x0csnapshotCopy\x18\x04\
    \x20\x01(\x0b2#.hadoop.hdfs.INodeSection.INodeFileR\x0csnapshotCopyB\0\
    \x121\n\x06blocks\x18\x05\x20\x03(\x0b2\x17.hadoop.hdfs.BlockProtoR\x06b\
    locksB\0:\0\x1a\xbb\x01\n\tDiffEntry\x12E\n\x04type\x18\x01\x20\x02(\x0e\
    2/.hadoop.hdfs.SnapshotDiffSection.DiffEntry.TypeR\x04typeB\0\x12\x1a\n\
    \x07inodeId\x18\x02\x20\x01(\x04R\x07inodeIdB\0\x12\x1e\n\tnumOfDiff\x18\
    \x03\x20\x01(\rR\tnumOfDiffB\0\")\n\x04Type\x12\x0c\n\x08FILEDIFF\x10\
    \x01\x12\x11\n\rDIRECTORYDIFF\x10\x02\x1a\0:\0:\0\"\x86\x01\n\x12StringT\
    ableSection\x12\x1c\n\x08numEntry\x18\x01\x20\x01(\rR\x08numEntryB\0\x12\
    \x1f\n\x08maskBits\x18\x02\x20\x01(\r:\x010R\x08maskBitsB\0\x1a/\n\x05En\
    try\x12\x10\n\x02id\x18\x01\x20\x01(\rR\x02idB\0\x12\x12\n\x03str\x18\
    \x02\x20\x01(\tR\x03strB\0:\0:\0\"\xb0\x04\n\x14SecretManagerSection\x12\
    \x1e\n\tcurrentId\x18\x01\x20\x01(\rR\tcurrentIdB\0\x122\n\x13tokenSeque\
    nceNumber\x18\x02\x20\x01(\rR\x13tokenSequenceNumberB\0\x12\x1a\n\x07num\
    Keys\x18\x03\x20\x01(\rR\x07numKeysB\0\x12\x1e\n\tnumTokens\x18\x04\x20\
    \x01(\rR\tnumTokensB\0\x1aY\n\rDelegationKey\x12\x10\n\x02id\x18\x01\x20\
    \x01(\rR\x02idB\0\x12\x20\n\nexpiryDate\x18\x02\x20\x01(\x04R\nexpiryDat\
    eB\0\x12\x12\n\x03key\x18\x03\x20\x01(\x0cR\x03keyB\0:\0\x1a\xaa\x02\n\
    \x0cPersistToken\x12\x1a\n\x07version\x18\x01\x20\x01(\rR\x07versionB\0\
    \x12\x16\n\x05owner\x18\x02\x20\x01(\tR\x05ownerB\0\x12\x1a\n\x07renewer\
    \x18\x03\x20\x01(\tR\x07renewerB\0\x12\x1c\n\x08realUser\x18\x04\x20\x01\
    (\tR\x08realUserB\0\x12\x1e\n\tissueDate\x18\x05\x20\x01(\x04R\tissueDat\
    eB\0\x12\x1a\n\x07maxDate\x18\x06\x20\x01(\x04R\x07maxDateB\0\x12(\n\x0e\
    sequenceNumber\x18\x07\x20\x01(\rR\x0esequenceNumberB\0\x12\"\n\x0bmaste\
    rKeyId\x18\x08\x20\x01(\rR\x0bmasterKeyIdB\0\x12\x20\n\nexpiryDate\x18\t\
    \x20\x01(\x04R\nexpiryDateB\0:\0:\0\"\x89\x01\n\x13CacheManagerSection\
    \x12*\n\x0fnextDirectiveId\x18\x01\x20\x02(\x04R\x0fnextDirectiveIdB\0\
    \x12\x1c\n\x08numPools\x18\x02\x20\x02(\rR\x08numPoolsB\0\x12&\n\rnumDir\
    ectives\x18\x03\x20\x02(\rR\rnumDirectivesB\0:\0\"]\n\x14ErasureCodingSe\
    ction\x12C\n\x08policies\x18\x01\x20\x03(\x0b2%.hadoop.hdfs.ErasureCodin\
    gPolicyProtoR\x08policiesB\0:\0B\0b\x06proto2\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
